#!/usr/bin/perl -w
#
# PERL front-end to the effective-sample size tools
#
#


#  This file is part of LOOS.
#
#  LOOS (Lightweight Object-Oriented Structure library)
#  Copyright (c) 2010, Tod D. Romo
#  Department of Biochemistry and Biophysics
#  School of Medicine & Dentistry, University of Rochester
#
#  This package (LOOS) is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation under version 3 of the License.
#
#  This package is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.



use FileHandle;
use Getopt::Long;



my $prefix;
my $nbins = 20;
my $nreps = 10;
my $model_name;
my $traj_name;
my $selection;
my $verbosity = 1;


# Suffixes generated by the various tools we'll call...
my @suffixes = qw/.log _assignments.asc .states .dcd .pdb .samples/;
my $backup = '.bak';


my $hdr = &header($0, \@ARGV);

my $ok = GetOptions(
		    "prefix=s" => \$prefix,
		    "nbins=i" => \$nbins,
		    "nreps=i" => \$nreps,
		    "verbosity=i" => \$verbosity,
		    "help" => sub { &showHelp; }
		   );

&showHelp if (!$ok || $#ARGV != 2);

$model_name = shift;
$traj_name = shift;
$selection = shift;

if (!defined($prefix)) {
  if ($model_name =~ /\./) {
    $model_name =~ /^(.+)\..+?$/;
    $prefix = $1;
  } else {
    $prefix = $model_name;
  }

  $prefix .= '.neff';
}

my $nframes = &getNumberOfFrames($model_name, $traj_name);
my $frac = 1.0 / $nbins;
my $binsize = int($nframes / $nbins);
my $range = $binsize * $nbins - 1;

print "# $hdr\n# binsize=$binsize, frac=$frac, range=$range\n";
print "# iter\tneff\tneff Total\n";

my @neffs;

for (my $i=0; $i<$nreps; ++$i) {
  &runCommand("ufidpick $model_name $traj_name 0:$range '$selection' $prefix $frac >& $prefix.log");
  &runCommand("hierarchy ${prefix}_assignments.asc >$prefix.states");
  &runCommand("neff ${prefix}_assignments.asc $prefix.states $binsize >$prefix.samples");

  my $neff = &extractNeff("$prefix.samples");
  defined($neff) || die "Error- cannot find effective sample size in neff output ($prefix.samples)";
  if ($verbosity) {
    printf "%-3d\t%f\t%f\n", $i, $neff, $neff * $nbins;
  }
  push(@neffs, $neff);
}

my $mean = &average(\@neffs);
my $std = &stddev(\@neffs, $mean);

print "# Average effective sample size = $mean += $std\n";

my $total_samples = $mean * $nbins;
my $total_std = $std * $nbins;

print "# Total samples = $total_samples += $total_std\n";

my $low_td = $range/($total_samples + $total_std);
my $high_td = $range/($total_samples - $total_std);
print "# Effective Td = $low_td - $high_td\n";



#############################################################


sub average {
  my $ra = shift;

  my $avg = 0.0;
  foreach (@$ra) {
    $avg += $_;
  }

  return($avg / ($#$ra + 1));
}


sub stddev {
  my $ra = shift;
  my $m = shift;

  my $s = 0.0;
  foreach (@$ra) {
    my $d = $_ - $m;
    $s += $d*$d;
  }

  return(sqrt($s / $#$ra));
}



sub runCommand {
  my $cmd = shift;

  print STDERR "# $cmd\n" if ($verbosity > 1);
  my $failed = system($cmd);
  die "Error- '$cmd' failed with code ", $failed >> 8 if ($failed);
}




sub extractNeff {
  my $fn = shift;
  my $fh = new FileHandle $fn;
  defined($fh) || die "Error- cannot open neff output file $fn";

  while (<$fh>) {
    chomp;
    if (/^Segment effective sample size = (.+)$/) {
      return($1);
    }
  }

  return(undef);
}



sub getNumberOfFrames {
  my $model = shift;
  my $traj = shift;

  my $fh = new FileHandle "trajinfo -b $model $traj 2>&1|";
  defined($fh) || die "Error- cannot open pipe from trajinfo command";

  my $dummy = <$fh>;
  my @ary = split(/\s+/, $dummy);
  $#ary == 3 || die "Error- trajinfo command gave bad results";
  return($ary[1]);
}


sub header {
  my $prog = shift;
  my $ra = shift;

  my $hdr = $prog . ' ';
  foreach (@$ra) {
    $hdr .= '\'' . $_ . '\' ';
  }
  chop($hdr);
  return($hdr);
}


sub showHelp {
  print <<EOF;
Usage- effsize.pl [options] model traj selection

Options:
        --help        This message
    --prefix=s        Prefix for intermmediate files
     --nbins=i (20)   Number of bins to use to partition space
     --nreps=i (10)   Number of times to repeat analysis
 --verbosity=i (1)    How verbose output is during operation
EOF
  exit(0);
}
