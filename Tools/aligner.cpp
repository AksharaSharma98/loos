/*
  aligner.cpp


  Aligns structures in a trajectory...

*/




/*

  This file is part of LOOS.

  LOOS (Lightweight Object-Oriented Structure library)
  Copyright (c) 2008, Tod D. Romo
  Department of Biochemistry and Biophysics
  School of Medicine & Dentistry, University of Rochester

  This package (LOOS) is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation under version 3 of the License.

  This package is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


#include <loos.hpp>

using namespace std;
using namespace loos;

namespace opts = loos::OptionsFramework;
namespace po = loos::OptionsFramework::po;





// @cond TOOLS_INTERNAL
string fullHelpMessage(void) {
  string msg =
    "\n"
    "SYNOPSIS\n"
    "Aligns the structures in a trajectory\n"
    "\n"
    "DESCRIPTION\n"
    "\taligner can align a trajectory two different ways: an optimal alignment of all structures,\n"
    "or aligning all structures to a reference structure.  The optimal alignment uses an iterative\n"
    "algorithm (described in Grossfield, et al. Proteins 67, 31â€“40 (2007)).  The latter method\n"
    "uses a Kabsch least-squares algorithm to superimpose each frame of the trajectory onto the\n"
    "reference structure.\n"
    "\taligner can take multiple selections to govern what is aligned.  The --selection option\n"
    "determines what subset of atoms from the trajectory is used in computing the alignment\n"
    "transformation for each frame.  The --transform option determines which atoms from the\n"
    "trajectory the alignment transformation is applied to.  Only these atoms are written out\n"
    "to the DCD file generated by aligner.  Note that the default --transform selection is 'all',\n"
    "so if you want to align alpha-carbons and only output alpha-carbons, you will need to provide\n"
    "the same selection (i.e. \"name == 'CA'\") to both options.\n"
    "\tWhen aligning to a reference structure, the selection given in --selection is used for\n"
    "both the trajectory and the reference structure.  Sometimes, however, the selection expression\n"
    "for the trajectory does not match the reference structure (e.g. aligning a trajectory to a\n"
    "crystal structure).  In this case, use the --refsel option to specify a different selection\n"
    "expression for the reference structure.  Note that the atoms must be in the same order as\n"
    "the ones picked by the trajectory --selection (i.e. the first atom from the reference subset\n"
    "must match the first atom in the trajectory subset, etc).\n"
    "\n"
    "\n"
    "EXAMPLES\n"
    "\n"
    "\taligner --prefix b2ar-aligned b2ar.pdb b2ar.dcd\n"
    "Aligns the trajectory based on the default selection (alpha-carbons).  All atoms are transformed\n"
    "and the model is written to b2ar-aligned.pdb and the aligned trajectory is written to\n"
    "b2ar-aligned.dcd\n"
    "\n"
    "\taligner --prefix aligned --transform 'name =~ \"^(C|O|N|CA)$\"' model.pdb traj.dcd\n"
    "Aligns the trajectory based on the default selection (alpha-carbons).  Only backbone atoms are\n"
    "transformed.  Creates aligned.pdb and aligned.dcd\n"
    "\n"
    "\taligner --prefix aligned --selection 'segid == \"HEME\"' \\\n"
    "\t  --transform 'segid == \"PROT\" || segid == \"HEME\"' model.pdb traj.dcd\n"
    "Aligns the trajectory based on atoms with segid 'HEME'.  Only transforms protein and heme atoms\n"
    "\n"
    "\taligner --prefix aligned --reference xtal.pdb model.pdb traj.dcd\n"
    "Aligns using alpha-carbons, transforming all atoms, but align the trajectory to the structure\n"
    "in xtal.pdb\n"
    "\n"
    "\taligner --prefix aligned --reference xtal.pdb \\\n"
    "\t  --refsel 'resid >= 30 && resid <= 60 && name == \"CA\"' \\\n"
    "\t  --selection 'resid >= 10 && resid <= 40 && name == \"CA\"' model.pdb traj.dcd\n"
    "Aligns against a reference structure.  Uses alpha-carbons from residues 30-60 in the reference\n"
    "structure, aligned against alpha-carbons from residues 10-40 from the trajectory.  All atoms\n"
    "in the trajectory are transformed.\n"
    "\n"
    "NOTES\n"
    "\n"
    "\tAligner will cache all frames/alignment segments in memory to align,\n"
    "so beware of swapping with big trajectories\n";

  return(msg);
}



class ToolOptions : public opts::OptionsPackage {
public:
  ToolOptions() : alignment_string("name == 'CA'"),
                  transform_string("all"),
                  reference_name(""),
                  reference_sel(""),
                  alignment_tol(1e-6),
                  maxiter(5000),
                  center(true) { }

  void addGeneric(po::options_description& o) {
    o.add_options()
      ("align", po::value<string>(&alignment_string)->default_value(alignment_string), "Align using this selection")
      ("transform", po::value<string>(&transform_string)->default_value(transform_string), "Transform using this selection")
      ("maxiter", po::value<uint>(&maxiter)->default_value(maxiter), "Maximum number of iterations for alignment algorith")
      ("tolerance", po::value<double>(&alignment_tol)->default_value(alignment_tol), "Tolerance for alignment convergence")
      ("center", po::value<bool>(&center)->default_value(center), "Auto-center the trajectory using the alignment subset")
      ("reference", po::value<string>(&reference_name), "Align to a reference structure (non-iterative")
      ("refsel", po::value<string>(&reference_sel), "Selection to align against in reference (default is same as --align)");
  }

  string alignment_string, transform_string;
  string reference_name, reference_sel;
  double alignment_tol;
  uint maxiter;
  bool center;
};


// @endcond



void centerFrame(AtomicGroup& src, AtomicGroup& trg) {
  GCoord c = src.centroid();
  trg.translate(-c);
}

void savePDB(const string& fname, const string& meta, const AtomicGroup& grp) {
  AtomicGroup dup = grp.copy();
  PDB pdb = PDB::fromAtomicGroup(dup);
  pdb.pruneBonds();
  pdb.renumber();
  pdb.remarks().add(meta);
  ofstream ofs(fname.c_str());
  ofs << pdb;
}




int main(int argc, char *argv[]) {

  // Parse command-line options, cache invocation header for later use...
  string header = invocationHeader(argc, argv);
  opts::BasicOptions* bopts = new opts::BasicOptions(fullHelpMessage());
  opts::OutputPrefix* prefopts = new opts::OutputPrefix;
  opts::TrajectoryWithFrameIndices* tropts = new opts::TrajectoryWithFrameIndices;
  ToolOptions* topts = new ToolOptions;

  opts::AggregateOptions options;
  options.add(bopts).add(prefopts).add(tropts).add(topts);
  if (!options.parse(argc, argv))
    exit(-1);

  // Read the inputs...
  AtomicGroup model = tropts->model;
  pTraj traj = tropts->trajectory;

  // Get the selections (subsets) to operate over
  AtomicGroup align_sub = selectAtoms(model, topts->alignment_string);

  AtomicGroup applyto_sub = selectAtoms(model, topts->transform_string);

  // Now do the alignin'...
  vector<uint> indices = tropts->frameList();
  unsigned int nframes = indices.size();

  
  if (topts->reference_name.empty()) {

    // Read in the trajectory frames and extract the coordinates for the
    // aligning subset...
    vector<AtomicGroup> frames;
    for (vector<uint>::iterator i = indices.begin(); i != indices.end(); ++i) {
      traj->readFrame(*i);
      traj->updateGroupCoords(align_sub);
      AtomicGroup subcopy = align_sub.copy();
      frames.push_back(subcopy);
    }
    
    boost::tuple<vector<XForm>,greal, int> res = iterativeAlignment(frames, topts->alignment_tol, topts->maxiter);
    greal final_rmsd = boost::get<1>(res);
    cerr << "Final RMSD between average structures is " << final_rmsd << endl;
    cerr << "Total iters = " << boost::get<2>(res) << endl;
    
    vector<XForm> xforms = boost::get<0>(res);
    
    // Zzzzap our stored groups...
    frames.clear();
    
    // Setup for writing DCD...
    DCDWriter dcdout(prefopts->prefix + ".dcd");
    dcdout.setHeader(applyto_sub.size(), nframes, 1e-3, traj->hasPeriodicBox());
    dcdout.setTitle(header);
    dcdout.writeHeader();
    
    // Now apply the alignment transformations to the requested subsets
    for (unsigned int i = 0; i<nframes; i++) {
      traj->readFrame(i);
      traj->updateGroupCoords(model);
      model.applyTransform(xforms[i]);
      
      if (topts->center)
        centerFrame(align_sub, applyto_sub);
      dcdout.writeFrame(applyto_sub);
      
      if (i == 0) 
        savePDB(prefopts->prefix + ".pdb", header, applyto_sub);
    }
    
  } else {
    
    AtomicGroup reference = createSystem(topts->reference_name);
    
    string refsel = topts->reference_sel.empty() ? topts->alignment_string : topts->reference_sel;
    AtomicGroup refsub = selectAtoms(reference, refsel);

    if (refsub.size() != align_sub.size()) {
      cerr << boost::format("ERROR- alignment subset has %d atoms but reference subset has %d.  They must match.\n") % align_sub.size() % refsub.size();
      exit(-10);
    }

    DCDWriter dcdout(prefopts->prefix + ".dcd");
    dcdout.setHeader(applyto_sub.size(), nframes, 1e-3, traj->hasPeriodicBox());
    dcdout.setTitle(header);
    dcdout.writeHeader();


    bool first = true;
    for (vector<uint>::iterator i = indices.begin(); i != indices.end(); ++i) {
      traj->readFrame(*i);
      traj->updateGroupCoords(model);
      GMatrix M = align_sub.superposition(refsub);
      XForm W(M);
      applyto_sub.applyTransform(W);

      if (topts->center)
        centerFrame(align_sub, applyto_sub);
      dcdout.writeFrame(applyto_sub);

      if (first) {
        savePDB(prefopts->prefix + ".pdb", header, applyto_sub);
        first = false;
      }
    }

  }
}



    
