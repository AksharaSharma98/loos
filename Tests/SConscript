#!/usr/bin/env python
#  This file is part of LOOS.
#
#  LOOS (Lightweight Object-Oriented Structure library)
#  Copyright (c) 2008, Tod D. Romo
#  Department of Biochemistry and Biophysics
#  School of Medicine & Dentistry, University of Rochester
#
#  This package (LOOS) is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation under version 3 of the License.
#
#  This package is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.


#   _____  ______ _____  _____  ______ _____       _______ ______ _____  
#  |  __ \|  ____|  __ \|  __ \|  ____/ ____|   /\|__   __|  ____|  __ \ 
#  | |  | | |__  | |__) | |__) | |__ | |       /  \  | |  | |__  | |  | |
#  | |  | |  __| |  ___/|  _  /|  __|| |      / /\ \ | |  |  __| | |  | |
#  | |__| | |____| |    | | \ \| |___| |____ / ____ \| |  | |____| |__| |
#  |_____/|______|_|    |_|  \_\______\_____/_/    \_\_|  |______|_____/ 
#
#
# This directory is deprecated and may be removed in future versions of LOOS
#

                                                                      

Import('env')
clone = env.Clone()
clone.Prepend(LIBS = ['loos'])


### Major uglage ensues...  Close your eyes if you're squeamish...

### This is adapted from Matt Doar's UnitTest work ( see http://www.scons.org/wiki/UnitTests )

import os
import sys
import subprocess
def run(cmd, env):
    """Run a Unix command and return the exit code."""
    res = os.system(cmd)
    if (os.WIFEXITED(res)):
        code = os.WEXITSTATUS(res)
        return code
    # Assumes that if a process doesn't call exit, it was successful
    return 0

def unit_test_emitter(target, source, env):
    head,tail = os.path.split(source[0].abspath)
    newsrc = os.path.join(head, str(env['host_type']), tail)
    base, ext = os.path.splitext(newsrc)

    if env['REGENERATE'] != '1':
        source.append(base + '.expected')

    target = [base + '.passed']
    target.append(base + '.output')
    target.append(base + '.error')
    return (target, source)

def UnitTest(target, source, env):
    '''Run some app with an inputfile and compare the output with a .expected file
    containing the expected results.'''
    app = str(source[0].abspath)
    
    outputfile = str(target[0].abspath)

    if len(source) == 1:
        inputfile = ''
    else:
        inputfile = str(source[1].abspath)

    head,tail = os.path.split(source[0].abspath)
    newsrc = os.path.join(head, str(env['host_type']), tail)
    base, ext = os.path.splitext(newsrc)
    expected = base + ".expected"
    output = base + ".output"
    outerr = base + ".error"

    # Output can come on both stdout and stderr


    cmd = app + ' ' + inputfile + ' >' + output + ' 2>' + outerr
    res = run(cmd, env)


    if env['REGENERATE'] == '1':
        print "Regenerating expected results file: " + expected
        cmd = 'cat ' + output + ' ' + outerr + ' >' + expected
        run(cmd, env)
        return 0
    else:
        cmd = 'cat ' + output + ' ' + outerr + ' | diff - ' + expected
        res = run(cmd, env)

    # If the test passed, create the target file so the test won't be run again
    if res != 0:
        print "*** ERROR - Differences in test output from " + str(source[0])
    else:
	cmd = 'touch ' + str(target[0].abspath)
	run(cmd, env)

    return 0

# Create a builder for running unit tests
bld = Builder(action = Action(UnitTest, varlist = ['REGENERATE']), emitter = unit_test_emitter)
env.Append(BUILDERS = {'UnitTest' :  bld})

### Ok, you can open 'em now...

non_testable_tests = 'timeseries-test find_perf_test ccpdb_test pdbtraj_test tinker_arc_test rewind-test'
pdb_based_tests = 'pdb-tests alignment-tests parser-tests pdb-echo'
tinker_tests = 'tinkerxyz-tests'
solo_tests = 'principal-axes-tests atomic-group-test timeseries-test matrix_test hybrid36 within-test'

# This is the master list of dependencies to pass to our caller...
list = []

if sys.platform == 'darwin':
    env.AppendENVPath('DYLD_LIBRARY_PATH', '#')
    os.environ['DYLD_LIBRARY_PATH'] = env['ENV']['DYLD_LIBRARY_PATH']
else:
    env.AppendENVPath('LD_LIBRARY_PATH', '#')
    os.environ['LD_LIBRARY_PATH'] = env['ENV']['LD_LIBRARY_PATH']

# First, process non-testable tests...
for name in Split(non_testable_tests):
    fname = name + '.cpp'
    prog = clone.Program(fname)
    list.append(prog)

# Now run the tests that take no inputs...
for name in Split(solo_tests):
    fname = name + '.cpp'
    tname = name
    prog = clone.Program(fname)
    test = env.UnitTest(tname, [prog])
    list.append(test)


# Now run the tests that take a PDB input...
for name in Split(pdb_based_tests):
    fname = name + '.cpp'
    tname = name
    prog = clone.Program(fname)
    test = env.UnitTest(tname, [prog, 'test.pdb'])
    list.append(test)

# Now run the tests that take a Tinker input...
for name in Split(tinker_tests):
    fname = name + '.cpp'
    tname = name
    prog = clone.Program(fname)
    test = env.UnitTest(tname, [prog, 'test.xyz'])
    list.append(test)


Return('list')
