#!/usr/bin/env python
#  This file is part of LOOS.
#
#  LOOS (Lightweight Object-Oriented Structure library)
#  Copyright (c) 2008, Tod D. Romo
#  Department of Biochemistry and Biophysics
#  School of Medicine & Dentistry, University of Rochester
#
#  This package (LOOS) is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation under version 3 of the License.
#
#  This package is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.


Import('env')
clone = env.Clone()
clone.Append(LIBS = ['loos'])


### Major uglage ensues...  Close your eyes if you're squeamish...

### This is adapted from Matt Doar's UnitTest work ( see http://www.scons.org/wiki/UnitTests )

import os
import sys
def run(cmd, env):
    """Run a Unix command and return the exit code."""
    res = os.system(cmd)
    if (os.WIFEXITED(res)):
        code = os.WEXITSTATUS(res)
        return code
    # Assumes that if a process doesn't call exit, it was successful
    return 0

def unit_test_emitter(target, source, env):
    head,tail = os.path.split(source[0].abspath)
    newsrc = os.path.join(head, str(env['platform']), tail)
    base, ext = os.path.splitext(newsrc)

    if env['REGENERATE'] != '1':
        source.append(base + '.expected')

    target = [base + '.passed']
    target.append(base + '.output')
    target.append(base + '.error')
    return (target, source)

def UnitTest(target, source, env):
    '''Run some app with an inputfile and compare the output with a .expected file
    containing the expected results.'''
    app = str(source[0].abspath)
    
    outputfile = str(target[0].abspath)

    if len(source) == 1:
        inputfile = ''
    else:
        inputfile = str(source[1].abspath)

    head,tail = os.path.split(source[0].abspath)
    newsrc = os.path.join(head, str(env['platform']), tail)
    base, ext = os.path.splitext(newsrc)
    expected = base + ".expected"
    output = base + ".output"
    outerr = base + ".error"

    # Output can come on both stdout and stderr


    cmd = app + ' ' + inputfile + ' >' + output + ' 2>' + outerr
    res = run(cmd, env)


    if env['REGENERATE'] == '1':
        print "Regenerating expected results file: " + expected
        cmd = 'cat ' + output + ' ' + outerr + ' >' + expected
        run(cmd, env)
        return 0
    else:
        cmd = 'cat ' + output + ' ' + outerr + ' | diff - ' + expected
        res = run(cmd, env)

    # If the test passed, create the target file so the test won't be run again
    if res != 0:
        print "*** ERROR - Differences in test output from " + str(source[0])
    else:
	cmd = 'touch ' + str(target[0].abspath)
	run(cmd, env)

    return 0

# Create a builder for running unit tests
bld = Builder(action = Action(UnitTest, varlist = ['REGENERATE']), emitter = unit_test_emitter)
env.Append(BUILDERS = {'UnitTest' :  bld})

### Ok, you can open 'em now...
if env.has_key('LD_LIBRARY_PATH'):
    if os.environ.has_key('LD_LIBRARY_PATH'):
        ld_path = os.environ['LD_LIBRARY_PATH']
        os.environ['LD_LIBRARY_PATH'] = env['LD_LIBRARY_PATH'] + ":" + ld_path
    else:
        os.environ['LD_LIBARY_PATH' ] = env['LD_LIBRARY_PATH']

non_testable_tests = 'timeseries-test find_perf_test ccpdb_test pdbtraj_test tinker_arc_test'
pdb_based_tests = 'pdb-tests alignment-tests parser-tests pdb-echo'
tinker_tests = 'tinkerxyz-tests'
solo_tests = 'principal-axes-tests atomic-group-test timeseries-test matrix_test'

script_tests = 'dumpmol.sh'


# This is the master list of dependencies to pass to our caller...
list = []

# First, process non-testable tests...
for name in Split(non_testable_tests):
    fname = name + '.cpp'
    prog = clone.Program(fname)
    list.append(prog)

# Now run the tests that take no inputs...
for name in Split(solo_tests):
    fname = name + '.cpp'
    tname = name
    prog = clone.Program(fname)
    test = env.UnitTest(tname, [prog])
    list.append(test)


# Now run the tests that take a PDB input...
for name in Split(pdb_based_tests):
    fname = name + '.cpp'
    tname = name
    prog = clone.Program(fname)
    test = env.UnitTest(tname, [prog, 'test.pdb'])
    list.append(test)

# Now run the tests that take a Tinker input...
for name in Split(tinker_tests):
    fname = name + '.cpp'
    tname = name
    prog = clone.Program(fname)
    test = env.UnitTest(tname, [prog, 'test.xyz'])
    list.append(test)


for name in Split(script_tests):
    test = env.UnitTest(name)
    list.append(test)


Return('list')
