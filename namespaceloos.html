<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LOOS: loos Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LOOS
   &#160;<span id="projectnumber">v3.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceloos.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">loos Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for most things not already encapsulated within a class.  
<a href="namespaceloos.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceloos_1_1_density_tools"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_density_tools.html">DensityTools</a></td></tr>
<tr class="memdesc:namespaceloos_1_1_density_tools"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for Density package. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceloos_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1internal.html">internal</a></td></tr>
<tr class="memdesc:namespaceloos_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loos esoterica. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceloos_1_1_math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html">Math</a></td></tr>
<tr class="memdesc:namespaceloos_1_1_math"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for math and math-related things in loos. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceloos_1_1_options_framework"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_options_framework.html">OptionsFramework</a></td></tr>
<tr class="memdesc:namespaceloos_1_1_options_framework"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for encapsulating options processing. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_abstract_observer.html">AbstractObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_amber.html">Amber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading in AMBER parmtop/coord files...  <a href="classloos_1_1_amber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_amber_netcdf.html">AmberNetcdf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading <a class="el" href="classloos_1_1_amber.html" title="Class for reading in AMBER parmtop/coord files...">Amber</a> Trajectories in NetCDF format.  <a href="classloos_1_1_amber_netcdf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_amber_rst.html">AmberRst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading amber restart files as a single-frame trajectory.  <a href="classloos_1_1_amber_rst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_amber_traj.html">AmberTraj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading amber coordinate trajectories.  <a href="classloos_1_1_amber_traj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_and_selector.html">AndSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two selectors with a logical "and".  <a href="structloos_1_1_and_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_ascending_sort.html">AscendingSort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy class for sorting in ascending sequence.  <a href="classloos_1_1_ascending_sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atom.html">Atom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic <a class="el" href="classloos_1_1_atom.html" title="Basic Atom class for handling atom properties.">Atom</a> class for handling atom properties.  <a href="classloos_1_1_atom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_atom_coords_equals.html">AtomCoordsEquals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two atoms based on name, id, resid, resname, segid, and coords.  <a href="structloos_1_1_atom_coords_equals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_atom_equals.html">AtomEquals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two atoms based solely on name, id, resid, resname, and segid.  <a href="structloos_1_1_atom_equals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling groups of Atoms (pAtoms, actually)  <a href="classloos_1_1_atomic_group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_atom_name_selector.html">AtomNameSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting atoms based on explicit name matching.  <a href="structloos_1_1_atom_name_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_atom_selector.html">AtomSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base-class for selecting atoms from a group.  <a href="structloos_1_1_atom_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_backbone_selector.html">BackboneSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting backbone.  <a href="classloos_1_1_backbone_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_basic_progress.html">BasicProgress</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_bound_fmt.html">BoundFmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal helper class to bind formatting state.  <a href="structloos_1_1_bound_fmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_c_alpha_selector.html">CAlphaSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting CA atoms.  <a href="structloos_1_1_c_alpha_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_c_c_p_d_b.html">CCPDB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for interpreting concatenated <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> files as a <a class="el" href="classloos_1_1_trajectory.html" title="Base-class for polymorphic trajectories.">Trajectory</a>.  <a href="classloos_1_1_c_c_p_d_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_c_h_a_r_m_m.html">CHARMM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading a <a class="el" href="classloos_1_1_c_h_a_r_m_m.html" title="Class for reading a CHARMM coordinate file.">CHARMM</a> coordinate file.  <a href="classloos_1_1_c_h_a_r_m_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_coord.html">Coord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic 3-D coordinates class.  <a href="classloos_1_1_coord.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_d_c_d.html">DCD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading <a class="el" href="classloos_1_1_d_c_d.html" title="Class for reading DCD files.">DCD</a> files.  <a href="classloos_1_1_d_c_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_d_c_d_writer.html">DCDWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <em>very</em> lightweight class for writing simple DCDs.  <a href="classloos_1_1_d_c_d_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_descending_sort.html">DescendingSort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy class for sorting in descending sequence.  <a href="classloos_1_1_descending_sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_estimating_counter.html">EstimatingCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A progress counter that can estimate how much time is left.  <a href="classloos_1_1_estimating_counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_file_error.html">FileError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Errors related to File I/O.  <a href="classloos_1_1_file_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_file_open_error.html">FileOpenError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error while opening a file.  <a href="classloos_1_1_file_open_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_file_read_error.html">FileReadError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Errors that occur while reading a file.  <a href="classloos_1_1_file_read_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_file_read_error_with_line.html">FileReadErrorWithLine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Errors that occur while reading a text file (where lines are tracked)  <a href="classloos_1_1_file_read_error_with_line.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_file_write_error.html">FileWriteError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Errors while writing to files.  <a href="classloos_1_1_file_write_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_fmt.html">Fmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output formatter class, adapted from Stroustrup's book.  <a href="classloos_1_1_fmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_gromacs.html">Gromacs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a GROMACS model file (.gro)  <a href="classloos_1_1_gromacs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_h_bond_detector.html">HBondDetector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for detecting hydrogen bonds.  <a href="classloos_1_1_h_bond_detector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_heavy_atom_selector.html">HeavyAtomSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select non-hydrogen atoms.  <a href="structloos_1_1_heavy_atom_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_heavy_solvent_selector.html">HeavySolventSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select only heavy solvent atoms.  <a href="structloos_1_1_heavy_solvent_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_hydrogen_selector.html">HydrogenSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select hydrogen atoms.  <a href="structloos_1_1_hydrogen_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_index_selector.html">IndexSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting atoms based on index.  <a href="structloos_1_1_index_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_kernel.html">Kernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classloos_1_1_kernel.html" title="The Kernel (virtual machine) for compiling and executing user-defined atom selections.">Kernel</a> (virtual machine) for compiling and executing user-defined atom selections.  <a href="classloos_1_1_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_kernel_selector.html">KernelSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selection predicate that executes a compiled <a class="el" href="classloos_1_1_kernel.html" title="The Kernel (virtual machine) for compiling and executing user-defined atom selections.">Kernel</a>.  <a href="classloos_1_1_kernel_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_line_reader.html">LineReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading line-by-line from a file while tracking line numbers and stripping comments.  <a href="classloos_1_1_line_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_l_o_o_s_error.html">LOOSError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic LOOS exception.  <a href="classloos_1_1_l_o_o_s_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_matrix44.html">Matrix44</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized 4x4 Matrix class for handling coordinate transforms.  <a href="classloos_1_1_matrix44.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_matrix_read_error.html">MatrixReadError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic reading error class.  <a href="classloos_1_1_matrix_read_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_read_impl.html">MatrixReadImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_read_impl_3_01_t_00_01_math_1_1_triangular_00_01_s_01_4.html">MatrixReadImpl&lt; T, Math::Triangular, S &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special handling for triangular matrices.  <a href="structloos_1_1_matrix_read_impl_3_01_t_00_01_math_1_1_triangular_00_01_s_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_read_impl_3_01_t_00_01_p_00_01_math_1_1_sparse_array_01_4.html">MatrixReadImpl&lt; T, P, Math::SparseArray &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special handling for sparse matrices.  <a href="structloos_1_1_matrix_read_impl_3_01_t_00_01_p_00_01_math_1_1_sparse_array_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_write_impl.html">MatrixWriteImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_write_impl_3_01_t_00_01_math_1_1_triangular_00_01_s_00_01_f_01_4.html">MatrixWriteImpl&lt; T, Math::Triangular, S, F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out a triangular matrix.  <a href="structloos_1_1_matrix_write_impl_3_01_t_00_01_math_1_1_triangular_00_01_s_00_01_f_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_write_impl_3_01_t_00_01_p_00_01_math_1_1_sparse_array_00_01_f_01_4.html">MatrixWriteImpl&lt; T, P, Math::SparseArray, F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out a sparse matrix.  <a href="structloos_1_1_matrix_write_impl_3_01_t_00_01_p_00_01_math_1_1_sparse_array_00_01_f_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_multi_trajectory.html">MultiTrajectory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine multiple trajectories (pTraj's) into one large virtual trajectory.  <a href="classloos_1_1_multi_trajectory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_not_selector.html">NotSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates a selection predicate.  <a href="structloos_1_1_not_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_numerical_error.html">NumericalError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception caused by a blas/atlas error.  <a href="classloos_1_1_numerical_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_options_error.html">OptionsError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception in options.  <a href="classloos_1_1_options_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_or_selector.html">OrSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two selectors with a logical "or".  <a href="structloos_1_1_or_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_parse_error.html">ParseError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception when parsing input data.  <a href="classloos_1_1_parse_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_parser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Front-end to the Bison/Flex parser.  <a href="classloos_1_1_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_parser_driver.html">ParserDriver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_p_d_b.html">PDB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> reading/writing class.  <a href="classloos_1_1_p_d_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_p_d_b_traj.html">PDBTraj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for intepreting separate <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> files as a single trajectory.  <a href="classloos_1_1_p_d_b_traj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_percent_progress.html">PercentProgress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide feedback by percent-complete.  <a href="classloos_1_1_percent_progress.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_percent_progress_with_time.html">PercentProgressWithTime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_percent_trigger.html">PercentTrigger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger whenever at least frac percent more iterations have happened.  <a href="classloos_1_1_percent_trigger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_periodic_box.html">PeriodicBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing periodic box information.  <a href="classloos_1_1_periodic_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_precise_matrix_formatter.html">PreciseMatrixFormatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic matrix element formatter allowing setting of width and precision.  <a href="classloos_1_1_precise_matrix_formatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_progress_counter.html">ProgressCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The progress counter front-end.  <a href="classloos_1_1_progress_counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_p_s_f.html">PSF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading a subset of the <a class="el" href="classloos_1_1_p_s_f.html" title="Class for reading a subset of the PSF format.">PSF</a> format.  <a href="classloos_1_1_p_s_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_remarks.html">Remarks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> <a class="el" href="classloos_1_1_remarks.html" title="Class for handling PDB Remarks.">Remarks</a>.  <a href="classloos_1_1_remarks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_resid_range_selector.html">ResidRangeSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting atoms from a range of resid's.  <a href="structloos_1_1_resid_range_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_rna_suite.html">RnaSuite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for assigning backbone suites to an RNA.  <a href="classloos_1_1_rna_suite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_scientific_matrix_formatter.html">ScientificMatrixFormatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic matrix element formatter using scientific notation...  <a href="classloos_1_1_scientific_matrix_formatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_segid_selector.html">SegidSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting atoms based on the passed segid string.  <a href="structloos_1_1_segid_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_shared_periodic_box.html">SharedPeriodicBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class manages a shared Periodicbox.  <a href="classloos_1_1_shared_periodic_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_simple_counter.html">SimpleCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic progress counter object, defining the interface...  <a href="classloos_1_1_simple_counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_solvent_selector.html">SolventSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting solvent based on common solvent SEGIDs.  <a href="structloos_1_1_solvent_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_stream_wrapper.html">StreamWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper class for caching stream pointers.  <a href="classloos_1_1_stream_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for tracking time.  <a href="classloos_1_1_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_time_series.html">TimeSeries</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time Series Class.  <a href="classloos_1_1_time_series.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_tinker_arc.html">TinkerArc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling Tinker ARC files (concatenation of .xyz files)  <a href="classloos_1_1_tinker_arc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_tinker_x_y_z.html">TinkerXYZ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading a subset of the <a class="el" href="classloos_1_1_tinker_x_y_z.html" title="Class for reading a subset of the TinkerXYZ format.">TinkerXYZ</a> format.  <a href="classloos_1_1_tinker_x_y_z.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_trajectory.html">Trajectory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base-class for polymorphic trajectories.  <a href="classloos_1_1_trajectory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_trajectory_writer.html">TrajectoryWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for writing trajectories.  <a href="classloos_1_1_trajectory_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_trigger_always.html">TriggerAlways</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple "trigger" for use as a default.  <a href="classloos_1_1_trigger_always.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_trigger_every.html">TriggerEvery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger every i-iterations.  <a href="classloos_1_1_trigger_every.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_t_r_r.html">TRR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the GROMACS <a class="el" href="classloos_1_1_t_r_r.html" title="Class representing the GROMACS TRR trajectory files.">TRR</a> trajectory files.  <a href="classloos_1_1_t_r_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_unique_strings.html">UniqueStrings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for uniquifying strings...  <a href="classloos_1_1_unique_strings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_unit_cell.html">UnitCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class encapsulates crystallographic unit cell data.  <a href="classloos_1_1_unit_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_unset_property.html">UnsetProperty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception when trying to use an unset <a class="el" href="classloos_1_1_atom.html" title="Basic Atom class for handling atom properties.">Atom</a> property.  <a href="classloos_1_1_unset_property.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_user_timer.html">UserTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy class for tracking only user process time.  <a href="classloos_1_1_user_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_wall_timer.html">WallTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy class for tracking wall-time.  <a href="classloos_1_1_wall_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_weights.html">Weights</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_x_d_r_data_size_error.html">XDRDataSizeError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception indicating internal XDR error.  <a href="structloos_1_1_x_d_r_data_size_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_x_form.html">XForm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix class for handling coordinate transforms...  <a href="classloos_1_1_x_form.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_x_t_c.html">XTC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing GROMACS reduced precision, compressed trajectories.  <a href="classloos_1_1_x_t_c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_x_t_c_writer.html">XTCWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for writing <a class="el" href="classloos_1_1_gromacs.html" title="Implements a GROMACS model file (.gro)">Gromacs</a> <a class="el" href="classloos_1_1_x_t_c.html" title="Class representing GROMACS reduced precision, compressed trajectories.">XTC</a> trajectories.  <a href="classloos_1_1_x_t_c_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_z_slice_selector.html">ZSliceSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting atoms in a specific range of z values.  <a href="structloos_1_1_z_slice_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aced2bcc520b7b0b40c0507a5c43046ac"><td class="memItemLeft" align="right" valign="top"><a id="aced2bcc520b7b0b40c0507a5c43046ac"></a>
typedef boost::mt19937&#160;</td><td class="memItemRight" valign="bottom"><b>base_generator_type</b></td></tr>
<tr class="separator:aced2bcc520b7b0b40c0507a5c43046ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8558bdcb5d02e2b03b9c27a54d735eeb"><td class="memItemLeft" align="right" valign="top"><a id="a8558bdcb5d02e2b03b9c27a54d735eeb"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>dcd_double</b></td></tr>
<tr class="separator:a8558bdcb5d02e2b03b9c27a54d735eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677dfeeced2a19ec5d89d43027568663"><td class="memItemLeft" align="right" valign="top"><a id="a677dfeeced2a19ec5d89d43027568663"></a>
typedef float&#160;</td><td class="memItemRight" valign="bottom"><b>dcd_real</b></td></tr>
<tr class="separator:a677dfeeced2a19ec5d89d43027568663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856cdc978cc29744a195f110acba135e"><td class="memItemLeft" align="right" valign="top"><a id="a856cdc978cc29744a195f110acba135e"></a>
typedef <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; double, <a class="el" href="classloos_1_1_math_1_1_col_major.html">Math::ColMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DoubleMatrix</b></td></tr>
<tr class="separator:a856cdc978cc29744a195f110acba135e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6a2951ceb24e0799ad1b9203f79dc7"><td class="memItemLeft" align="right" valign="top"><a id="afa6a2951ceb24e0799ad1b9203f79dc7"></a>
typedef <a class="el" href="classloos_1_1_time_series.html">TimeSeries</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dTimeSeries</b></td></tr>
<tr class="separator:afa6a2951ceb24e0799ad1b9203f79dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2771ad929b3ea94a50cfca5787d23e58"><td class="memItemLeft" align="right" valign="top"><a id="a2771ad929b3ea94a50cfca5787d23e58"></a>
typedef <a class="el" href="classloos_1_1_time_series.html">TimeSeries</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>fTimeSeries</b></td></tr>
<tr class="separator:a2771ad929b3ea94a50cfca5787d23e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92f70e8081d83add2d3192363ce5007"><td class="memItemLeft" align="right" valign="top"><a id="ae92f70e8081d83add2d3192363ce5007"></a>
typedef <a class="el" href="classloos_1_1_coord.html">Coord</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GCoord</b></td></tr>
<tr class="separator:ae92f70e8081d83add2d3192363ce5007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740c959c36933207e26d986abf6b0567"><td class="memItemLeft" align="right" valign="top"><a id="a740c959c36933207e26d986abf6b0567"></a>
typedef long&#160;</td><td class="memItemRight" valign="bottom"><b>gint</b></td></tr>
<tr class="separator:a740c959c36933207e26d986abf6b0567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782e7cbcc7c09168957a9211fa4b2e29"><td class="memItemLeft" align="right" valign="top"><a id="a782e7cbcc7c09168957a9211fa4b2e29"></a>
typedef <a class="el" href="classloos_1_1_matrix44.html">Matrix44</a>&lt; greal &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GMatrix</b></td></tr>
<tr class="separator:a782e7cbcc7c09168957a9211fa4b2e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f9243b5cea9150fda36cf7590898d0"><td class="memItemLeft" align="right" valign="top"><a id="a84f9243b5cea9150fda36cf7590898d0"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>greal</b></td></tr>
<tr class="separator:a84f9243b5cea9150fda36cf7590898d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9382a6038b1de8a4faf0e5a7996bf64a"><td class="memItemLeft" align="right" valign="top"><a id="a9382a6038b1de8a4faf0e5a7996bf64a"></a>
typedef boost::unordered_map&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IMap</b></td></tr>
<tr class="separator:a9382a6038b1de8a4faf0e5a7996bf64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17edd11c76d48f9d9d4f061b17daa3a8"><td class="memItemLeft" align="right" valign="top"><a id="a17edd11c76d48f9d9d4f061b17daa3a8"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_amber.html">Amber</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pAmber</b></td></tr>
<tr class="separator:a17edd11c76d48f9d9d4f061b17daa3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855d432ffd74e681801e2c1194ace334"><td class="memItemLeft" align="right" valign="top"><a id="a855d432ffd74e681801e2c1194ace334"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_amber_rst.html">AmberRst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pAmberRst</b></td></tr>
<tr class="separator:a855d432ffd74e681801e2c1194ace334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516f30b0825b48a234737afacca3d226"><td class="memItemLeft" align="right" valign="top"><a id="a516f30b0825b48a234737afacca3d226"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_amber_traj.html">AmberTraj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pAmberTraj</b></td></tr>
<tr class="separator:a516f30b0825b48a234737afacca3d226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a951283a85ad02410ab26cb955ab98e"><td class="memItemLeft" align="right" valign="top"><a id="a6a951283a85ad02410ab26cb955ab98e"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_atom.html">Atom</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pAtom</b></td></tr>
<tr class="separator:a6a951283a85ad02410ab26cb955ab98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14441c8676772c04dc6d08db44887151"><td class="memItemLeft" align="right" valign="top"><a id="a14441c8676772c04dc6d08db44887151"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pAtomicGroup</b></td></tr>
<tr class="separator:a14441c8676772c04dc6d08db44887151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb1f6a679d7fe27209424a66a84924e"><td class="memItemLeft" align="right" valign="top"><a id="a5eb1f6a679d7fe27209424a66a84924e"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_c_c_p_d_b.html">CCPDB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pCCPDB</b></td></tr>
<tr class="separator:a5eb1f6a679d7fe27209424a66a84924e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635652e3286bd9efcc6fc1df6891622b"><td class="memItemLeft" align="right" valign="top"><a id="a635652e3286bd9efcc6fc1df6891622b"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_c_h_a_r_m_m.html">CHARMM</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pCHARMM</b></td></tr>
<tr class="separator:a635652e3286bd9efcc6fc1df6891622b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec9f315445db2e78b27c67cb36fa987"><td class="memItemLeft" align="right" valign="top"><a id="a9ec9f315445db2e78b27c67cb36fa987"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_d_c_d.html">DCD</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pDCD</b></td></tr>
<tr class="separator:a9ec9f315445db2e78b27c67cb36fa987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7e0568b4d48c6038e4044fdf0924f8"><td class="memItemLeft" align="right" valign="top"><a id="abf7e0568b4d48c6038e4044fdf0924f8"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pGCoord</b></td></tr>
<tr class="separator:abf7e0568b4d48c6038e4044fdf0924f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1497a59287a6f38548981a61928d23b"><td class="memItemLeft" align="right" valign="top"><a id="ad1497a59287a6f38548981a61928d23b"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_gromacs.html">Gromacs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pGromacs</b></td></tr>
<tr class="separator:ad1497a59287a6f38548981a61928d23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f286d70e4968ce09aa08e7a732b168"><td class="memItemLeft" align="right" valign="top"><a id="a05f286d70e4968ce09aa08e7a732b168"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_p_d_b.html">PDB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pPDB</b></td></tr>
<tr class="separator:a05f286d70e4968ce09aa08e7a732b168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2691cf67f6faca31f43efdc33546dc"><td class="memItemLeft" align="right" valign="top"><a id="aef2691cf67f6faca31f43efdc33546dc"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_p_d_b_traj.html">PDBTraj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pPDBTraj</b></td></tr>
<tr class="separator:aef2691cf67f6faca31f43efdc33546dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe933d2904863b2411b00229b2a9f2a8"><td class="memItemLeft" align="right" valign="top"><a id="afe933d2904863b2411b00229b2a9f2a8"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_p_s_f.html">PSF</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pPSF</b></td></tr>
<tr class="separator:afe933d2904863b2411b00229b2a9f2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0944b4e7a7a56c044d1a20d2ad074ac6"><td class="memItemLeft" align="right" valign="top"><a id="a0944b4e7a7a56c044d1a20d2ad074ac6"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_tinker_arc.html">TinkerArc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pTinkerArc</b></td></tr>
<tr class="separator:a0944b4e7a7a56c044d1a20d2ad074ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7682005e76c448015c3f3c52cff510ac"><td class="memItemLeft" align="right" valign="top"><a id="a7682005e76c448015c3f3c52cff510ac"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_tinker_x_y_z.html">TinkerXYZ</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pTinkerXYZ</b></td></tr>
<tr class="separator:a7682005e76c448015c3f3c52cff510ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4adf45fb6d4f597c4a9523944aa467"><td class="memItemLeft" align="right" valign="top"><a id="aeb4adf45fb6d4f597c4a9523944aa467"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_trajectory.html">Trajectory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pTraj</b></td></tr>
<tr class="separator:aeb4adf45fb6d4f597c4a9523944aa467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b72b411fb75a1cf05cf20995059c917"><td class="memItemLeft" align="right" valign="top"><a id="a8b72b411fb75a1cf05cf20995059c917"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_trajectory_writer.html">TrajectoryWriter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pTrajectoryWriter</b></td></tr>
<tr class="separator:a8b72b411fb75a1cf05cf20995059c917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2639bad9abe1e371c2dc06151ac89d70"><td class="memItemLeft" align="right" valign="top"><a id="a2639bad9abe1e371c2dc06151ac89d70"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_t_r_r.html">TRR</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pTRR</b></td></tr>
<tr class="separator:a2639bad9abe1e371c2dc06151ac89d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4e21493305bc8a9649c15fb06a22e0"><td class="memItemLeft" align="right" valign="top"><a id="a6f4e21493305bc8a9649c15fb06a22e0"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_x_t_c.html">XTC</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pXTC</b></td></tr>
<tr class="separator:a6f4e21493305bc8a9649c15fb06a22e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c5acc0cd3789ba45bba2b6fd3066ea"><td class="memItemLeft" align="right" valign="top"><a id="ab4c5acc0cd3789ba45bba2b6fd3066ea"></a>
typedef <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; float, <a class="el" href="classloos_1_1_math_1_1_col_major.html">Math::ColMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RealMatrix</b></td></tr>
<tr class="separator:ab4c5acc0cd3789ba45bba2b6fd3066ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a45e43cc68b6dd5c4088ba26b5b6e1585"><td class="memItemLeft" align="right" valign="top"><a id="a45e43cc68b6dd5c4088ba26b5b6e1585"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>appendCoords</b> (std::vector&lt; std::vector&lt; double &gt; &gt; &amp;M, <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;model, pTraj &amp;traj, const std::vector&lt; uint &gt; &amp;indices, const bool updates=false)</td></tr>
<tr class="separator:a45e43cc68b6dd5c4088ba26b5b6e1585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fa637f8cfa6289d84f12a818071c27"><td class="memItemLeft" align="right" valign="top"><a id="a87fa637f8cfa6289d84f12a818071c27"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>applyTransforms</b> (std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble, std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;xforms)</td></tr>
<tr class="separator:a87fa637f8cfa6289d84f12a818071c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ca80dcc44112f32a37ffe8cb879fff"><td class="memItemLeft" align="right" valign="top"><a id="a58ca80dcc44112f32a37ffe8cb879fff"></a>
std::vector&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a58ca80dcc44112f32a37ffe8cb879fff">assignTrajectoryFrames</a> (const pTraj &amp;traj, const std::string &amp;frame_index_spec, uint skip=0, uint stride=1)</td></tr>
<tr class="memdesc:a58ca80dcc44112f32a37ffe8cb879fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a list of trajectory indices (frame_index_spec supercedes skip) <br /></td></tr>
<tr class="separator:a58ca80dcc44112f32a37ffe8cb879fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34d379cd19a139ee185b55d1e96c724"><td class="memItemLeft" align="right" valign="top"><a id="ad34d379cd19a139ee185b55d1e96c724"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>availableMemory</b> ()</td></tr>
<tr class="separator:ad34d379cd19a139ee185b55d1e96c724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81981b62c6359fcc7efb602a4052b95f"><td class="memItemLeft" align="right" valign="top"><a id="a81981b62c6359fcc7efb602a4052b95f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>availableOutputTrajectoryFileTypes</b> (const std::string &amp;prefix)</td></tr>
<tr class="separator:a81981b62c6359fcc7efb602a4052b95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8aae67eea00e8b5a151880fa6ce2df4"><td class="memItemLeft" align="right" valign="top"><a id="ae8aae67eea00e8b5a151880fa6ce2df4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>availableSystemFileTypes</b> (const std::string &amp;prefix)</td></tr>
<tr class="separator:ae8aae67eea00e8b5a151880fa6ce2df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91abab23d6d7f189b8213077538f4b3b"><td class="memItemLeft" align="right" valign="top"><a id="a91abab23d6d7f189b8213077538f4b3b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>availableTrajectoryFileTypes</b> (const std::string &amp;prefix)</td></tr>
<tr class="separator:a91abab23d6d7f189b8213077538f4b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aefac013fa449999f74fa4e0df8b55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a50aefac013fa449999f74fa4e0df8b55">averageStructure</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;, const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;, pTraj &amp;traj)</td></tr>
<tr class="memdesc:a50aefac013fa449999f74fa4e0df8b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the average structure using all frames in a trajectory.  <a href="namespaceloos.html#a50aefac013fa449999f74fa4e0df8b55">More...</a><br /></td></tr>
<tr class="separator:a50aefac013fa449999f74fa4e0df8b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145b1950c29d680031aaba768f133ce0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a145b1950c29d680031aaba768f133ce0">averageStructure</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;, const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;, pTraj &amp;traj, const std::vector&lt; uint &gt; &amp;indices)</td></tr>
<tr class="memdesc:a145b1950c29d680031aaba768f133ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the average structure from a trajectory reading only certain frames.  <a href="namespaceloos.html#a145b1950c29d680031aaba768f133ce0">More...</a><br /></td></tr>
<tr class="separator:a145b1950c29d680031aaba768f133ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe25ba2b9027123aca28176782570862"><td class="memItemLeft" align="right" valign="top"><a id="abe25ba2b9027123aca28176782570862"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#abe25ba2b9027123aca28176782570862">averageStructure</a> (const std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble)</td></tr>
<tr class="memdesc:abe25ba2b9027123aca28176782570862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the average structure of a set of <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> objects. <br /></td></tr>
<tr class="separator:abe25ba2b9027123aca28176782570862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10ec538bd0a45ef4543c60489fb6a74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#aa10ec538bd0a45ef4543c60489fb6a74">averageStructure</a> (const std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble, const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;xforms)</td></tr>
<tr class="memdesc:aa10ec538bd0a45ef4543c60489fb6a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the average structure of a set of <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> objects.  <a href="namespaceloos.html#aa10ec538bd0a45ef4543c60489fb6a74">More...</a><br /></td></tr>
<tr class="separator:aa10ec538bd0a45ef4543c60489fb6a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa994f20daba9b26f90c194c2c472382"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_coord.html">GCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#aaa994f20daba9b26f90c194c2c472382">boxFromRemarks</a> (const <a class="el" href="classloos_1_1_remarks.html">Remarks</a> &amp;)</td></tr>
<tr class="memdesc:aaa994f20daba9b26f90c194c2c472382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the Alan-style box-size from a <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> <a class="el" href="classloos_1_1_remarks.html" title="Class for handling PDB Remarks.">Remarks</a> block.  <a href="namespaceloos.html#aaa994f20daba9b26f90c194c2c472382">More...</a><br /></td></tr>
<tr class="separator:aaa994f20daba9b26f90c194c2c472382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d683eed7d375c78108025222edae89"><td class="memItemLeft" align="right" valign="top"><a id="a48d683eed7d375c78108025222edae89"></a>
pTrajectoryWriter&#160;</td><td class="memItemRight" valign="bottom"><b>createOutputTrajectory</b> (const std::string &amp;filename, const bool append)</td></tr>
<tr class="separator:a48d683eed7d375c78108025222edae89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345eb4ec3d6cdf14ce032c86e8875d53"><td class="memItemLeft" align="right" valign="top"><a id="a345eb4ec3d6cdf14ce032c86e8875d53"></a>
pTrajectoryWriter&#160;</td><td class="memItemRight" valign="bottom"><b>createOutputTrajectory</b> (const std::string &amp;filename, const std::string &amp;type, const bool append)</td></tr>
<tr class="separator:a345eb4ec3d6cdf14ce032c86e8875d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb266964bdaa10942329c7747adce633"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#acb266964bdaa10942329c7747adce633">createSystem</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:acb266964bdaa10942329c7747adce633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function for reading in structure files.  <a href="namespaceloos.html#acb266964bdaa10942329c7747adce633">More...</a><br /></td></tr>
<tr class="separator:acb266964bdaa10942329c7747adce633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780ea25bfcceb8473e0061e8347ec9a5"><td class="memItemLeft" align="right" valign="top"><a id="a780ea25bfcceb8473e0061e8347ec9a5"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>createSystem</b> (const std::string &amp;filename, const std::string &amp;filetype)</td></tr>
<tr class="separator:a780ea25bfcceb8473e0061e8347ec9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3c6426f2a874bf1b5bbda549a45291"><td class="memItemLeft" align="right" valign="top"><a id="a7c3c6426f2a874bf1b5bbda549a45291"></a>
pAtomicGroup&#160;</td><td class="memItemRight" valign="bottom"><b>createSystemPtr</b> (const std::string &amp;filename)</td></tr>
<tr class="separator:a7c3c6426f2a874bf1b5bbda549a45291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88442242c02d5fba2d8486cf733ca8a"><td class="memItemLeft" align="right" valign="top"><a id="ab88442242c02d5fba2d8486cf733ca8a"></a>
pAtomicGroup&#160;</td><td class="memItemRight" valign="bottom"><b>createSystemPtr</b> (const std::string &amp;filename, const std::string &amp;filetype)</td></tr>
<tr class="separator:ab88442242c02d5fba2d8486cf733ca8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3b7c1613a234d4b4d23f23b5d4af6f"><td class="memItemLeft" align="right" valign="top">pTraj&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a5c3b7c1613a234d4b4d23f23b5d4af6f">createTrajectory</a> (const std::string &amp;, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;)</td></tr>
<tr class="memdesc:a5c3b7c1613a234d4b4d23f23b5d4af6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function for reading in a trajectory file.  <a href="namespaceloos.html#a5c3b7c1613a234d4b4d23f23b5d4af6f">More...</a><br /></td></tr>
<tr class="separator:a5c3b7c1613a234d4b4d23f23b5d4af6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679943e849946c7782c1b0716941d390"><td class="memItemLeft" align="right" valign="top"><a id="a679943e849946c7782c1b0716941d390"></a>
pTraj&#160;</td><td class="memItemRight" valign="bottom"><b>createTrajectory</b> (const std::string &amp;filename, const std::string &amp;filetype, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>
<tr class="separator:a679943e849946c7782c1b0716941d390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce914a61c5001a5a966864f758630ca"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a8ce914a61c5001a5a966864f758630ca">deduceAtomicNumberFromMass</a> (const double mass, const double tolerance=0.1)</td></tr>
<tr class="memdesc:a8ce914a61c5001a5a966864f758630ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce an atomic number from the mass.  <a href="namespaceloos.html#a8ce914a61c5001a5a966864f758630ca">More...</a><br /></td></tr>
<tr class="separator:a8ce914a61c5001a5a966864f758630ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab105c97e5ba3247de8ade1fad86e5708"><td class="memItemLeft" align="right" valign="top"><a id="ab105c97e5ba3247de8ade1fad86e5708"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>extractCoords</b> (const std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble)</td></tr>
<tr class="separator:ab105c97e5ba3247de8ade1fad86e5708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bea8219aacef9d44fdafa407be8c50"><td class="memItemLeft" align="right" valign="top"><a id="a52bea8219aacef9d44fdafa407be8c50"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>extractCoords</b> (const std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble, const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;xforms)</td></tr>
<tr class="separator:a52bea8219aacef9d44fdafa407be8c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363b240e30a710c8f48ad1bc7c08d5a8"><td class="memItemLeft" align="right" valign="top"><a id="a363b240e30a710c8f48ad1bc7c08d5a8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a363b240e30a710c8f48ad1bc7c08d5a8">findBaseName</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a363b240e30a710c8f48ad1bc7c08d5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull off the file name extension (if present) <br /></td></tr>
<tr class="separator:a363b240e30a710c8f48ad1bc7c08d5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6015c531612f5cc23706fde42b78fa"><td class="memItemLeft" align="right" valign="top"><a id="adc6015c531612f5cc23706fde42b78fa"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adc6015c531612f5cc23706fde42b78fa"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fixedSizeFormat</b> (const std::string &amp;s, const uint n)</td></tr>
<tr class="separator:adc6015c531612f5cc23706fde42b78fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea93b358c7f352d1d565cc76651452a"><td class="memTemplParams" colspan="2"><a id="abea93b358c7f352d1d565cc76651452a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abea93b358c7f352d1d565cc76651452a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fixedSizeFormat</b> (const T t, const uint n)</td></tr>
<tr class="separator:abea93b358c7f352d1d565cc76651452a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c8cd790f55130edc6de00f091608c7"><td class="memItemLeft" align="right" valign="top"><a id="a61c8cd790f55130edc6de00f091608c7"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>FormatConectRecords</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_p_d_b.html">PDB</a> &amp;p)</td></tr>
<tr class="separator:a61c8cd790f55130edc6de00f091608c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514899a26c171f6c8048de4e48a289b8"><td class="memItemLeft" align="right" valign="top"><a id="a514899a26c171f6c8048de4e48a289b8"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>FormattedUnitCell</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_unit_cell.html">UnitCell</a> &amp;u)</td></tr>
<tr class="separator:a514899a26c171f6c8048de4e48a289b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dd62fa117e274ec179938359eda8ba"><td class="memItemLeft" align="right" valign="top"><a id="a54dd62fa117e274ec179938359eda8ba"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a54dd62fa117e274ec179938359eda8ba">getNextLine</a> (std::istream &amp;is, int *lineno)</td></tr>
<tr class="memdesc:a54dd62fa117e274ec179938359eda8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next line of input, skipping blanks and stripping comments. <br /></td></tr>
<tr class="separator:a54dd62fa117e274ec179938359eda8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba65865c353e9755c1ac221e7c301de"><td class="memItemLeft" align="right" valign="top"><a id="a8ba65865c353e9755c1ac221e7c301de"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>gridify</b> (<a class="el" href="classloos_1_1_d_c_d.html">DCD</a> &amp;, double *, double *, int[], const std::vector&lt; int &gt;, int, int, double)</td></tr>
<tr class="separator:a8ba65865c353e9755c1ac221e7c301de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01118ab9b5036271c399aedee6eccbb"><td class="memItemLeft" align="right" valign="top"><a id="ab01118ab9b5036271c399aedee6eccbb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ab01118ab9b5036271c399aedee6eccbb">hybrid36AsString</a> (int value, uint fieldsize)</td></tr>
<tr class="memdesc:ab01118ab9b5036271c399aedee6eccbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an int into a hybrid-36 encoded string. <br /></td></tr>
<tr class="separator:ab01118ab9b5036271c399aedee6eccbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9938bb182cff8aeddeb0eb7aac81b09f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a9938bb182cff8aeddeb0eb7aac81b09f">invocationHeader</a> (int, char *[])</td></tr>
<tr class="memdesc:a9938bb182cff8aeddeb0eb7aac81b09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an invocation header.  <a href="namespaceloos.html#a9938bb182cff8aeddeb0eb7aac81b09f">More...</a><br /></td></tr>
<tr class="separator:a9938bb182cff8aeddeb0eb7aac81b09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60e58ede81cd383ae1dab79df2b309f"><td class="memItemLeft" align="right" valign="top"><a id="af60e58ede81cd383ae1dab79df2b309f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#af60e58ede81cd383ae1dab79df2b309f">isFileNetCDF</a> (const std::string &amp;fname)</td></tr>
<tr class="memdesc:af60e58ede81cd383ae1dab79df2b309f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the file is a NetCDF file. <br /></td></tr>
<tr class="separator:af60e58ede81cd383ae1dab79df2b309f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49641765fa93b77284181d6ee83eea86"><td class="memItemLeft" align="right" valign="top"><a id="a49641765fa93b77284181d6ee83eea86"></a>
boost::tuple&lt; std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt;, greal, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterativeAlignment</b> (alignment::vecMatrix &amp;ensemble, greal threshold, int maxiter)</td></tr>
<tr class="separator:a49641765fa93b77284181d6ee83eea86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eb966a6f433cbf170fbfe97dbc1041"><td class="memItemLeft" align="right" valign="top"><a id="aa0eb966a6f433cbf170fbfe97dbc1041"></a>
boost::tuple&lt; std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt;, greal, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterativeAlignment</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, pTraj &amp;traj, greal threshold, int maxiter)</td></tr>
<tr class="separator:aa0eb966a6f433cbf170fbfe97dbc1041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42aeab4c92169da3571c75d3f035ad5"><td class="memItemLeft" align="right" valign="top">boost::tuple&lt; std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt;, greal, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ab42aeab4c92169da3571c75d3f035ad5">iterativeAlignment</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;model, pTraj &amp;traj, const std::vector&lt; uint &gt; &amp;frame_indices, greal threshold=1e-6, int maxiter=1000)</td></tr>
<tr class="memdesc:ab42aeab4c92169da3571c75d3f035ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an iterative superposition by reading in frames from the <a class="el" href="classloos_1_1_trajectory.html" title="Base-class for polymorphic trajectories.">Trajectory</a>.  <a href="namespaceloos.html#ab42aeab4c92169da3571c75d3f035ad5">More...</a><br /></td></tr>
<tr class="separator:ab42aeab4c92169da3571c75d3f035ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832649f67b5fad01e4c3f5102855ae30"><td class="memItemLeft" align="right" valign="top"><a id="a832649f67b5fad01e4c3f5102855ae30"></a>
boost::tuple&lt; std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt;, greal, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterativeAlignment</b> (std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble, greal threshold, int maxiter)</td></tr>
<tr class="separator:a832649f67b5fad01e4c3f5102855ae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b873907a2cd5784dbfd14b20c0f2edb"><td class="memItemLeft" align="right" valign="top"><a id="a8b873907a2cd5784dbfd14b20c0f2edb"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a8b873907a2cd5784dbfd14b20c0f2edb">loadStructureWithCoords</a> (const std::string &amp;model, const std::string &amp;cooords)</td></tr>
<tr class="memdesc:a8b873907a2cd5784dbfd14b20c0f2edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a structure and optional coordinates. <br /></td></tr>
<tr class="separator:a8b873907a2cd5784dbfd14b20c0f2edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a4390bc78763697346c0164da56ad7"><td class="memItemLeft" align="right" valign="top"><a id="af3a4390bc78763697346c0164da56ad7"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>loadStructureWithCoords</b> (const std::string &amp;model_name, const std::string &amp;type, const std::string &amp;coord_name)</td></tr>
<tr class="separator:af3a4390bc78763697346c0164da56ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad172cde7ba10cd0378d767a9c5ece776"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad172cde7ba10cd0378d767a9c5ece776"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_coord.html">Coord</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ad172cde7ba10cd0378d767a9c5ece776">operator*</a> (const <a class="el" href="classloos_1_1_matrix44.html">Matrix44</a>&lt; T &gt; &amp;, const <a class="el" href="classloos_1_1_coord.html">Coord</a>&lt; T &gt; &amp;)</td></tr>
<tr class="separator:ad172cde7ba10cd0378d767a9c5ece776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e6726ac3e8f663fddbd7be4fa472bd"><td class="memItemLeft" align="right" valign="top"><a id="a30e6726ac3e8f663fddbd7be4fa472bd"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const pAtom &amp;lhs, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs)</td></tr>
<tr class="separator:a30e6726ac3e8f663fddbd7be4fa472bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2567359abda91586ae2750e6e2d1d8"><td class="memItemLeft" align="right" valign="top"><a id="ace2567359abda91586ae2750e6e2d1d8"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const pAtom &amp;lhs, const pAtom &amp;rhs)</td></tr>
<tr class="separator:ace2567359abda91586ae2750e6e2d1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9f87a2fbf3583d9e6324cc18df9e5e"><td class="memItemLeft" align="right" valign="top"><a id="aeb9f87a2fbf3583d9e6324cc18df9e5e"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp)</td></tr>
<tr class="separator:aeb9f87a2fbf3583d9e6324cc18df9e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addba2db09fd04a563c820e465b4aa6c6"><td class="memItemLeft" align="right" valign="top"><a id="addba2db09fd04a563c820e465b4aa6c6"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#addba2db09fd04a563c820e465b4aa6c6">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structloos_1_1_bound_fmt.html">BoundFmt</a> &amp;bf)</td></tr>
<tr class="memdesc:addba2db09fd04a563c820e465b4aa6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the output with the specified formatter. <br /></td></tr>
<tr class="separator:addba2db09fd04a563c820e465b4aa6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8a1af5ac9fdf234a1fddd0e9dc7c62"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ade8a1af5ac9fdf234a1fddd0e9dc7c62">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_gromacs.html">Gromacs</a> &amp;g)</td></tr>
<tr class="memdesc:ade8a1af5ac9fdf234a1fddd0e9dc7c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the group as a GRO...  <a href="namespaceloos.html#ade8a1af5ac9fdf234a1fddd0e9dc7c62">More...</a><br /></td></tr>
<tr class="separator:ade8a1af5ac9fdf234a1fddd0e9dc7c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f289489846eda89983722a4cf7ebd81"><td class="memItemLeft" align="right" valign="top"><a id="a0f289489846eda89983722a4cf7ebd81"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_kernel.html">Kernel</a> &amp;k)</td></tr>
<tr class="separator:a0f289489846eda89983722a4cf7ebd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c25f1b6fdc4247d26e71ba3db2da2f"><td class="memItemLeft" align="right" valign="top"><a id="ac2c25f1b6fdc4247d26e71ba3db2da2f"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_atom.html">loos::Atom</a> &amp;a)</td></tr>
<tr class="separator:ac2c25f1b6fdc4247d26e71ba3db2da2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383e865fa6a6e7a88c696a449fbf7c2b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a383e865fa6a6e7a88c696a449fbf7c2b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_p_d_b.html">PDB</a> &amp;p)</td></tr>
<tr class="memdesc:a383e865fa6a6e7a88c696a449fbf7c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the group as a <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a>...  <a href="namespaceloos.html#a383e865fa6a6e7a88c696a449fbf7c2b">More...</a><br /></td></tr>
<tr class="separator:a383e865fa6a6e7a88c696a449fbf7c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7ce15a19bf0392a1d0e469ff133ba1"><td class="memItemLeft" align="right" valign="top"><a id="adc7ce15a19bf0392a1d0e469ff133ba1"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_remarks.html">Remarks</a> &amp;r)</td></tr>
<tr class="separator:adc7ce15a19bf0392a1d0e469ff133ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd6cbeb3a85a7eca37465041b39479f"><td class="memTemplParams" colspan="2"><a id="a1fd6cbeb3a85a7eca37465041b39479f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1fd6cbeb3a85a7eca37465041b39479f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_timer.html">Timer</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="separator:a1fd6cbeb3a85a7eca37465041b39479f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a934b70913b38a1bb2aa4c0fecf32d0"><td class="memItemLeft" align="right" valign="top">vector&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a3a934b70913b38a1bb2aa4c0fecf32d0">parseIndexRange</a> (const std::string &amp;input, const uint maxsize)</td></tr>
<tr class="memdesc:a3a934b70913b38a1bb2aa4c0fecf32d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use boost::Spirit to parse a new-style range list.  <a href="namespaceloos.html#a3a934b70913b38a1bb2aa4c0fecf32d0">More...</a><br /></td></tr>
<tr class="separator:a3a934b70913b38a1bb2aa4c0fecf32d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef82d7e98c0493c76dfad5621043b43c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef82d7e98c0493c76dfad5621043b43c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#aef82d7e98c0493c76dfad5621043b43c">parseRange</a> (const std::string &amp;text, const T endpoint=0)</td></tr>
<tr class="memdesc:aef82d7e98c0493c76dfad5621043b43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an Octave/Matlab-style range.  <a href="namespaceloos.html#aef82d7e98c0493c76dfad5621043b43c">More...</a><br /></td></tr>
<tr class="separator:aef82d7e98c0493c76dfad5621043b43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750b5d795f43978407dc4e9127c7db03"><td class="memItemLeft" align="right" valign="top"><a id="a750b5d795f43978407dc4e9127c7db03"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a750b5d795f43978407dc4e9127c7db03">parseRangeList</a> (const std::string &amp;, const int endpoint=0)</td></tr>
<tr class="memdesc:a750b5d795f43978407dc4e9127c7db03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a list of Octave-style range specifiers (for compatability) <br /></td></tr>
<tr class="separator:a750b5d795f43978407dc4e9127c7db03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163ccbfeb984c222e3e50813e47b7b47"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a163ccbfeb984c222e3e50813e47b7b47"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a163ccbfeb984c222e3e50813e47b7b47">parseRangeList</a> (const std::string &amp;text, const T endpoint=0)</td></tr>
<tr class="memdesc:a163ccbfeb984c222e3e50813e47b7b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a comma-separated list of Octave-style ranges.  <a href="namespaceloos.html#a163ccbfeb984c222e3e50813e47b7b47">More...</a><br /></td></tr>
<tr class="separator:a163ccbfeb984c222e3e50813e47b7b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0281788c276087db41945cdb097444"><td class="memTemplParams" colspan="2"><a id="a1e0281788c276087db41945cdb097444"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e0281788c276087db41945cdb097444"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a1e0281788c276087db41945cdb097444">parseRangeList</a> (const std::vector&lt; std::string &gt; &amp;ranges, const T endpoint=0)</td></tr>
<tr class="memdesc:a1e0281788c276087db41945cdb097444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a list of Octave-style ranges taken from a vector of strings. <br /></td></tr>
<tr class="separator:a1e0281788c276087db41945cdb097444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8810a947ea516380336323ac9f98dc07"><td class="memTemplParams" colspan="2"><a id="a8810a947ea516380336323ac9f98dc07"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8810a947ea516380336323ac9f98dc07"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a8810a947ea516380336323ac9f98dc07">parseStringAs</a> (const std::string &amp;source, const uint pos=0, const uint nelem=0)</td></tr>
<tr class="memdesc:a8810a947ea516380336323ac9f98dc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a field from a string. <br /></td></tr>
<tr class="separator:a8810a947ea516380336323ac9f98dc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dc2fc2f2753b7714a41fbedb227189"><td class="memItemLeft" align="right" valign="top"><a id="a49dc2fc2f2753b7714a41fbedb227189"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a49dc2fc2f2753b7714a41fbedb227189"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseStringAs&lt; std::string &gt;</b> (const std::string &amp;source, const uint pos, const uint nelem)</td></tr>
<tr class="separator:a49dc2fc2f2753b7714a41fbedb227189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bc7f779a522f273b9437a8280b60ee"><td class="memItemLeft" align="right" valign="top"><a id="a79bc7f779a522f273b9437a8280b60ee"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a79bc7f779a522f273b9437a8280b60ee">parseStringAsHybrid36</a> (const std::string &amp;source, const uint pos=0, const uint nelem=0)</td></tr>
<tr class="memdesc:a79bc7f779a522f273b9437a8280b60ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a hybrid-36 encoded string into an int. <br /></td></tr>
<tr class="separator:a79bc7f779a522f273b9437a8280b60ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ade6e7564c4aa077a6f3134c6252663"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a6ade6e7564c4aa077a6f3134c6252663">randomSeedRNG</a> (void)</td></tr>
<tr class="memdesc:a6ade6e7564c4aa077a6f3134c6252663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly seeds the RNG.  <a href="namespaceloos.html#a6ade6e7564c4aa077a6f3134c6252663">More...</a><br /></td></tr>
<tr class="separator:a6ade6e7564c4aa077a6f3134c6252663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a3560aa8e85ffb32803693e189f46d"><td class="memTemplParams" colspan="2"><a id="a36a3560aa8e85ffb32803693e189f46d"></a>
template&lt;class T , class P , template&lt; typename &gt; class S&gt; </td></tr>
<tr class="memitem:a36a3560aa8e85ffb32803693e189f46d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a36a3560aa8e85ffb32803693e189f46d">readAsciiMatrix</a> (const std::string &amp;fname)</td></tr>
<tr class="memdesc:a36a3560aa8e85ffb32803693e189f46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a matrix from a file returning a newly created matrix. <br /></td></tr>
<tr class="separator:a36a3560aa8e85ffb32803693e189f46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e77d0692564a911b561299a64fdf7f6"><td class="memTemplParams" colspan="2"><a id="a6e77d0692564a911b561299a64fdf7f6"></a>
template&lt;class T , class P , template&lt; typename &gt; class S&gt; </td></tr>
<tr class="memitem:a6e77d0692564a911b561299a64fdf7f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a6e77d0692564a911b561299a64fdf7f6">readAsciiMatrix</a> (const std::string &amp;fname, <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M)</td></tr>
<tr class="memdesc:a6e77d0692564a911b561299a64fdf7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a matrix from a file storing it in the specified matrix. <br /></td></tr>
<tr class="separator:a6e77d0692564a911b561299a64fdf7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a53a1fdb183bce924a2b8697237c31"><td class="memTemplParams" colspan="2"><a id="ad1a53a1fdb183bce924a2b8697237c31"></a>
template&lt;class T , class P , template&lt; typename &gt; class S&gt; </td></tr>
<tr class="memitem:ad1a53a1fdb183bce924a2b8697237c31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ad1a53a1fdb183bce924a2b8697237c31">readAsciiMatrix</a> (std::istream &amp;is)</td></tr>
<tr class="memdesc:ad1a53a1fdb183bce924a2b8697237c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a matrix from a stream returning a newly created matrix. <br /></td></tr>
<tr class="separator:ad1a53a1fdb183bce924a2b8697237c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e01762bdfa3c9270476cac1bed6eb06"><td class="memTemplParams" colspan="2"><a id="a4e01762bdfa3c9270476cac1bed6eb06"></a>
template&lt;class T , class P , template&lt; typename &gt; class S&gt; </td></tr>
<tr class="memitem:a4e01762bdfa3c9270476cac1bed6eb06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a4e01762bdfa3c9270476cac1bed6eb06">readAsciiMatrix</a> (std::istream &amp;is, <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M)</td></tr>
<tr class="memdesc:a4e01762bdfa3c9270476cac1bed6eb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a matrix from a stream storing it in the specified matrix. <br /></td></tr>
<tr class="separator:a4e01762bdfa3c9270476cac1bed6eb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa577aee0e745597b4ed2ca0588c4be"><td class="memItemLeft" align="right" valign="top"><a id="a4aa577aee0e745597b4ed2ca0588c4be"></a>
std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>readCoords</b> (<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;model, pTraj &amp;traj, const std::vector&lt; uint &gt; &amp;indices, const bool updates=false)</td></tr>
<tr class="separator:a4aa577aee0e745597b4ed2ca0588c4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404022ec67bffdf139bea816da702ec6"><td class="memTemplParams" colspan="2"><a id="a404022ec67bffdf139bea816da702ec6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a404022ec67bffdf139bea816da702ec6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a404022ec67bffdf139bea816da702ec6">readTable</a> (const std::string &amp;fname)</td></tr>
<tr class="memdesc:a404022ec67bffdf139bea816da702ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a table given a filename. <br /></td></tr>
<tr class="separator:a404022ec67bffdf139bea816da702ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6652c219629008baddc12e6209a8c590"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6652c219629008baddc12e6209a8c590"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a6652c219629008baddc12e6209a8c590">readTable</a> (<a class="el" href="classloos_1_1_line_reader.html">LineReader</a> &amp;reader)</td></tr>
<tr class="memdesc:a6652c219629008baddc12e6209a8c590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a table of items using a <a class="el" href="classloos_1_1_line_reader.html" title="Class for reading line-by-line from a file while tracking line numbers and stripping comments.">LineReader</a> object.  <a href="namespaceloos.html#a6652c219629008baddc12e6209a8c590">More...</a><br /></td></tr>
<tr class="separator:a6652c219629008baddc12e6209a8c590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58c4029e4cae718f7b6e11a53655440"><td class="memTemplParams" colspan="2"><a id="ae58c4029e4cae718f7b6e11a53655440"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae58c4029e4cae718f7b6e11a53655440"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ae58c4029e4cae718f7b6e11a53655440">readTable</a> (std::istream &amp;is)</td></tr>
<tr class="memdesc:ae58c4029e4cae718f7b6e11a53655440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a table given a stream. <br /></td></tr>
<tr class="separator:ae58c4029e4cae718f7b6e11a53655440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b08e1ea35c0b41c4ef7c023ddc66008"><td class="memItemLeft" align="right" valign="top"><a id="a0b08e1ea35c0b41c4ef7c023ddc66008"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>readTrajectory</b> (std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;model, pTraj trajectory)</td></tr>
<tr class="separator:a0b08e1ea35c0b41c4ef7c023ddc66008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78afa41f5adfbea531e21eb6619b3ac5"><td class="memItemLeft" align="right" valign="top"><a id="a78afa41f5adfbea531e21eb6619b3ac5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>readTrajectory</b> (std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;model, pTraj trajectory, std::vector&lt; uint &gt; &amp;frames)</td></tr>
<tr class="separator:a78afa41f5adfbea531e21eb6619b3ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924b19197b15f3d4ddb0bbe7269927a6"><td class="memTemplParams" colspan="2"><a id="a924b19197b15f3d4ddb0bbe7269927a6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a924b19197b15f3d4ddb0bbe7269927a6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a924b19197b15f3d4ddb0bbe7269927a6">readVector</a> (const std::string &amp;fname)</td></tr>
<tr class="memdesc:a924b19197b15f3d4ddb0bbe7269927a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a list of items from a file with default behavior. <br /></td></tr>
<tr class="separator:a924b19197b15f3d4ddb0bbe7269927a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad402d8c3aa16082e4187b60d61f2687c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad402d8c3aa16082e4187b60d61f2687c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ad402d8c3aa16082e4187b60d61f2687c">readVector</a> (<a class="el" href="classloos_1_1_line_reader.html">LineReader</a> &amp;reader)</td></tr>
<tr class="memdesc:ad402d8c3aa16082e4187b60d61f2687c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a list of items using a <a class="el" href="classloos_1_1_line_reader.html" title="Class for reading line-by-line from a file while tracking line numbers and stripping comments.">LineReader</a> object.  <a href="namespaceloos.html#ad402d8c3aa16082e4187b60d61f2687c">More...</a><br /></td></tr>
<tr class="separator:ad402d8c3aa16082e4187b60d61f2687c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c4fcef4f427eeca90408b24b0d775a"><td class="memTemplParams" colspan="2"><a id="af7c4fcef4f427eeca90408b24b0d775a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af7c4fcef4f427eeca90408b24b0d775a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#af7c4fcef4f427eeca90408b24b0d775a">readVector</a> (std::istream &amp;is)</td></tr>
<tr class="memdesc:af7c4fcef4f427eeca90408b24b0d775a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a list of items from a stream with default behavior. <br /></td></tr>
<tr class="separator:af7c4fcef4f427eeca90408b24b0d775a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99d766080fbbeea698c4c68594f9341"><td class="memItemLeft" align="right" valign="top"><a id="aa99d766080fbbeea698c4c68594f9341"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#aa99d766080fbbeea698c4c68594f9341">remarksHasBox</a> (const <a class="el" href="classloos_1_1_remarks.html">Remarks</a> &amp;)</td></tr>
<tr class="memdesc:aa99d766080fbbeea698c4c68594f9341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="classloos_1_1_remarks.html" title="Class for handling PDB Remarks.">Remarks</a> block has an Alan-style box size in it. <br /></td></tr>
<tr class="separator:aa99d766080fbbeea698c4c68594f9341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82436be3d1bfa01542d6a8f3820a38b"><td class="memItemLeft" align="right" valign="top">base_generator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ab82436be3d1bfa01542d6a8f3820a38b">rng_singleton</a> (void)</td></tr>
<tr class="memdesc:ab82436be3d1bfa01542d6a8f3820a38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suite-wide random number generator singleton.  <a href="namespaceloos.html#ab82436be3d1bfa01542d6a8f3820a38b">More...</a><br /></td></tr>
<tr class="separator:ab82436be3d1bfa01542d6a8f3820a38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bd1f2095f292abfd3b70f9415a9d57"><td class="memItemLeft" align="right" valign="top"><a id="a91bd1f2095f292abfd3b70f9415a9d57"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a91bd1f2095f292abfd3b70f9415a9d57">sanitizeString</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a91bd1f2095f292abfd3b70f9415a9d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes internal newlines from string. <br /></td></tr>
<tr class="separator:a91bd1f2095f292abfd3b70f9415a9d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ad12706a6b9884cc8f3a5677a899e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a01ad12706a6b9884cc8f3a5677a899e3">selectAtoms</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;, const std::string)</td></tr>
<tr class="memdesc:a01ad12706a6b9884cc8f3a5677a899e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a string-based selection to an atomic group...  <a href="namespaceloos.html#a01ad12706a6b9884cc8f3a5677a899e3">More...</a><br /></td></tr>
<tr class="separator:a01ad12706a6b9884cc8f3a5677a899e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306faecd06fa13031ba30f542159010a"><td class="memTemplParams" colspan="2">template&lt;typename T , class SortPredicate &gt; </td></tr>
<tr class="memitem:a306faecd06fa13031ba30f542159010a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a306faecd06fa13031ba30f542159010a">sortedIndex</a> (const T &amp;A)</td></tr>
<tr class="separator:a306faecd06fa13031ba30f542159010a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2148b0b508844d5fb84e7675bbd26a7"><td class="memTemplParams" colspan="2"><a id="ac2148b0b508844d5fb84e7675bbd26a7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2148b0b508844d5fb84e7675bbd26a7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ac2148b0b508844d5fb84e7675bbd26a7">sortedIndex</a> (const T &amp;A)</td></tr>
<tr class="memdesc:ac2148b0b508844d5fb84e7675bbd26a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a container in ascending sequence. <br /></td></tr>
<tr class="separator:ac2148b0b508844d5fb84e7675bbd26a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8ebb4bc959bbfeccc0a42324808db8"><td class="memItemLeft" align="right" valign="top"><a id="ade8ebb4bc959bbfeccc0a42324808db8"></a>
boost::tuple&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>splitFilename</b> (const std::string &amp;filename)</td></tr>
<tr class="separator:ade8ebb4bc959bbfeccc0a42324808db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db0c1b0db1fa0f298f82402e4a70219"><td class="memItemLeft" align="right" valign="top"><a id="a7db0c1b0db1fa0f298f82402e4a70219"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a7db0c1b0db1fa0f298f82402e4a70219">stringsAsComments</a> (const std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="memdesc:a7db0c1b0db1fa0f298f82402e4a70219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of strings into a standard log format. <br /></td></tr>
<tr class="separator:a7db0c1b0db1fa0f298f82402e4a70219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bae3110e11bb30502050796b4cd586"><td class="memItemLeft" align="right" valign="top"><a id="a48bae3110e11bb30502050796b4cd586"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a48bae3110e11bb30502050796b4cd586">stringsAsString</a> (const std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="memdesc:a48bae3110e11bb30502050796b4cd586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of strings into a single string with newlines. <br /></td></tr>
<tr class="separator:a48bae3110e11bb30502050796b4cd586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee39a071d0643188f73b398af04c5d7"><td class="memItemLeft" align="right" valign="top"><a id="a0ee39a071d0643188f73b398af04c5d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>subtractAverage</b> (<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;M)</td></tr>
<tr class="separator:a0ee39a071d0643188f73b398af04c5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34932a929bc0953556a35766c9989471"><td class="memItemLeft" align="right" valign="top">boost::tuple&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>, <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>, <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a34932a929bc0953556a35766c9989471">svd</a> (std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble, const bool align=true)</td></tr>
<tr class="memdesc:a34932a929bc0953556a35766c9989471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the SVD of an ensemble with optional alignment (note RSVs returned are transposed)  <a href="namespaceloos.html#a34932a929bc0953556a35766c9989471">More...</a><br /></td></tr>
<tr class="separator:a34932a929bc0953556a35766c9989471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1021d75b06b63e2410636b11179c1a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee1021d75b06b63e2410636b11179c1a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#aee1021d75b06b63e2410636b11179c1a">swab</a> (const T &amp;datum)</td></tr>
<tr class="memdesc:aee1021d75b06b63e2410636b11179c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a byte-swapped copy of an arbitrary type.  <a href="namespaceloos.html#aee1021d75b06b63e2410636b11179c1a">More...</a><br /></td></tr>
<tr class="separator:aee1021d75b06b63e2410636b11179c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa080c6848021738d86d5dc4a73c19bd"><td class="memItemLeft" align="right" valign="top"><a id="aaa080c6848021738d86d5dc4a73c19bd"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#aaa080c6848021738d86d5dc4a73c19bd">timeAsString</a> (const double t, const uint precision=0)</td></tr>
<tr class="memdesc:aaa080c6848021738d86d5dc4a73c19bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert t (seconds) into a string, converting to hours and minutes as necessary. <br /></td></tr>
<tr class="separator:aaa080c6848021738d86d5dc4a73c19bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3671a3351a4a71dda3e62ea964d0b08a"><td class="memTemplParams" colspan="2"><a id="a3671a3351a4a71dda3e62ea964d0b08a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3671a3351a4a71dda3e62ea964d0b08a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a3671a3351a4a71dda3e62ea964d0b08a">uniquifyVector</a> (const std::vector&lt; T &gt; &amp;list)</td></tr>
<tr class="memdesc:a3671a3351a4a71dda3e62ea964d0b08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing only the unique elements of the input vector. <br /></td></tr>
<tr class="separator:a3671a3351a4a71dda3e62ea964d0b08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8783c2b04ba43093b26f20f769d5afae"><td class="memItemLeft" align="right" valign="top"><a id="a8783c2b04ba43093b26f20f769d5afae"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8783c2b04ba43093b26f20f769d5afae"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a8783c2b04ba43093b26f20f769d5afae">vectorAsStringWithCommas</a> (const std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="memdesc:a8783c2b04ba43093b26f20f769d5afae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for strings that sanitizes the contained strings. <br /></td></tr>
<tr class="separator:a8783c2b04ba43093b26f20f769d5afae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac337138d3dd868ff6c78ff7606024425"><td class="memTemplParams" colspan="2"><a id="ac337138d3dd868ff6c78ff7606024425"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac337138d3dd868ff6c78ff7606024425"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ac337138d3dd868ff6c78ff7606024425">vectorAsStringWithCommas</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ac337138d3dd868ff6c78ff7606024425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of type T to a string-list with commas. <br /></td></tr>
<tr class="separator:ac337138d3dd868ff6c78ff7606024425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63f81614006afb36b456a3e8d69cd02"><td class="memTemplParams" colspan="2"><a id="ae63f81614006afb36b456a3e8d69cd02"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae63f81614006afb36b456a3e8d69cd02"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ae63f81614006afb36b456a3e8d69cd02">vToString</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae63f81614006afb36b456a3e8d69cd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert something that can iterate into a string... <br /></td></tr>
<tr class="separator:ae63f81614006afb36b456a3e8d69cd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b71724c3ca8b3c7f53db1f5981d9252"><td class="memTemplParams" colspan="2">template&lt;class T , class P , template&lt; typename &gt; class S&gt; </td></tr>
<tr class="memitem:a1b71724c3ca8b3c7f53db1f5981d9252"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a1b71724c3ca8b3c7f53db1f5981d9252">writeAsciiMatrix</a> (const std::string &amp;fname, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false)</td></tr>
<tr class="memdesc:a1b71724c3ca8b3c7f53db1f5981d9252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an entire matrix to a file.  <a href="namespaceloos.html#a1b71724c3ca8b3c7f53db1f5981d9252">More...</a><br /></td></tr>
<tr class="separator:a1b71724c3ca8b3c7f53db1f5981d9252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd2e70f929e714ccc204509826aa755"><td class="memTemplParams" colspan="2"><a id="a3dd2e70f929e714ccc204509826aa755"></a>
template&lt;class T , class P , template&lt; typename &gt; class S, class F &gt; </td></tr>
<tr class="memitem:a3dd2e70f929e714ccc204509826aa755"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a3dd2e70f929e714ccc204509826aa755">writeAsciiMatrix</a> (const std::string &amp;fname, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false, F fmt=F())</td></tr>
<tr class="memdesc:a3dd2e70f929e714ccc204509826aa755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an entire matrix to a file. <br /></td></tr>
<tr class="separator:a3dd2e70f929e714ccc204509826aa755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d8f9638487d808a278351d80f813a2"><td class="memTemplParams" colspan="2"><a id="ae9d8f9638487d808a278351d80f813a2"></a>
template&lt;class T , class P , template&lt; typename &gt; class S&gt; </td></tr>
<tr class="memitem:ae9d8f9638487d808a278351d80f813a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ae9d8f9638487d808a278351d80f813a2">writeAsciiMatrix</a> (const std::string &amp;fname, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;start, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;end, const bool trans=false)</td></tr>
<tr class="memdesc:ae9d8f9638487d808a278351d80f813a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a submatrix to a file. <br /></td></tr>
<tr class="separator:ae9d8f9638487d808a278351d80f813a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb2b19efa2dd29b200b34a93216c14b"><td class="memTemplParams" colspan="2"><a id="aacb2b19efa2dd29b200b34a93216c14b"></a>
template&lt;class T , class P , template&lt; typename &gt; class S, class F &gt; </td></tr>
<tr class="memitem:aacb2b19efa2dd29b200b34a93216c14b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#aacb2b19efa2dd29b200b34a93216c14b">writeAsciiMatrix</a> (const std::string &amp;fname, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;start, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;end, const bool trans=false, F fmt=F())</td></tr>
<tr class="memdesc:aacb2b19efa2dd29b200b34a93216c14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a submatrix to a file. <br /></td></tr>
<tr class="separator:aacb2b19efa2dd29b200b34a93216c14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba5b0b4f53aa4291ecc820554c0d656"><td class="memTemplParams" colspan="2">template&lt;class T , class P , template&lt; typename &gt; class S&gt; </td></tr>
<tr class="memitem:a0ba5b0b4f53aa4291ecc820554c0d656"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a0ba5b0b4f53aa4291ecc820554c0d656">writeAsciiMatrix</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false)</td></tr>
<tr class="memdesc:a0ba5b0b4f53aa4291ecc820554c0d656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an entire matrix to a stream.  <a href="namespaceloos.html#a0ba5b0b4f53aa4291ecc820554c0d656">More...</a><br /></td></tr>
<tr class="separator:a0ba5b0b4f53aa4291ecc820554c0d656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a5ae72058e2dc1c095d73e8ab99b43"><td class="memTemplParams" colspan="2"><a id="ac5a5ae72058e2dc1c095d73e8ab99b43"></a>
template&lt;class T , class P , template&lt; typename &gt; class S, class F &gt; </td></tr>
<tr class="memitem:ac5a5ae72058e2dc1c095d73e8ab99b43"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ac5a5ae72058e2dc1c095d73e8ab99b43">writeAsciiMatrix</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false, F fmt=F())</td></tr>
<tr class="memdesc:ac5a5ae72058e2dc1c095d73e8ab99b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an entire matrix to a stream. <br /></td></tr>
<tr class="separator:ac5a5ae72058e2dc1c095d73e8ab99b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158c018749d0b0b47d165aff1215ceb9"><td class="memTemplParams" colspan="2"><a id="a158c018749d0b0b47d165aff1215ceb9"></a>
template&lt;class T , class P , template&lt; typename &gt; class S&gt; </td></tr>
<tr class="memitem:a158c018749d0b0b47d165aff1215ceb9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a158c018749d0b0b47d165aff1215ceb9">writeAsciiMatrix</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;start, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;end, const bool trans=false)</td></tr>
<tr class="memdesc:a158c018749d0b0b47d165aff1215ceb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a submatrix to a stream. <br /></td></tr>
<tr class="separator:a158c018749d0b0b47d165aff1215ceb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e6e76011c77a9237cf87efc6262a66"><td class="memTemplParams" colspan="2">template&lt;class T , class P , template&lt; typename &gt; class S, class F &gt; </td></tr>
<tr class="memitem:ab7e6e76011c77a9237cf87efc6262a66"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ab7e6e76011c77a9237cf87efc6262a66">writeAsciiMatrix</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;start, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;end, const bool trans=false, F fmt=F())</td></tr>
<tr class="memdesc:ab7e6e76011c77a9237cf87efc6262a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a submatrix to a stream.  <a href="namespaceloos.html#ab7e6e76011c77a9237cf87efc6262a66">More...</a><br /></td></tr>
<tr class="separator:ab7e6e76011c77a9237cf87efc6262a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdec91122443dd4148e9405ec100d71a"><td class="memItemLeft" align="right" valign="top"><a id="abdec91122443dd4148e9405ec100d71a"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>XTALLine</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box)</td></tr>
<tr class="separator:abdec91122443dd4148e9405ec100d71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a02bef07c4445361fa503cece9c01d65e"><td class="memItemLeft" align="right" valign="top"><a id="a02bef07c4445361fa503cece9c01d65e"></a>
const uint&#160;</td><td class="memItemRight" valign="bottom"><b>gigabytes</b> = 1024 * megabytes</td></tr>
<tr class="separator:a02bef07c4445361fa503cece9c01d65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fc858dbe7cc440042f51c99aa6074a"><td class="memItemLeft" align="right" valign="top"><a id="a49fc858dbe7cc440042f51c99aa6074a"></a>
const uint&#160;</td><td class="memItemRight" valign="bottom"><b>kilobytes</b> = 1024</td></tr>
<tr class="separator:a49fc858dbe7cc440042f51c99aa6074a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcb36b491ae6e78ca17cd48d0bdfa2c"><td class="memItemLeft" align="right" valign="top"><a id="a5fcb36b491ae6e78ca17cd48d0bdfa2c"></a>
const uint&#160;</td><td class="memItemRight" valign="bottom"><b>megabytes</b> = 1024 * kilobytes</td></tr>
<tr class="separator:a5fcb36b491ae6e78ca17cd48d0bdfa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for most things not already encapsulated within a class. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a50aefac013fa449999f74fa4e0df8b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50aefac013fa449999f74fa4e0df8b55">&#9670;&nbsp;</a></span>averageStructure() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::averageStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pTraj &amp;&#160;</td>
          <td class="paramname"><em>traj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the average structure using all frames in a trajectory. </p>
<p>This version only reads a frame at a time from the trajectory. The trajectory iterator will be left pointing to the end of the trajectory. </p>

<p class="definition">Definition at line <a class="el" href="ensembles_8cpp_source.html#l00125">125</a> of file <a class="el" href="ensembles_8cpp_source.html">ensembles.cpp</a>.</p>

</div>
</div>
<a id="a145b1950c29d680031aaba768f133ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145b1950c29d680031aaba768f133ce0">&#9670;&nbsp;</a></span>averageStructure() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::averageStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pTraj &amp;&#160;</td>
          <td class="paramname"><em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the average structure from a trajectory reading only certain frames. </p>
<p>Note that the trajectory is NOT stored in memory. Frames will be read as needed. The trajectory "iterator" will be left pointing to the next frame after the last frame index passed. </p>

<p class="definition">Definition at line <a class="el" href="ensembles_8cpp_source.html#l00091">91</a> of file <a class="el" href="ensembles_8cpp_source.html">ensembles.cpp</a>.</p>

</div>
</div>
<a id="aa10ec538bd0a45ef4543c60489fb6a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10ec538bd0a45ef4543c60489fb6a74">&#9670;&nbsp;</a></span>averageStructure() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::averageStructure </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ensemble</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>xforms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the average structure of a set of <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> objects. </p>
<p>Takes into consideration the passed set of transforms... </p>

<p class="definition">Definition at line <a class="el" href="ensembles_8cpp_source.html#l00061">61</a> of file <a class="el" href="ensembles_8cpp_source.html">ensembles.cpp</a>.</p>

</div>
</div>
<a id="aaa994f20daba9b26f90c194c2c472382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa994f20daba9b26f90c194c2c472382">&#9670;&nbsp;</a></span>boxFromRemarks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_coord.html">GCoord</a> loos::boxFromRemarks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_remarks.html">Remarks</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the Alan-style box-size from a <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> <a class="el" href="classloos_1_1_remarks.html" title="Class for handling PDB Remarks.">Remarks</a> block. </p>
<p>Returns a GCoord(99999.99, 99999.99, 99999.99) if there is no box info found in the remarks block. </p>

<p class="definition">Definition at line <a class="el" href="utils__structural_8cpp_source.html#l00042">42</a> of file <a class="el" href="utils__structural_8cpp_source.html">utils_structural.cpp</a>.</p>

</div>
</div>
<a id="acb266964bdaa10942329c7747adce633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb266964bdaa10942329c7747adce633">&#9670;&nbsp;</a></span>createSystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::createSystem </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function for reading in structure files. </p>
<p>This function will try to determine the filetype for a structure file by examining the suffix of the file. It will return an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> copy of the input structure.</p>
<p><a class="el" href="classloos_1_1_amber.html" title="Class for reading in AMBER parmtop/coord files...">Amber</a> files are handled differently... If the filename ends with ".prmtop", then LOOS will check for a corresponding ".inpcrd" file. If one is found, then the coords will be loaded into the group. Otherwise, the prmtop will be loaded without coords and returned. </p>

<p class="definition">Definition at line <a class="el" href="sfactories_8cpp_source.html#l00115">115</a> of file <a class="el" href="sfactories_8cpp_source.html">sfactories.cpp</a>.</p>

</div>
</div>
<a id="a5c3b7c1613a234d4b4d23f23b5d4af6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3b7c1613a234d4b4d23f23b5d4af6f">&#9670;&nbsp;</a></span>createTrajectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pTraj loos::createTrajectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function for reading in a trajectory file. </p>
<p>This function will try to determine the filetype for a trajectory by examining the suffix of the file. It will return a boost shared pointer to a new <a class="el" href="classloos_1_1_trajectory.html" title="Base-class for polymorphic trajectories.">Trajectory</a> object.</p>
<p>It is <em>very</em> <em>important</em> to understand that the object returned by this function must behave polymorphically. That's why it is wrapped in a boost shared pointer to the base class. Do not try to deference it and assign it to a <a class="el" href="classloos_1_1_trajectory.html" title="Base-class for polymorphic trajectories.">Trajectory</a> object... </p>

<p class="definition">Definition at line <a class="el" href="sfactories_8cpp_source.html#l00184">184</a> of file <a class="el" href="sfactories_8cpp_source.html">sfactories.cpp</a>.</p>

</div>
</div>
<a id="a8ce914a61c5001a5a966864f758630ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce914a61c5001a5a966864f758630ca">&#9670;&nbsp;</a></span>deduceAtomicNumberFromMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int loos::deduceAtomicNumberFromMass </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduce an atomic number from the mass. </p>
<p>Only the first 96 elements are included in LOOS. An atomic number of 0 is returned if the mass is not found within LOOS' table. </p>

<p class="definition">Definition at line <a class="el" href="_atomic_number_deducer_8cpp_source.html#l00134">134</a> of file <a class="el" href="_atomic_number_deducer_8cpp_source.html">AtomicNumberDeducer.cpp</a>.</p>

</div>
</div>
<a id="a9938bb182cff8aeddeb0eb7aac81b09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9938bb182cff8aeddeb0eb7aac81b09f">&#9670;&nbsp;</a></span>invocationHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string loos::invocationHeader </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an invocation header. </p>
<p>This is a string that can be embedded in output that records the invoking user, command-line, and a timestamp. </p>

<p class="definition">Definition at line <a class="el" href="utils_8cpp_source.html#l00124">124</a> of file <a class="el" href="utils_8cpp_source.html">utils.cpp</a>.</p>

</div>
</div>
<a id="ab42aeab4c92169da3571c75d3f035ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42aeab4c92169da3571c75d3f035ad5">&#9670;&nbsp;</a></span>iterativeAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::tuple&lt; std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt;, greal, int &gt; loos::iterativeAlignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pTraj &amp;&#160;</td>
          <td class="paramname"><em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">greal&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an iterative superposition by reading in frames from the <a class="el" href="classloos_1_1_trajectory.html" title="Base-class for polymorphic trajectories.">Trajectory</a>. </p>
<p>The iterativeAlignment() functions that take a trajectory as an argument do NOT cache frames of the trajectory internally. This means that the trajectory will be read as many times as is necessary for the alignment to converge. In practice, the OS-specific caching will likely result in decent performance. If speed is essential, then consider using the iterativeAlignment() version that takes a <code>std::vector&lt;AtomicGroup&gt;&amp;</code> as argument instead. </p>

<p class="definition">Definition at line <a class="el" href="alignment_8cpp_source.html#l00355">355</a> of file <a class="el" href="alignment_8cpp_source.html">alignment.cpp</a>.</p>

</div>
</div>
<a id="ad172cde7ba10cd0378d767a9c5ece776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad172cde7ba10cd0378d767a9c5ece776">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_coord.html">Coord</a>&lt; T &gt; loos::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_matrix44.html">Matrix44</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_coord.html">Coord</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector multiply This has to be a friend outside the class for GCC to be happy... </p>

<p class="definition">Definition at line <a class="el" href="_matrix44_8hpp_source.html#l00244">244</a> of file <a class="el" href="_matrix44_8hpp_source.html">Matrix44.hpp</a>.</p>

</div>
</div>
<a id="ade8a1af5ac9fdf234a1fddd0e9dc7c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8a1af5ac9fdf234a1fddd0e9dc7c62">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; loos::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_gromacs.html">Gromacs</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the group as a GRO... </p>
<p>Output as a GRO. </p>

<p class="definition">Definition at line <a class="el" href="gro_8cpp_source.html#l00141">141</a> of file <a class="el" href="gro_8cpp_source.html">gro.cpp</a>.</p>

</div>
</div>
<a id="a383e865fa6a6e7a88c696a449fbf7c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383e865fa6a6e7a88c696a449fbf7c2b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; loos::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_p_d_b.html">PDB</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the group as a <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a>... </p>
<p>Output as a <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a>.</p>
<p>There are some formatting changes that occur when the group has a large number of atoms or resids. The most significant is when you have 100,000 or more, in which case you lose the altloc and chainid fields on output. However, the output <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> will load into pymol... </p>

<p class="definition">Definition at line <a class="el" href="pdb_8cpp_source.html#l00485">485</a> of file <a class="el" href="pdb_8cpp_source.html">pdb.cpp</a>.</p>

</div>
</div>
<a id="a3a934b70913b38a1bb2aa4c0fecf32d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a934b70913b38a1bb2aa4c0fecf32d0">&#9670;&nbsp;</a></span>parseIndexRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint &gt; loos::parseIndexRange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use boost::Spirit to parse a new-style range list. </p>
<p>Similar to <a class="el" href="namespaceloos.html#a750b5d795f43978407dc4e9127c7db03" title="Parses a list of Octave-style range specifiers (for compatability)">parseRangeList()</a>, but uses boost::spirit can requires a maximum index size. This allows you to specify ranges without knowing the endpoint, e.g. 10:2:, means start at 10, skipping 2, until the value of maxsize. This is useful for trajectories, otherwise you would have to know how big they are before using a range to specify a skip and stride. </p>

<p class="definition">Definition at line <a class="el" href="index__range__parser_8cpp_source.html#l00147">147</a> of file <a class="el" href="index__range__parser_8cpp_source.html">index_range_parser.cpp</a>.</p>

</div>
</div>
<a id="aef82d7e98c0493c76dfad5621043b43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef82d7e98c0493c76dfad5621043b43c">&#9670;&nbsp;</a></span>parseRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; loos::parseRange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>endpoint</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an Octave/Matlab-style range. </p>
<p>The Octave format is one of the following:</p><ul>
<li>value</li>
<li>start:stop</li>
<li>start:step:stop</li>
</ul>
<p>The range is inclusive for both ends. Internally, a vector of T's is created. There is no checking to make sure that the vector doesn't completely fill up memory.</p>
<p>As with matlab/octave, to count down, the step must be negative and start &gt; stop. </p>

<p class="definition">Definition at line <a class="el" href="utils_8hpp_source.html#l00173">173</a> of file <a class="el" href="utils_8hpp_source.html">utils.hpp</a>.</p>

</div>
</div>
<a id="a163ccbfeb984c222e3e50813e47b7b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163ccbfeb984c222e3e50813e47b7b47">&#9670;&nbsp;</a></span>parseRangeList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; loos::parseRangeList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>endpoint</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a comma-separated list of Octave-style ranges. </p>
<p>This function breaks apart a string at the commas and passes each substring to parseRange. The union of all of the vectors returned by parseRange is then sorted in ascending order and duplicate values are removed. This vector is then returned to the caller. </p>

<p class="definition">Definition at line <a class="el" href="utils_8hpp_source.html#l00262">262</a> of file <a class="el" href="utils_8hpp_source.html">utils.hpp</a>.</p>

</div>
</div>
<a id="a6ade6e7564c4aa077a6f3134c6252663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ade6e7564c4aa077a6f3134c6252663">&#9670;&nbsp;</a></span>randomSeedRNG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint loos::randomSeedRNG </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomly seeds the RNG. </p>
<p>Currently uses time(3) to seed the RNG obtained from the singleton... Returns the seed used. </p>

<p class="definition">Definition at line <a class="el" href="utils__random_8cpp_source.html#l00036">36</a> of file <a class="el" href="utils__random_8cpp_source.html">utils_random.cpp</a>.</p>

</div>
</div>
<a id="a6652c219629008baddc12e6209a8c590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6652c219629008baddc12e6209a8c590">&#9670;&nbsp;</a></span>readTable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt;T&gt; &gt; loos::readTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classloos_1_1_line_reader.html">LineReader</a> &amp;&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read in a table of items using a <a class="el" href="classloos_1_1_line_reader.html" title="Class for reading line-by-line from a file while tracking line numbers and stripping comments.">LineReader</a> object. </p>
<p>This is distinct from the Matrix class reader which requires a specific format. Here, comments may be freely interspersed with the data and rows may contain different numbers of columns </p>

<p class="definition">Definition at line <a class="el" href="utils_8hpp_source.html#l00114">114</a> of file <a class="el" href="utils_8hpp_source.html">utils.hpp</a>.</p>

</div>
</div>
<a id="ad402d8c3aa16082e4187b60d61f2687c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad402d8c3aa16082e4187b60d61f2687c">&#9670;&nbsp;</a></span>readVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; loos::readVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classloos_1_1_line_reader.html">LineReader</a> &amp;&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a list of items using a <a class="el" href="classloos_1_1_line_reader.html" title="Class for reading line-by-line from a file while tracking line numbers and stripping comments.">LineReader</a> object. </p>
<p>The <a class="el" href="namespaceloos.html#ad402d8c3aa16082e4187b60d61f2687c" title="Read a list of items using a LineReader object.">readVector&lt;T&gt;()</a> family of functions allows you to read in a list of items (numbers) from a stream or a file. When used with a <a class="el" href="classloos_1_1_line_reader.html" title="Class for reading line-by-line from a file while tracking line numbers and stripping comments.">LineReader</a> object, you have control over how blank lines and comments are handled. When used with either an istream or a string, the default behavior is to skip blank lines and comments will begin with the '#' character and are stripped. </p>

<p class="definition">Definition at line <a class="el" href="utils_8hpp_source.html#l00077">77</a> of file <a class="el" href="utils_8hpp_source.html">utils.hpp</a>.</p>

</div>
</div>
<a id="ab82436be3d1bfa01542d6a8f3820a38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82436be3d1bfa01542d6a8f3820a38b">&#9670;&nbsp;</a></span>rng_singleton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">base_generator_type &amp; loos::rng_singleton </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suite-wide random number generator singleton. </p>
<pre class="fragment"> LOOS makes no assumptions about how the random number generator
 gets seeded.  It is up to the tool-writer to seed it with a known
 value,
</pre> <div class="fragment"><div class="line">rng_singleton().seed(seed_value);</div>
</div><!-- fragment --><p> or call <a class="el" href="namespaceloos.html#a6ade6e7564c4aa077a6f3134c6252663" title="Randomly seeds the RNG.">randomSeedRNG()</a> to randomly seed the random number generator... </p>

<p class="definition">Definition at line <a class="el" href="utils__random_8cpp_source.html#l00027">27</a> of file <a class="el" href="utils__random_8cpp_source.html">utils_random.cpp</a>.</p>

</div>
</div>
<a id="a01ad12706a6b9884cc8f3a5677a899e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ad12706a6b9884cc8f3a5677a899e3">&#9670;&nbsp;</a></span>selectAtoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::selectAtoms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>selection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a string-based selection to an atomic group... </p>
<p>This routine parses the passed string, turning it into a selector and applies it to <em>source</em>. If there is an exception in the parsing, this is repackaged into a more sensible error message (including the string that generated the error). No other exceptions are caught.</p>
<p>We're also assuming that you're <em>always</em> wanting to select some atoms, so lack of selection constitutes an error and an exception is thrown. Note that in both the case of a parse error and null-selection, a runtime_error exception is thrown so the catcher cannot disambiguate between the two. </p>

<p class="definition">Definition at line <a class="el" href="utils_8cpp_source.html#l00195">195</a> of file <a class="el" href="utils_8cpp_source.html">utils.cpp</a>.</p>

</div>
</div>
<a id="a306faecd06fa13031ba30f542159010a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306faecd06fa13031ba30f542159010a">&#9670;&nbsp;</a></span>sortedIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class SortPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint&gt; loos::sortedIndex </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort a container using the given sort policy, returning the indices that permutes the container into the sorted order. The container to be sorted must support T::size() and T::operator[]. What is returned is a vector of unsigned ints that represent the index into the container when it is sorted. </p>

<p class="definition">Definition at line <a class="el" href="sorting_8hpp_source.html#l00071">71</a> of file <a class="el" href="sorting_8hpp_source.html">sorting.hpp</a>.</p>

</div>
</div>
<a id="a34932a929bc0953556a35766c9989471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34932a929bc0953556a35766c9989471">&#9670;&nbsp;</a></span>svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::tuple&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>, <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>, <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &gt; loos::svd </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ensemble</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>align</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the SVD of an ensemble with optional alignment (note RSVs returned are transposed) </p>
<p>Returns the U, S, and V' of the SVD of the passed ensemble. If align is true, then the ensemble is iteratively aligned prior to computing the SVD. </p>

<p class="definition">Definition at line <a class="el" href="ensembles_8cpp_source.html#l00239">239</a> of file <a class="el" href="ensembles_8cpp_source.html">ensembles.cpp</a>.</p>

</div>
</div>
<a id="aee1021d75b06b63e2410636b11179c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1021d75b06b63e2410636b11179c1a">&#9670;&nbsp;</a></span>swab()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T loos::swab </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>datum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a byte-swapped copy of an arbitrary type. </p>
<p>Only valid for simple types (i.e. int, float, double) </p>

<p class="definition">Definition at line <a class="el" href="utils_8hpp_source.html#l00301">301</a> of file <a class="el" href="utils_8hpp_source.html">utils.hpp</a>.</p>

</div>
</div>
<a id="a1b71724c3ca8b3c7f53db1f5981d9252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b71724c3ca8b3c7f53db1f5981d9252">&#9670;&nbsp;</a></span>writeAsciiMatrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , template&lt; typename &gt; class S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void loos::writeAsciiMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>meta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>trans</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an entire matrix to a file. </p>
<p>Principal front-end to writing out ASCII matrices. Given a filename, matrix, metadata, and optional flag for whether or not the matrix is transposed interally, will write the entire matrix using the default C++ type-to-string conversion. </p>

<p class="definition">Definition at line <a class="el" href="_matrix_write_8hpp_source.html#l00228">228</a> of file <a class="el" href="_matrix_write_8hpp_source.html">MatrixWrite.hpp</a>.</p>

</div>
</div>
<a id="a0ba5b0b4f53aa4291ecc820554c0d656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba5b0b4f53aa4291ecc820554c0d656">&#9670;&nbsp;</a></span>writeAsciiMatrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , template&lt; typename &gt; class S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; loos::writeAsciiMatrix </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>meta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>trans</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an entire matrix to a stream. </p>
<pre class="fragment"> Primary front-end to writing an entire ASCII matrix to a stream.
 Will use the default C++ type-to-string conversion for the matrix
 data type (e.g. float).
 Example:
</pre> <div class="fragment"><div class="line">Matrix&lt;double&gt; M;</div>
<div class="line">writeAsciiMatrix(cout, M, &quot;Eigenvector matrix&quot;);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_matrix_write_8hpp_source.html#l00176">176</a> of file <a class="el" href="_matrix_write_8hpp_source.html">MatrixWrite.hpp</a>.</p>

</div>
</div>
<a id="ab7e6e76011c77a9237cf87efc6262a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e6e76011c77a9237cf87efc6262a66">&#9670;&nbsp;</a></span>writeAsciiMatrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , template&lt; typename &gt; class S, class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; loos::writeAsciiMatrix </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>meta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>trans</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fmt</em> = <code>F()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a submatrix to a stream. </p>
<p>This family of functions write a matrix in ASCII format suitable for loading into Octave/Matlab or gnuplot. The <em>meta</em> information is written as part of the comment at the start of the file. The <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24" title="Specify a range for columns/rows [first,second)">Math::Range</a> <em>start</em> and <em>end</em> are just pairs that give an <em></em>(j,i) starting and ending point within the matrix to write. Note that these arguments are not always honored (such as with a triangular matrix). The <em>trans</em> flag causes the output matrix to be the transpose of the stored matrix. The <em>fmt</em> arg is a functor that is expected for format each element of the matrix as a string. You can use this to adjust the precision of the output or delimit it, etc. The default is to use whatever the default operator&lt;&lt;() would be for type T. </p>

<p class="definition">Definition at line <a class="el" href="_matrix_write_8hpp_source.html#l00140">140</a> of file <a class="el" href="_matrix_write_8hpp_source.html">MatrixWrite.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceloos.html">loos</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
