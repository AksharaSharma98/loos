<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LOOS: loos::Math Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceloos.html">loos</a>::<a class="el" href="namespaceloos_1_1_math.html">Math</a>
  </div>
</div>
<div class="contents">
<h1>loos::Math Namespace Reference</h1>Namespace for math and math-related things in <a class="el" href="namespaceloos.html" title="Namespace for most things not already encapsulated within a class.">loos</a>.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_math_1_1_matrix.html">Matrix</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple matrix template class using policy classes to determine behavior.  <a href="classloos_1_1_math_1_1_matrix.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_math_1_1_triangular.html">Triangular</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for storing a symmetric triangular matrix.  <a href="classloos_1_1_math_1_1_triangular.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_math_1_1_col_major.html">ColMajor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for storing a matrix in column-major order.  <a href="classloos_1_1_math_1_1_col_major.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_math_1_1_row_major.html">RowMajor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for storing a matrix in row-major order...  <a href="classloos_1_1_math_1_1_row_major.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_math_1_1_shared_array.html">SharedArray</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Storage policy for a block of memory wrapped in a boost::shared_array pointer.  <a href="classloos_1_1_math_1_1_shared_array.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_math_1_1_sparse_array.html">SparseArray</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Storage policy for a sparse matrix (see important note in the detailed documentation).  <a href="classloos_1_1_math_1_1_sparse_array.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8d27aca30e04e2c36cd3f56f6380df39"></a><!-- doxytag: member="loos::Math::angle" ref="8d27aca30e04e2c36cd3f56f6380df39" args="(const GCoord &amp;, const GCoord &amp;, const GCoord &amp;)" -->
greal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html#8d27aca30e04e2c36cd3f56f6380df39">angle</a> (const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the angle in degrees assuming the middle is the vertex. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aabe2f5fc5cf4be2ce325041dae0382c"></a><!-- doxytag: member="loos::Math::angle" ref="aabe2f5fc5cf4be2ce325041dae0382c" args="(const pAtom &amp;a, const pAtom &amp;b, const pAtom &amp;c)" -->
greal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html#aabe2f5fc5cf4be2ce325041dae0382c">angle</a> (const pAtom &amp;a, const pAtom &amp;b, const pAtom &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the angle in degrees assuming the middle is the vertex. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="82e0a5e7d4737459c7da4c8bc871080c"></a><!-- doxytag: member="loos::Math::torsion" ref="82e0a5e7d4737459c7da4c8bc871080c" args="(const GCoord &amp;a, const GCoord &amp;b, const GCoord &amp;c, const GCoord &amp;d)" -->
greal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html#82e0a5e7d4737459c7da4c8bc871080c">torsion</a> (const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;a, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;b, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;c, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the torsion in degrees. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6c638e1a9f7e973fa79a162c299cafff"></a><!-- doxytag: member="loos::Math::torsion" ref="6c638e1a9f7e973fa79a162c299cafff" args="(const pAtom &amp;a, const pAtom &amp;b, const pAtom &amp;c, const pAtom &amp;d)" -->
greal&nbsp;</td><td class="memItemRight" valign="bottom"><b>torsion</b> (const pAtom &amp;a, const pAtom &amp;b, const pAtom &amp;c, const pAtom &amp;d)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="e89bc6396a74bed30dd3c16af5340a78"></a><!-- doxytag: member="loos::Math::reinterpretOrder" ref="e89bc6396a74bed30dd3c16af5340a78" args="(const Matrix&lt; T, ColMajor, S &gt; &amp;)" -->
template&lt;typename T, template&lt; typename &gt; class S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_math_1_1_matrix.html">Matrix</a>&lt; T, <a class="el" href="classloos_1_1_math_1_1_row_major.html">RowMajor</a>, S &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpretOrder</b> (const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Matrix</a>&lt; T, <a class="el" href="classloos_1_1_math_1_1_col_major.html">ColMajor</a>, S &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="bde634675b5a844e0d42cd126174570d"></a><!-- doxytag: member="loos::Math::reinterpretOrder" ref="bde634675b5a844e0d42cd126174570d" args="(const Matrix&lt; T, RowMajor, S &gt; &amp;)" -->
template&lt;typename T, template&lt; typename &gt; class S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_math_1_1_matrix.html">Matrix</a>&lt; T, <a class="el" href="classloos_1_1_math_1_1_col_major.html">ColMajor</a>, S &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpretOrder</b> (const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Matrix</a>&lt; T, <a class="el" href="classloos_1_1_math_1_1_row_major.html">RowMajor</a>, S &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="0fa72c0a7fa5eace785437a8729729c8"></a><!-- doxytag: member="loos::Math::operator&lt;&lt;" ref="0fa72c0a7fa5eace785437a8729729c8" args="(std::ostream &amp;os, const Matrix&lt; T, P, S &gt; &amp;M)" -->
template&lt;typename T, class P, template&lt; typename &gt; class S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Matrix</a>&lt; T, P, S &gt; &amp;M)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::tuple&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>, <br>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>, <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html#a80f9957dec57153801f27aabf443240">svd</a> (<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the SVD of a single precision matrix.  <a href="#a80f9957dec57153801f27aabf443240"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2be8b6d0f8defda576058d59e421c755"></a><!-- doxytag: member="loos::Math::MMMultiply" ref="2be8b6d0f8defda576058d59e421c755" args="(const RealMatrix &amp;A, const RealMatrix &amp;B, const bool transa=false, const bool transb=false)" -->
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html#2be8b6d0f8defda576058d59e421c755">MMMultiply</a> (const <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;A, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;B, const bool transa=false, const bool transb=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matrix-matrix multiply (using BLAS). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="55e3d68bb0cd437d0ec443131f5695cd"></a><!-- doxytag: member="loos::Math::invert" ref="55e3d68bb0cd437d0ec443131f5695cd" args="(RealMatrix &amp;A, const float eps=1e-5)" -->
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html#55e3d68bb0cd437d0ec443131f5695cd">invert</a> (<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;A, const float eps=1e-5)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pseudo-inverse of a matrix using the SVD. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8c79fc5ecbd7be791482c2d6a7bc896b"></a><!-- doxytag: member="loos::Math::invert" ref="8c79fc5ecbd7be791482c2d6a7bc896b" args="(DoubleMatrix &amp;A, const double eps)" -->
<a class="el" href="classloos_1_1_math_1_1_matrix.html">DoubleMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>invert</b> (<a class="el" href="classloos_1_1_math_1_1_matrix.html">DoubleMatrix</a> &amp;A, const double eps)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5451e8e25d76dec5045ba4f5670a3388"></a><!-- doxytag: member="loos::Math::operator+=" ref="5451e8e25d76dec5045ba4f5670a3388" args="(RealMatrix &amp;A, const RealMatrix &amp;B)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html#5451e8e25d76dec5045ba4f5670a3388">operator+=</a> (<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;A, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded operators for RealMatrix matrices (see important note below). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2a90799513437b1f5366c2a57ce33232"></a><!-- doxytag: member="loos::Math::operator+" ref="2a90799513437b1f5366c2a57ce33232" args="(const RealMatrix &amp;A, const RealMatrix &amp;B)" -->
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;A, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="361bcb259ba7a6a8e146a21f2528d870"></a><!-- doxytag: member="loos::Math::operator-=" ref="361bcb259ba7a6a8e146a21f2528d870" args="(RealMatrix &amp;A, const RealMatrix &amp;B)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;A, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="68d46d8d0772f4b24fd82844948dac27"></a><!-- doxytag: member="loos::Math::operator-" ref="68d46d8d0772f4b24fd82844948dac27" args="(const RealMatrix &amp;A, const RealMatrix &amp;B)" -->
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;A, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5e78ea64e0d85710b7bcd9fc0fb58581"></a><!-- doxytag: member="loos::Math::operator*=" ref="5e78ea64e0d85710b7bcd9fc0fb58581" args="(RealMatrix &amp;A, const float d)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;A, const float d)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="92e3f5571d741257049d1ab860deb8f8"></a><!-- doxytag: member="loos::Math::operator*" ref="92e3f5571d741257049d1ab860deb8f8" args="(const RealMatrix &amp;A, const float d)" -->
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;A, const float d)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b818c13a7c37bc8e8c45bafed7d2b40e"></a><!-- doxytag: member="loos::Math::operator*=" ref="b818c13a7c37bc8e8c45bafed7d2b40e" args="(RealMatrix &amp;A, const RealMatrix &amp;B)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;A, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aca6131c6be0420758805a037c1170fb"></a><!-- doxytag: member="loos::Math::operator*" ref="aca6131c6be0420758805a037c1170fb" args="(const RealMatrix &amp;A, const RealMatrix &amp;B)" -->
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;A, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="42eb0515121baa7b688dc430c22f8236"></a><!-- doxytag: member="loos::Math::operator*=" ref="42eb0515121baa7b688dc430c22f8236" args="(DoubleMatrix &amp;A, const double d)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (<a class="el" href="classloos_1_1_math_1_1_matrix.html">DoubleMatrix</a> &amp;A, const double d)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0de771a395c0e3f9c3ca6e50af8e8cb8"></a><!-- doxytag: member="loos::Math::operator*" ref="0de771a395c0e3f9c3ca6e50af8e8cb8" args="(const DoubleMatrix &amp;A, const double d)" -->
<a class="el" href="classloos_1_1_math_1_1_matrix.html">DoubleMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classloos_1_1_math_1_1_matrix.html">DoubleMatrix</a> &amp;A, const double d)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4d107a566411b68e07892ec1f18b47d2"></a><!-- doxytag: member="loos::Math::operator-" ref="4d107a566411b68e07892ec1f18b47d2" args="(RealMatrix &amp;A)" -->
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8eaed7e58a85d30df07dc8d86dbf99da"></a><!-- doxytag: member="loos::Math::eye" ref="8eaed7e58a85d30df07dc8d86dbf99da" args="(const uint n)" -->
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html#8eaed7e58a85d30df07dc8d86dbf99da">eye</a> (const uint n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An identity matrix of size n. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9adfec3f700b78d756054504dae6933f"></a><!-- doxytag: member="loos::Math::deye" ref="9adfec3f700b78d756054504dae6933f" args="(const uint n)" -->
<a class="el" href="classloos_1_1_math_1_1_matrix.html">DoubleMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>deye</b> (const uint n)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="0e38f0a6d9e56f9cd97e209869963a0e"></a><!-- doxytag: member="loos::Math::permuteColumns" ref="0e38f0a6d9e56f9cd97e209869963a0e" args="(const T &amp;A, const std::vector&lt; uint &gt; &amp;indices)" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html#0e38f0a6d9e56f9cd97e209869963a0e">permuteColumns</a> (const T &amp;A, const std::vector&lt; uint &gt; &amp;indices)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy of the matrix with the columns permuted by the indices. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="57b3897e4d6f8fec0bd2ffd19a97b694"></a><!-- doxytag: member="loos::Math::permuteRows" ref="57b3897e4d6f8fec0bd2ffd19a97b694" args="(const T &amp;A, const std::vector&lt; uint &gt; &amp;indices)" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html#57b3897e4d6f8fec0bd2ffd19a97b694">permuteRows</a> (const T &amp;A, const std::vector&lt; uint &gt; &amp;indices)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy of the matrix with the rows permuted by the indices. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="dc7ea115bbb691b3ab566aae6d260ad5"></a><!-- doxytag: member="loos::Math::reverseColumns" ref="dc7ea115bbb691b3ab566aae6d260ad5" args="(T &amp;A)" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>reverseColumns</b> (T &amp;A)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="5b6ce13c7a1ccf4a86d10cf0c5d5e589"></a><!-- doxytag: member="loos::Math::reverseRows" ref="5b6ce13c7a1ccf4a86d10cf0c5d5e589" args="(T &amp;A)" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>reverseRows</b> (T &amp;A)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="e9c20fc7c840a8c717275690bc4a35fe"></a><!-- doxytag: member="loos::Math::subspaceOverlap" ref="e9c20fc7c840a8c717275690bc4a35fe" args="(const T &amp;A, const T &amp;B, uint nmodes=0)" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>subspaceOverlap</b> (const T &amp;A, const T &amp;B, uint nmodes=0)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html#0110d3bcc6c9e45a6f2c61f3a747e7f5">covarianceOverlap</a> (const T &amp;lamA, const T &amp;UA, const T &amp;lamB, const T &amp;UB)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the covariance overlap between two subspaces.  <a href="#0110d3bcc6c9e45a6f2c61f3a747e7f5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class P1, template&lt; typename &gt; class S1, class T2, class P2, template&lt; typename &gt; class S2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html#eded27141e30c5bc5ec77cd42028364c">copyMatrix</a> (<a class="el" href="classloos_1_1_math_1_1_matrix.html">Matrix</a>&lt; T1, P1, S1 &gt; &amp;A, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Matrix</a>&lt; T2, P2, S2 &gt; &amp;M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy one matrix into another, converting order/storage along the way.  <a href="#eded27141e30c5bc5ec77cd42028364c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class P1, class T2, class P2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html#37f5a2ae4558de7e5428ae1fddd057b1">copyMatrix</a> (<a class="el" href="classloos_1_1_math_1_1_matrix.html">Matrix</a>&lt; T1, P1, <a class="el" href="classloos_1_1_math_1_1_sparse_array.html">SparseArray</a> &gt; &amp;A, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Matrix</a>&lt; T2, P2, <a class="el" href="classloos_1_1_math_1_1_sparse_array.html">SparseArray</a> &gt; &amp;M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload for copying a sparse matrix that preserves the original.  <a href="#37f5a2ae4558de7e5428ae1fddd057b1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="bb7dfaa7024178963bb1a70e2438165e"></a><!-- doxytag: member="loos::Math::getRow" ref="bb7dfaa7024178963bb1a70e2438165e" args="(const Matrix&lt; T, P, S &gt; &amp;M, const uint j)" -->
template&lt;typename T, class P, template&lt; typename &gt; class S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::vector&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html#bb7dfaa7024178963bb1a70e2438165e">getRow</a> (const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Matrix</a>&lt; T, P, S &gt; &amp;M, const uint j)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a row from a matrix as a vector of T. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="0173209d6201adb3425a39ace791ecc2"></a><!-- doxytag: member="loos::Math::getCol" ref="0173209d6201adb3425a39ace791ecc2" args="(const Matrix&lt; T, P, S &gt; &amp;M, const uint i)" -->
template&lt;typename T, class P, template&lt; typename &gt; class S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::vector&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html#0173209d6201adb3425a39ace791ecc2">getCol</a> (const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Matrix</a>&lt; T, P, S &gt; &amp;M, const uint i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a column from a matrix as a vector of T. <br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="75e282739bb6e11f5ededc6e4d0d6220"></a><!-- doxytag: member="loos::Math::DEGREES" ref="75e282739bb6e11f5ededc6e4d0d6220" args="" -->
const double&nbsp;</td><td class="memItemRight" valign="bottom"><b>DEGREES</b> = 180 / M_PI</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Namespace for math and math-related things in <a class="el" href="namespaceloos.html" title="Namespace for most things not already encapsulated within a class.">loos</a>. 
<p>
Note: the operator overloads presented for DoubleMatrix are not going to be efficient. They are only provided as a convenience for working with matrices in LOOS. If you need to perform more serious linear algebra operations, you are encouraged to use a 3rd party library for your tool. <hr><h2>Function Documentation</h2>
<a class="anchor" name="37f5a2ae4558de7e5428ae1fddd057b1"></a><!-- doxytag: member="loos::Math::copyMatrix" ref="37f5a2ae4558de7e5428ae1fddd057b1" args="(Matrix&lt; T1, P1, SparseArray &gt; &amp;A, const Matrix&lt; T2, P2, SparseArray &gt; &amp;M)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class P1, class T2, class P2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void loos::Math::copyMatrix           </td>
          <td>(</td>
          <td class="paramtype">Matrix&lt; T1, P1, SparseArray &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T2, P2, SparseArray &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overload for copying a sparse matrix that preserves the original. 
<p>
Note: static null_value SHOULD match what's in MatrixStorage, but this probably isn't guaranteed Note: Overloading templated functions is dangerous. If this needs to be expanded, better to use an Impl class... 
<p>Definition at line <a class="el" href="_matrix_utils_8hpp-source.html#l00073">73</a> of file <a class="el" href="_matrix_utils_8hpp-source.html">MatrixUtils.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="eded27141e30c5bc5ec77cd42028364c"></a><!-- doxytag: member="loos::Math::copyMatrix" ref="eded27141e30c5bc5ec77cd42028364c" args="(Matrix&lt; T1, P1, S1 &gt; &amp;A, const Matrix&lt; T2, P2, S2 &gt; &amp;M)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class P1, template&lt; typename &gt; class S1, class T2, class P2, template&lt; typename &gt; class S2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void loos::Math::copyMatrix           </td>
          <td>(</td>
          <td class="paramtype">Matrix&lt; T1, P1, S1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T2, P2, S2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy one matrix into another, converting order/storage along the way. 
<p>
Scans over all elements of a matrix. This may not behave as intended with sparse matrices... 
<p>Definition at line <a class="el" href="_matrix_utils_8hpp-source.html#l00052">52</a> of file <a class="el" href="_matrix_utils_8hpp-source.html">MatrixUtils.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="0110d3bcc6c9e45a6f2c61f3a747e7f5"></a><!-- doxytag: member="loos::Math::covarianceOverlap" ref="0110d3bcc6c9e45a6f2c61f3a747e7f5" args="(const T &amp;lamA, const T &amp;UA, const T &amp;lamB, const T &amp;UB)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double loos::Math::covarianceOverlap           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>lamA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>UA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>lamB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>UB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the covariance overlap between two subspaces. 
<p>
This function expects a set of eigenpairs for comparison. The eigenvalues are stored in a Matrix-vector (i.e. an nx1 matrix). The eigenvectors are stored in the columns of the respective matrices.<p>
Note: Be sure that the eigenvalues are scaled appropriately. For example, when comparing PCA and ENM, the ENM eigenvalues are inversely proportional to the PCA eigenvalues while the PCA "eigenvalues" are actually the singular values (and hence the square-root of the eigenvalues of AA'<p>
Note: It is possible for double sum to be slightly greater than 2x the sum of the eigenvalues, which results in trying to take the square root of a negative number. To prevent this, we actually use the absolute value of the difference.<p>
Note: Due to rounding errors in single precision, it is possible that the covariance overlap of a set of eigenpairs against itself will not come out to be exactly 1, but will be close (i.e. to within 1e-3). 
<p>Definition at line <a class="el" href="_matrix_ops_8hpp-source.html#l00211">211</a> of file <a class="el" href="_matrix_ops_8hpp-source.html">MatrixOps.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="a80f9957dec57153801f27aabf443240"></a><!-- doxytag: member="loos::Math::svd" ref="a80f9957dec57153801f27aabf443240" args="(RealMatrix &amp;M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::tuple&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">DoubleMatrix</a>, <a class="el" href="classloos_1_1_math_1_1_matrix.html">DoubleMatrix</a>, <a class="el" href="classloos_1_1_math_1_1_matrix.html">DoubleMatrix</a> &gt; loos::Math::svd           </td>
          <td>(</td>
          <td class="paramtype">DoubleMatrix &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the SVD of a single precision matrix. 
<p>
Compute the SVD of a double precision matrix.<p>
The SVD functions will overwrite the source matrix <ul>
<li>M </li>
</ul>

<p>Definition at line <a class="el" href="_matrix_ops_8cpp-source.html#l00036">36</a> of file <a class="el" href="_matrix_ops_8cpp-source.html">MatrixOps.cpp</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Apr 21 12:54:53 2010 for LOOS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
