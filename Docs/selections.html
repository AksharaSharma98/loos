<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LOOS: Selection Language</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="main.html">Lightweight Object-Oriented Structure library (LOOS)</a>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="selections">Selection Language </a></h1><h2><a class="anchor" name="Language">
Description</a></h2>
The selection string parser is a relatively simpled parser patterned after C/PERL expressions and includes support for PERL-style regular expressions via Boost. There are two kinds of literals supported: strings and numbers. Numbers are any valid integer. Strings are delimited by either single quotes or double quotes, so both of the following are valid strings: <div class="fragment"><pre class="fragment">
"a string"
'another string'
</pre></div><p>
An important caveat to integer numbers is that LOOS assumes that none will be negative. In other words, no atomid nor resid nor number extracted from a segid (see <a class="el" href="selections.html#magops_explained">Magical Operations</a> magical ops below) will evaluate to a negative number. The relational operators &lt; and &lt;= will behave differently if either operand is a negative number. In this case, they will evaluate to false, for reasons that will become obvious when you read about the magical operators below...<p>
The parser also recognizes a small set of keywords that evaluate to Atom properties. These keywords fall into two types as well: those that evaluate to a number (id, resid) and those that evaluate to a string (name, resname, segname or segid). Keep in mind that keywords are not substitutions, but are more like a pre-defined function that returns that atom property. So you cannot put a keyword in a string and expect it to be substituted with the appropriate value, for example.<h3><a class="anchor" name="relops">
Relational Operators</a></h3>
<table align="center" border="1" cellspacing="3" cellpadding="3">
<tr align="center">
<th>Operator</th><th>Operation </th><th>Strings</th><th>Numbers</th><th>Example </th></tr>
<tr align="center">
<td>&gt;</td><td>Greater than</td><td>yes</td><td>yes</td><td>resid &gt; 10 </td></tr>
<tr align="center">
<td>&gt;=</td><td>Greater than or equals</td><td>yes</td><td>yes</td><td>resid &gt;= 10 </td></tr>
<tr align="center">
<td>&lt;=</td><td>Less than or equals</td><td>yes</td><td>yes</td><td>resid &lt;= 50 </td></tr>
<tr align="center">
<td>&lt;</td><td>Less than</td><td>yes</td><td>yes</td><td>resid &lt; 50 </td></tr>
<tr align="center">
<td>==</td><td>Exactly equals</td><td>yes</td><td>yes</td><td>name == "CA" </td></tr>
<tr align="center">
<td>!=</td><td>Doesn't equals exactly</td><td>yes</td><td>yes</td><td>segname != "SOLV" </td></tr>
<tr align="center">
<td>=~</td><td>Regular expression match</td><td>yes</td><td>no</td><td>name =~ "^(C[A]?|N|O)$" </td></tr>
</table>
<h3><a class="anchor" name="logops">
Logical Operators</a></h3>
<table align="center" border="1" cellspacing="3" cellpadding="3">
<tr align="center">
<th>Operator</th><th>Operation</th><th>Example </th></tr>
<tr align="center">
<td>&amp;&amp;</td><td>Logical And</td><td>name == "CA" &amp;&amp; segid == "PROT" </td></tr>
<tr align="center">
<td>||</td><td>Logical Or</td><td>segid == "SOLV" || segid == "BULK" </td></tr>
<tr align="center">
<td>!</td><td>Not (Negate)</td><td>!(segid == "SOLV") </td></tr>
</table>
<h3><a class="anchor" name="magops">
Magical Operators</a></h3>
<table align="center" border="1" cellspacing="3" cellpadding="3">
<tr align="center">
<th>Operator</th><th>Operation</th><th>Example </th></tr>
<tr align="center">
<td>-&gt;</td><td>Extracts a number from a string</td><td>segid -&gt; "L(\d+)" </td></tr>
</table>
<h3><a class="anchor" name="keywords">
Keywords</a></h3>
<table align="center" border="1" cellspacing="3" cellpadding="3">
<tr align="center">
<th>Keyword</th><th>Atom Property</th><th>Evaluates to...</th><th>Operators </th></tr>
<tr align="center">
<td>name</td><td>Atom name</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~ </td></tr>
<tr align="center">
<td>id</td><td>Atom ID</td><td>number</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, != </td></tr>
<tr align="center">
<td>resname</td><td>Residue name</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~ </td></tr>
<tr align="center">
<td>resid</td><td>Residue ID</td><td>number</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, != </td></tr>
<tr align="center">
<td>segid</td><td>Atom segid</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~ </td></tr>
<tr align="center">
<td>segname</td><td>Synonym for segid</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~ </td></tr>
<tr align="center">
<td>all</td><td>Evaluates to true</td><td>number</td><td></td></tr>
<tr align="center">
<td>hydrogen</td><td>Evaluates to true if atom is a hydrogen</td><td>number</td><td></td></tr>
</table>
<p>
Notes:<br>
 The <code>all</code> keyword is used to force a selection string to match all atoms in instances where a selection is required. For example, a program to align frames of a trajectory DCD to a reference structure might require a selection to pick which atoms to use when computing the rotations and then another selection to pick which atoms are actually rotated. If you wanted to apply the rotation to all atoms, you just use the <code>all</code> keyword, i.e. <div class="fragment"><pre class="fragment">
aligner --selection='name='CA' &amp;&amp; segid =~ "BAR[12]"' --transform='all' foo.pdb foo.dcd newfoo
</pre></div><h3><a class="anchor" name="regexps">
Regular Expression Matching</a></h3>
The regular expression matching operator "=~" deserves special attention. It's use is more restrictive than the other operators in that it can only take a keyword that evaluates to a string on the left-hand side and a string on the right-hand side. So, the following expressions are valid: <div class="fragment"><pre class="fragment">
name =~ "CA"
name =~ "^(C|O|N)$"
segid =~ "PROT|HEME"
</pre></div> While the following are not valid: <div class="fragment"><pre class="fragment">
resid =~ "10[0-9][0-9]"
segid =~ 0010
name =~ resname
</pre></div><p>
The regular expression syntax supported is the PERL syntax as implemented by the Boost libraries. While you can write regular expressions that look a lot like globbing (a la VMD selections), keep in mind that it isn't globbing. It's a regular expression, which is more powerful anyway... You do need to be careful though that your shell does not munge any of the regex operators. It's a good idea to use single quotes when you're writing regex's in a shell.<p>
The string equality operators ("==" and "!=") both consider the <em>entire</em> string. <div class="fragment"><pre class="fragment">
"CA" == "C"  --&gt; false
 "C" == "C"  --&gt; true
</pre></div> You can use the "=~" operator to perform a substring match. <div class="fragment"><pre class="fragment">
"CA" == "C"  --&gt; false
 "C" == "C"  --&gt; true
"CA" =~ "C"  --&gt; true
</pre></div> This brings up an important point about using regular expressions: be careful of unexpected substring matches. For example, let's say you are wanting to pick out all backbone atoms and you write this selection string: <div class="fragment"><pre class="fragment">
name =~ "C|CA|O|N"
</pre></div> Now look what happens when the following atom names are matched: <div class="fragment"><pre class="fragment">
 "CG" --&gt; true
"CD1" --&gt; true
 "NE" --&gt; true
"OH2" --&gt; true
</pre></div> The problem is that the regular expression is not constrained, so even though you explicitly put "CA" and "CB" in there, you also have a "C" which says <em>any</em> atom name with a "C" in it is a match. If you want to match a string <em>exactly</em> with a regular expression, you must anchor it: <div class="fragment"><pre class="fragment">
name =~ "^(C|CA|CB|O|N)$"
</pre></div><h3><a class="anchor" name="magops_explained">
Magical Operations</a></h3>
There is currently only one "magical operator" defined: "-&gt;". This operator takes a string keyword on the left-hand side (i.e. name, resname, or segid/segname) and a string on the right-hand side representing a regular expression pattern. It will then try to extract a numeric value (integer) from the subexpression matches. For example, suppose you have a range of segments that all follow a pattern such as "PG1", "PG2", "PG3", ..., "PG120". The regular expression "PG(\d+)" matches these and the pattern within the parenthesis is a subexpression. So, <div class="fragment"><pre class="fragment">
(segid-&gt;"L(\d+)") &gt;= 10 &amp;&amp; (segid-&gt;"L(\d+)") &lt;= 50
</pre></div> will match segid's "L10" through "L50". Since each matched subexpression will be examined for a valid integer conversion, the following will work as expected: <div class="fragment"><pre class="fragment">
segid-&gt;"(L|PG)(\d+)"
</pre></div><p>
There is a small hitch with the magical operator. If there is no match, it evaluates to -1. But this is a valid int, so you cannot do the following: <div class="fragment"><pre class="fragment">
segid-&gt;"L(\d+)" &lt;= 100
</pre></div> since it will match all segids. You can't, unless the &lt;= operator is also a little bit special. Fortunately, it is. If either operand is a negative number, both the &lt; and &lt;= operands assume that this is a flag for a null-match, and will result in a false value being returned. It's a bit of a kludge, but it works...<p>
<hr>
 <h2><a class="anchor" name="kahuna">
Putting It All Together...</a></h2>
When you perform a selection on an AtomicGroup using the selection language, the expression is evaluated once for each atom in the group. If it evaluates to "true" (integer 1), then the atom is added to the new selection. Only one atom is considered at a time.<p>
Here are some example selections: <div class="fragment"><pre class="fragment">
Extract C-alphas:
  name == "CA"

Solvent:
  segid == "SOLV" || segid == "BULK"

Solvent heavy atoms (oxygens only)
  name =~ "O" &amp;&amp; (segid == "SOLV" || segid == "BULK")

C-alphas from a range of residues:
  name == "CA" &amp;&amp; resid &gt;= 10 &amp;&amp; resid &lt;= 50
</pre></div><h3><a class="anchor" name="Usage">
Usage</a></h3>
Most tools based on LOOS will accept selection strings from the command-line. They must be enclosed in quotes though so they are all one argument to the tool. If you're using regular expressions, it's a good idea to use single quotes to prevent your shell from misinterpreting the regular expression operators and as mentioned before, back-slash escapes may need doubling.<p>
You can store your selection in a file if you want. To use it then, use the back-quote feature of your shell to "cat" your selection file. Since your selection must be one argument, you must enclose the back-quote within double-quotes, i.e. <div class="fragment"><pre class="fragment">
  a_tool_name "`cat myselection.txt`" arg arg arg
</pre></div><p>
If you store your selection in a file, then you can also use comments. A comment is anything after a "#" on a line. Here's an example of a selection in a file: <div class="fragment"><pre class="fragment">
### Select water oxygens only...
# Pick out any atom that contains an oxygen
name =~ "O" &amp;&amp;
(segid == "SOLV" || # any segment named SOLV
segid == "BULK")    # or named BULK
</pre></div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Apr 22 16:42:08 2010 for LOOS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
