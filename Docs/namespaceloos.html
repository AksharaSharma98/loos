<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LOOS: loos Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>loos Namespace Reference</h1>Namespace for most things not already encapsulated within a class.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_amber.html">Amber</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for reading in AMBER parmtop/coord files...  <a href="classloos_1_1_amber.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_amber_rst.html">AmberRst</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for reading amber restart files as a single-frame trajectory.  <a href="classloos_1_1_amber_rst.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_amber_traj.html">AmberTraj</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for reading amber coordinate trajectories.  <a href="classloos_1_1_amber_traj.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atom.html">Atom</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic <a class="el" href="classloos_1_1_atom.html" title="Basic Atom class for handling atom properties.">Atom</a> class for handling atom properties.  <a href="classloos_1_1_atom.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_atom_equals.html">AtomEquals</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares two atoms based solely on name, id, resid, resname, and segid.  <a href="structloos_1_1_atom_equals.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_atom_coords_equals.html">AtomCoordsEquals</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares two atoms based on name, id, resid, resname, segid, and coords.  <a href="structloos_1_1_atom_coords_equals.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_atom_selector.html">AtomSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual base-class for selecting atoms from a group.  <a href="structloos_1_1_atom_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for handling groups of Atoms (pAtoms, actually).  <a href="classloos_1_1_atomic_group.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_c_c_p_d_b.html">CCPDB</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for interpreting concatenated <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> files as a <a class="el" href="classloos_1_1_trajectory.html" title="Base-class for polymorphic trajectories.">Trajectory</a>.  <a href="classloos_1_1_c_c_p_d_b.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_coord.html">Coord</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic 3-D coordinates class.  <a href="classloos_1_1_coord.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_unit_cell.html">UnitCell</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class encapsulates crystallographic unit cell data.  <a href="classloos_1_1_unit_cell.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_d_c_d.html">DCD</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for reading <a class="el" href="classloos_1_1_d_c_d.html" title="Class for reading DCD files.">DCD</a> files.  <a href="classloos_1_1_d_c_d.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_d_c_d_writer.html">DCDWriter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <em>very</em> lightweight class for writing simple DCDs.  <a href="classloos_1_1_d_c_d_writer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_l_o_o_s_error.html">LOOSError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic LOOS exception.  <a href="classloos_1_1_l_o_o_s_error.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_parse_error.html">ParseError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception when parsing input data.  <a href="classloos_1_1_parse_error.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_null_result.html">NullResult</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception cause by some operation failing (ie no atoms selected).  <a href="classloos_1_1_null_result.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_missing_property.html">MissingProperty</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception caused by insufficient atom properties..  <a href="classloos_1_1_missing_property.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_numerical_error.html">NumericalError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception caused by a blas/atlas error.  <a href="classloos_1_1_numerical_error.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_fmt.html">Fmt</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output formatter class, adapted from Stroustrup's book.  <a href="classloos_1_1_fmt.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_bound_fmt.html">BoundFmt</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal helper class to bind formatting state.  <a href="structloos_1_1_bound_fmt.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_gromacs.html">Gromacs</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements a GROMACS model file (.gro).  <a href="classloos_1_1_gromacs.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_kernel.html">Kernel</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classloos_1_1_kernel.html" title="The Kernel (virtual machine) for compiling and executing user-defined atom selections...">Kernel</a> (virtual machine) for compiling and executing user-defined atom selections.  <a href="classloos_1_1_kernel.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_matrix44.html">Matrix44</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialized 4x4 Matrix class for handling coordinate transforms.  <a href="classloos_1_1_matrix44.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_matrix_read_error.html">MatrixReadError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic reading error class.  <a href="classloos_1_1_matrix_read_error.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>MatrixReadImpl</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_read_impl_3_01_t_00_01_p_00_01_math_1_1_sparse_array_01_4.html">MatrixReadImpl&lt; T, P, Math::SparseArray &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special handling for sparse matrices.  <a href="structloos_1_1_matrix_read_impl_3_01_t_00_01_p_00_01_math_1_1_sparse_array_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_read_impl_3_01_t_00_01_math_1_1_triangular_00_01_s_01_4.html">MatrixReadImpl&lt; T, Math::Triangular, S &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special handling for triangular matrices.  <a href="structloos_1_1_matrix_read_impl_3_01_t_00_01_math_1_1_triangular_00_01_s_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_precise_matrix_formatter.html">PreciseMatrixFormatter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic matrix element formatter allowing setting of width and precision.  <a href="classloos_1_1_precise_matrix_formatter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_scientific_matrix_formatter.html">ScientificMatrixFormatter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic matrix element formatter using scientific notation...  <a href="classloos_1_1_scientific_matrix_formatter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>MatrixWriteImpl</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_write_impl_3_01_t_00_01_p_00_01_math_1_1_sparse_array_00_01_f_01_4.html">MatrixWriteImpl&lt; T, P, Math::SparseArray, F &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write out a sparse matrix.  <a href="structloos_1_1_matrix_write_impl_3_01_t_00_01_p_00_01_math_1_1_sparse_array_00_01_f_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_write_impl_3_01_t_00_01_math_1_1_triangular_00_01_s_00_01_f_01_4.html">MatrixWriteImpl&lt; T, Math::Triangular, S, F &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write out a triangular matrix.  <a href="structloos_1_1_matrix_write_impl_3_01_t_00_01_math_1_1_triangular_00_01_s_00_01_f_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_parser.html">Parser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Front-end to the Bison/Flex parser.  <a href="classloos_1_1_parser.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_parser_driver.html">ParserDriver</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_p_d_b.html">PDB</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> reading/writing class.  <a href="classloos_1_1_p_d_b.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_remarks.html">Remarks</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for handling <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> <a class="el" href="classloos_1_1_remarks.html" title="Class for handling PDB Remarks.">Remarks</a>.  <a href="classloos_1_1_remarks.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_p_d_b_traj.html">PDBTraj</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for intepreting separate <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> files as a single trajectory.  <a href="classloos_1_1_p_d_b_traj.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_periodic_box.html">PeriodicBox</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for managing periodic box information.  <a href="classloos_1_1_periodic_box.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_shared_periodic_box.html">SharedPeriodicBox</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class manages a shared Periodicbox.  <a href="classloos_1_1_shared_periodic_box.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>AbstractObserver</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_simple_counter.html">SimpleCounter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic progress counter object, defining the interface...  <a href="classloos_1_1_simple_counter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_estimating_counter.html">EstimatingCounter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A progress counter that can estimate how much time is left.  <a href="classloos_1_1_estimating_counter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_trigger_always.html">TriggerAlways</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a simple "trigger" for use as a default.  <a href="classloos_1_1_trigger_always.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_progress_counter.html">ProgressCounter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The progress counter front-end.  <a href="classloos_1_1_progress_counter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_basic_progress.html">BasicProgress</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_percent_progress.html">PercentProgress</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provide feedback by percent-complete.  <a href="classloos_1_1_percent_progress.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_percent_progress_with_time.html">PercentProgressWithTime</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_trigger_every.html">TriggerEvery</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trigger every i-iterations.  <a href="classloos_1_1_trigger_every.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_percent_trigger.html">PercentTrigger</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trigger whenever at least frac percent more iterations have happened.  <a href="classloos_1_1_percent_trigger.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_p_s_f.html">PSF</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for reading a subset of the <a class="el" href="classloos_1_1_p_s_f.html" title="Class for reading a subset of the PSF format.">PSF</a> format.  <a href="classloos_1_1_p_s_f.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_c_alpha_selector.html">CAlphaSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predicate for selecting CA atoms.  <a href="structloos_1_1_c_alpha_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_backbone_selector.html">BackboneSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predicate for selecting backbone.  <a href="structloos_1_1_backbone_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_segid_selector.html">SegidSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predicate for selecting atoms based on the passed segid string.  <a href="structloos_1_1_segid_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_atom_name_selector.html">AtomNameSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predicate for selecting atoms based on explicit name matching.  <a href="structloos_1_1_atom_name_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_resid_range_selector.html">ResidRangeSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predicate for selecting atoms from a range of resid's.  <a href="structloos_1_1_resid_range_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_z_slice_selector.html">ZSliceSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predicate for selecting atoms in a specific range of z values.  <a href="structloos_1_1_z_slice_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_not_selector.html">NotSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negates a selection predicate.  <a href="structloos_1_1_not_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_hydrogen_selector.html">HydrogenSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select hydrogen atoms.  <a href="structloos_1_1_hydrogen_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_heavy_atom_selector.html">HeavyAtomSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select non-hydrogen atoms.  <a href="structloos_1_1_heavy_atom_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_and_selector.html">AndSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines two selectors with a logical "and".  <a href="structloos_1_1_and_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_or_selector.html">OrSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines two selectors with a logical "or".  <a href="structloos_1_1_or_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_solvent_selector.html">SolventSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predicate for selecting solvent based on common solvent SEGIDs.  <a href="structloos_1_1_solvent_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_heavy_solvent_selector.html">HeavySolventSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select only heavy solvent atoms.  <a href="structloos_1_1_heavy_solvent_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_kernel_selector.html">KernelSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Selection predicate that executes a compiled <a class="el" href="classloos_1_1_kernel.html" title="The Kernel (virtual machine) for compiling and executing user-defined atom selections...">Kernel</a>.  <a href="classloos_1_1_kernel_selector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_ascending_sort.html">AscendingSort</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Policy class for sorting in ascending sequence.  <a href="classloos_1_1_ascending_sort.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_descending_sort.html">DescendingSort</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Policy class for sorting in descending sequence.  <a href="classloos_1_1_descending_sort.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_stream_wrapper.html">StreamWrapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple wrapper class for caching stream pointers.  <a href="classloos_1_1_stream_wrapper.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_wall_timer.html">WallTimer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Policy class for tracking wall-time.  <a href="classloos_1_1_wall_timer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_user_timer.html">UserTimer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Policy class for tracking only user process time.  <a href="classloos_1_1_user_timer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_timer.html">Timer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for tracking time.  <a href="classloos_1_1_timer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_time_series.html">TimeSeries</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time Series Class.  <a href="classloos_1_1_time_series.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_tinker_arc.html">TinkerArc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for handling Tinker ARC files (concatenation of .xyz files).  <a href="classloos_1_1_tinker_arc.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_tinker_x_y_z.html">TinkerXYZ</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for reading a subset of the <a class="el" href="classloos_1_1_tinker_x_y_z.html" title="Class for reading a subset of the TinkerXYZ format.">TinkerXYZ</a> format.  <a href="classloos_1_1_tinker_x_y_z.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_trajectory.html">Trajectory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base-class for polymorphic trajectories.  <a href="classloos_1_1_trajectory.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_t_r_r.html">TRR</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing the GROMACS <a class="el" href="classloos_1_1_t_r_r.html" title="Class representing the GROMACS TRR trajectory files.">TRR</a> trajectory files.  <a href="classloos_1_1_t_r_r.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_unique_strings.html">UniqueStrings</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for uniquifying strings...  <a href="classloos_1_1_unique_strings.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_x_form.html">XForm</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matrix class for handling coordinate transforms...  <a href="classloos_1_1_x_form.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_x_t_c.html">XTC</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing GROMACS reduced precision, compressed trajectories.  <a href="classloos_1_1_x_t_c.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1internal.html">internal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loos esoterica. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html">Math</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Namespace for math and math-related things in <a class="el" href="namespaceloos.html" title="Namespace for most things not already encapsulated within a class.">loos</a>. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="14441c8676772c04dc6d08db44887151"></a><!-- doxytag: member="loos::pAtomicGroup" ref="14441c8676772c04dc6d08db44887151" args="" -->
typedef boost::shared_ptr<br>
&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pAtomicGroup</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="62a9eac32b9db6b2b15316c5933ab75d"></a><!-- doxytag: member="loos::greal" ref="62a9eac32b9db6b2b15316c5933ab75d" args="" -->
typedef double&nbsp;</td><td class="memItemRight" valign="bottom"><b>greal</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d9ad90e3b5d07cf29b9ddf698b6bda8"></a><!-- doxytag: member="loos::gint" ref="3d9ad90e3b5d07cf29b9ddf698b6bda8" args="" -->
typedef long&nbsp;</td><td class="memItemRight" valign="bottom"><b>gint</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a9db7c2cd6f381830ee2eafdfdfdf0e4"></a><!-- doxytag: member="loos::dcd_real" ref="a9db7c2cd6f381830ee2eafdfdfdf0e4" args="" -->
typedef float&nbsp;</td><td class="memItemRight" valign="bottom"><b>dcd_real</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="23e49cefcdaf7ebc4074701b3575354d"></a><!-- doxytag: member="loos::dcd_double" ref="23e49cefcdaf7ebc4074701b3575354d" args="" -->
typedef double&nbsp;</td><td class="memItemRight" valign="bottom"><b>dcd_double</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cc65167090212ee9ef5fbe456664a725"></a><!-- doxytag: member="loos::GCoord" ref="cc65167090212ee9ef5fbe456664a725" args="" -->
typedef <a class="el" href="classloos_1_1_coord.html">Coord</a>&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>GCoord</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e98ad536c7d55db0777466d2e289ecd9"></a><!-- doxytag: member="loos::pGCoord" ref="e98ad536c7d55db0777466d2e289ecd9" args="" -->
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pGCoord</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6cf07772410e906c25f91d8e61cbe4ec"></a><!-- doxytag: member="loos::pAtom" ref="6cf07772410e906c25f91d8e61cbe4ec" args="" -->
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_atom.html">Atom</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pAtom</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7e09291871df43363ebd6c1208b3c6b3"></a><!-- doxytag: member="loos::pTraj" ref="7e09291871df43363ebd6c1208b3c6b3" args="" -->
typedef boost::shared_ptr<br>
&lt; <a class="el" href="classloos_1_1_trajectory.html">Trajectory</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pTraj</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="71db4ff51b50bf97153cd5066169f9c6"></a><!-- doxytag: member="loos::pDCD" ref="71db4ff51b50bf97153cd5066169f9c6" args="" -->
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_d_c_d.html">DCD</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pDCD</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5612443977ee5f80750d5942698526f5"></a><!-- doxytag: member="loos::pAmberTraj" ref="5612443977ee5f80750d5942698526f5" args="" -->
typedef boost::shared_ptr<br>
&lt; <a class="el" href="classloos_1_1_amber_traj.html">AmberTraj</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pAmberTraj</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1c259756e217d4524c11f9fa9a543d09"></a><!-- doxytag: member="loos::pCCPDB" ref="1c259756e217d4524c11f9fa9a543d09" args="" -->
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_c_c_p_d_b.html">CCPDB</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pCCPDB</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7a35e716ca8ebbfbb41c1103d226b23c"></a><!-- doxytag: member="loos::pTinkerArc" ref="7a35e716ca8ebbfbb41c1103d226b23c" args="" -->
typedef boost::shared_ptr<br>
&lt; <a class="el" href="classloos_1_1_tinker_arc.html">TinkerArc</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pTinkerArc</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7f0da9847b65f7165cc73f69bcb7eebd"></a><!-- doxytag: member="loos::pPDBTraj" ref="7f0da9847b65f7165cc73f69bcb7eebd" args="" -->
typedef boost::shared_ptr<br>
&lt; <a class="el" href="classloos_1_1_p_d_b_traj.html">PDBTraj</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pPDBTraj</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6003eff82bee37538bf33bbf61d13d05"></a><!-- doxytag: member="loos::pXTC" ref="6003eff82bee37538bf33bbf61d13d05" args="" -->
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_x_t_c.html">XTC</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pXTC</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2160bb5fe891e3a23442652770fed1cb"></a><!-- doxytag: member="loos::pTRR" ref="2160bb5fe891e3a23442652770fed1cb" args="" -->
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_t_r_r.html">TRR</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pTRR</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d26d06605ac7fa467aebda6a9403a1f4"></a><!-- doxytag: member="loos::pPDB" ref="d26d06605ac7fa467aebda6a9403a1f4" args="" -->
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_p_d_b.html">PDB</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pPDB</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3cdadc7bbce79292e8587fff5673628d"></a><!-- doxytag: member="loos::pPSF" ref="3cdadc7bbce79292e8587fff5673628d" args="" -->
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_p_s_f.html">PSF</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pPSF</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d06ce169a29685220e441574c09f9ec5"></a><!-- doxytag: member="loos::pAmber" ref="d06ce169a29685220e441574c09f9ec5" args="" -->
typedef boost::shared_ptr&lt; <a class="el" href="classloos_1_1_amber.html">Amber</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pAmber</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fdb56aad450f747e11291af29bd32548"></a><!-- doxytag: member="loos::pAmberRst" ref="fdb56aad450f747e11291af29bd32548" args="" -->
typedef boost::shared_ptr<br>
&lt; <a class="el" href="classloos_1_1_amber_rst.html">AmberRst</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pAmberRst</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c24e9a289011d290b81f2c61cc89c96d"></a><!-- doxytag: member="loos::pTinkerXYZ" ref="c24e9a289011d290b81f2c61cc89c96d" args="" -->
typedef boost::shared_ptr<br>
&lt; <a class="el" href="classloos_1_1_tinker_x_y_z.html">TinkerXYZ</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pTinkerXYZ</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5c77a14a66259e1993361e831c2878a2"></a><!-- doxytag: member="loos::pGromacs" ref="5c77a14a66259e1993361e831c2878a2" args="" -->
typedef boost::shared_ptr<br>
&lt; <a class="el" href="classloos_1_1_gromacs.html">Gromacs</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pGromacs</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5399f8b1ce8f6cd4f002e3fe5b1e2966"></a><!-- doxytag: member="loos::RealMatrix" ref="5399f8b1ce8f6cd4f002e3fe5b1e2966" args="" -->
typedef <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; float, <br>
<a class="el" href="classloos_1_1_math_1_1_col_major.html">Math::ColMajor</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>RealMatrix</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e02a6cb7a9380eb98800a41814332e31"></a><!-- doxytag: member="loos::DoubleMatrix" ref="e02a6cb7a9380eb98800a41814332e31" args="" -->
typedef <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; double, <br>
<a class="el" href="classloos_1_1_math_1_1_col_major.html">Math::ColMajor</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>DoubleMatrix</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="abe405ed56fec26adefbd1cb5de50dd7"></a><!-- doxytag: member="loos::MDuple" ref="abe405ed56fec26adefbd1cb5de50dd7" args="" -->
typedef std::pair&lt; int, int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDuple</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="655584490721f039229fcb21c31300a5"></a><!-- doxytag: member="loos::dTimeSeries" ref="655584490721f039229fcb21c31300a5" args="" -->
typedef <a class="el" href="classloos_1_1_time_series.html">TimeSeries</a>&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>dTimeSeries</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="862847bc2f540b9992da04a1a8a1115f"></a><!-- doxytag: member="loos::fTimeSeries" ref="862847bc2f540b9992da04a1a8a1115f" args="" -->
typedef <a class="el" href="classloos_1_1_time_series.html">TimeSeries</a>&lt; float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>fTimeSeries</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c371342cdaaeea9ac9c1cbf89af5792f"></a><!-- doxytag: member="loos::base_generator_type" ref="c371342cdaaeea9ac9c1cbf89af5792f" args="" -->
typedef boost::mt19937&nbsp;</td><td class="memItemRight" valign="bottom"><b>base_generator_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="db4c317197fd53bdf8856e91988a9b0b"></a><!-- doxytag: member="loos::GMatrix" ref="db4c317197fd53bdf8856e91988a9b0b" args="" -->
typedef <a class="el" href="classloos_1_1_matrix44.html">Matrix44</a>&lt; greal &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>GMatrix</b></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="720ea78a60eea21b34ce037ad336aaf4"></a><!-- doxytag: member="loos::operator&lt;&lt;" ref="720ea78a60eea21b34ce037ad336aaf4" args="(std::ostream &amp;os, const loos::Atom &amp;a)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_atom.html">loos::Atom</a> &amp;a)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ce2567359abda91586ae2750e6e2d1d8"></a><!-- doxytag: member="loos::operator+" ref="ce2567359abda91586ae2750e6e2d1d8" args="(const pAtom &amp;lhs, const pAtom &amp;rhs)" -->
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const pAtom &amp;lhs, const pAtom &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="30e6726ac3e8f663fddbd7be4fa472bd"></a><!-- doxytag: member="loos::operator+" ref="30e6726ac3e8f663fddbd7be4fa472bd" args="(const pAtom &amp;lhs, const AtomicGroup &amp;rhs)" -->
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const pAtom &amp;lhs, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eb9f87a2fbf3583d9e6324cc18df9e5e"></a><!-- doxytag: member="loos::operator&lt;&lt;" ref="eb9f87a2fbf3583d9e6324cc18df9e5e" args="(std::ostream &amp;os, const AtomicGroup &amp;grp)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_coord.html">Coord</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#edc39a10168a1da45d94c00da2711407">operator*</a> (const <a class="el" href="classloos_1_1_matrix44.html">Matrix44</a>&lt; T &gt; &amp;, const <a class="el" href="classloos_1_1_coord.html">Coord</a>&lt; T &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a0e87f7aede1a7d0c40ac355deda1146">gridify</a> (<a class="el" href="classloos_1_1_d_c_d.html">DCD</a> &amp;dcd, double *avg_box, double *avg_unitvol, int gridsizes[], const std::vector&lt; int &gt; indices, int frameno=0, int window=1, double scale=1.0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map <a class="el" href="classloos_1_1_d_c_d.html" title="Class for reading DCD files.">DCD</a> coordinates onto a grid given a window and a range.  <a href="#a0e87f7aede1a7d0c40ac355deda1146"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="be25ba2b9027123aca28176782570862"></a><!-- doxytag: member="loos::averageStructure" ref="be25ba2b9027123aca28176782570862" args="(const std::vector&lt; AtomicGroup &gt; &amp;ensemble)" -->
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#be25ba2b9027123aca28176782570862">averageStructure</a> (const std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the average structure of a set of <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> objects. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a10ec538bd0a45ef4543c60489fb6a74">averageStructure</a> (const std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble, const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;xforms)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the average structure of a set of <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> objects.  <a href="#a10ec538bd0a45ef4543c60489fb6a74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f067b4ced1c982dcf4bcc94856d55318"></a><!-- doxytag: member="loos::averageStructure" ref="f067b4ced1c982dcf4bcc94856d55318" args="(const AtomicGroup &amp;, const std::vector&lt; XForm &gt; &amp;, pTraj &amp;traj, std::vector&lt; uint &gt; &amp;indices)" -->
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#f067b4ced1c982dcf4bcc94856d55318">averageStructure</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;, const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;, pTraj &amp;traj, std::vector&lt; uint &gt; &amp;indices)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the average structure from a trajectory reading only certain frames. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="50aefac013fa449999f74fa4e0df8b55"></a><!-- doxytag: member="loos::averageStructure" ref="50aefac013fa449999f74fa4e0df8b55" args="(const AtomicGroup &amp;, const std::vector&lt; XForm &gt; &amp;, pTraj &amp;traj)" -->
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#50aefac013fa449999f74fa4e0df8b55">averageStructure</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;, const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;, pTraj &amp;traj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the average structure using all frames in a trajectory. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0084e9b3f9fb691e1ad6af8c5e78f45b"></a><!-- doxytag: member="loos::iterativeAlignment" ref="0084e9b3f9fb691e1ad6af8c5e78f45b" args="(std::vector&lt; AtomicGroup &gt; &amp;ensemble, greal threshold=1e-6, int maxiter=1000)" -->
boost::tuple&lt; std::vector<br>
&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt;, greal, int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#0084e9b3f9fb691e1ad6af8c5e78f45b">iterativeAlignment</a> (std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble, greal threshold=1e-6, int maxiter=1000)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute an iterative superposition (a la Alan). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::tuple&lt; std::vector<br>
&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt;, greal, int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#840d87d2be092c503fb70a6c4dc0a7fe">iterativeAlignment</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, pTraj &amp;traj, std::vector&lt; uint &gt; &amp;frame_indices, greal threshold=1e-6, int maxiter=1000)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute an iterative superposition by reading in frames from the <a class="el" href="classloos_1_1_trajectory.html" title="Base-class for polymorphic trajectories.">Trajectory</a>.  <a href="#840d87d2be092c503fb70a6c4dc0a7fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0eb966a6f433cbf170fbfe97dbc1041"></a><!-- doxytag: member="loos::iterativeAlignment" ref="a0eb966a6f433cbf170fbfe97dbc1041" args="(const AtomicGroup &amp;g, pTraj &amp;traj, greal threshold, int maxiter)" -->
boost::tuple&lt; std::vector<br>
&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt;, greal, int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>iterativeAlignment</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, pTraj &amp;traj, greal threshold, int maxiter)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="87fa637f8cfa6289d84f12a818071c27"></a><!-- doxytag: member="loos::applyTransforms" ref="87fa637f8cfa6289d84f12a818071c27" args="(std::vector&lt; AtomicGroup &gt; &amp;ensemble, std::vector&lt; XForm &gt; &amp;xforms)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>applyTransforms</b> (std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble, std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;xforms)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0b08e1ea35c0b41c4ef7c023ddc66008"></a><!-- doxytag: member="loos::readTrajectory" ref="0b08e1ea35c0b41c4ef7c023ddc66008" args="(std::vector&lt; AtomicGroup &gt; &amp;ensemble, const AtomicGroup &amp;model, pTraj trajectory)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>readTrajectory</b> (std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;model, pTraj trajectory)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="78afa41f5adfbea531e21eb6619b3ac5"></a><!-- doxytag: member="loos::readTrajectory" ref="78afa41f5adfbea531e21eb6619b3ac5" args="(std::vector&lt; AtomicGroup &gt; &amp;ensemble, const AtomicGroup &amp;model, pTraj trajectory, std::vector&lt; uint &gt; &amp;frames)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>readTrajectory</b> (std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;model, pTraj trajectory, std::vector&lt; uint &gt; &amp;frames)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b105c97e5ba3247de8ade1fad86e5708"></a><!-- doxytag: member="loos::extractCoords" ref="b105c97e5ba3247de8ade1fad86e5708" args="(const std::vector&lt; AtomicGroup &gt; &amp;ensemble)" -->
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>extractCoords</b> (const std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="52bea8219aacef9d44fdafa407be8c50"></a><!-- doxytag: member="loos::extractCoords" ref="52bea8219aacef9d44fdafa407be8c50" args="(const std::vector&lt; AtomicGroup &gt; &amp;ensemble, const std::vector&lt; XForm &gt; &amp;xforms)" -->
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>extractCoords</b> (const std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble, const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;xforms)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0ee39a071d0643188f73b398af04c5d7"></a><!-- doxytag: member="loos::subtractAverage" ref="0ee39a071d0643188f73b398af04c5d7" args="(RealMatrix &amp;M)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>subtractAverage</b> (<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;M)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="129a08c104189242b4c2be8e79cdb4ee"></a><!-- doxytag: member="loos::svd" ref="129a08c104189242b4c2be8e79cdb4ee" args="(std::vector&lt; AtomicGroup &gt; &amp;ensemble, bool align)" -->
boost::tuple&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>, <br>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>, <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>svd</b> (std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;ensemble, bool align)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ddba2db09fd04a563c820e465b4aa6c6"></a><!-- doxytag: member="loos::operator&lt;&lt;" ref="ddba2db09fd04a563c820e465b4aa6c6" args="(std::ostream &amp;os, const BoundFmt &amp;bf)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ddba2db09fd04a563c820e465b4aa6c6">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structloos_1_1_bound_fmt.html">BoundFmt</a> &amp;bf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the output with the specified formatter. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0f289489846eda89983722a4cf7ebd81"></a><!-- doxytag: member="loos::operator&lt;&lt;" ref="0f289489846eda89983722a4cf7ebd81" args="(std::ostream &amp;os, const Kernel &amp;k)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_kernel.html">Kernel</a> &amp;k)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ca31ea1a332e67cae3e8674bbf2e6bc3"></a><!-- doxytag: member="loos::readAsciiMatrix" ref="ca31ea1a332e67cae3e8674bbf2e6bc3" args="(std::istream &amp;is)" -->
template&lt;class T, class P, template&lt; typename &gt; class S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ca31ea1a332e67cae3e8674bbf2e6bc3">readAsciiMatrix</a> (std::istream &amp;is)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read in a matrix from a stream returning a newly created matrix. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="054b45df48117bf2cf9234fd681dfdca"></a><!-- doxytag: member="loos::readAsciiMatrix" ref="054b45df48117bf2cf9234fd681dfdca" args="(std::istream &amp;is, Math::Matrix&lt; T, P, S &gt; &amp;M)" -->
template&lt;class T, class P, template&lt; typename &gt; class S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#054b45df48117bf2cf9234fd681dfdca">readAsciiMatrix</a> (std::istream &amp;is, <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read in a matrix from a stream storing it in the specified matrix. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="70d8b9f4ec16f1d28d3cc011c951e5c6"></a><!-- doxytag: member="loos::readAsciiMatrix" ref="70d8b9f4ec16f1d28d3cc011c951e5c6" args="(const std::string &amp;fname)" -->
template&lt;class T, class P, template&lt; typename &gt; class S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#70d8b9f4ec16f1d28d3cc011c951e5c6">readAsciiMatrix</a> (const std::string &amp;fname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read in a matrix from a file returning a newly created matrix. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="728672f554717e2b925af7231597f7f7"></a><!-- doxytag: member="loos::readAsciiMatrix" ref="728672f554717e2b925af7231597f7f7" args="(const std::string &amp;fname, Math::Matrix&lt; T, P, S &gt; &amp;M)" -->
template&lt;class T, class P, template&lt; typename &gt; class S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#728672f554717e2b925af7231597f7f7">readAsciiMatrix</a> (const std::string &amp;fname, <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read in a matrix from a file storing it in the specified matrix. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class P, template&lt; typename &gt; class S, class F&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#7ca6d958f9e7c5cc09aab9527d21aef1">writeAsciiMatrix</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const MDuple &amp;start, const MDuple &amp;end, const bool trans=false, F fmt=F())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a submatrix to a stream.  <a href="#7ca6d958f9e7c5cc09aab9527d21aef1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="d012bec215db6f46d016cbf98e845389"></a><!-- doxytag: member="loos::writeAsciiMatrix" ref="d012bec215db6f46d016cbf98e845389" args="(std::ostream &amp;os, const Math::Matrix&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const MDuple &amp;start, const MDuple &amp;end, const bool trans=false)" -->
template&lt;class T, class P, template&lt; typename &gt; class S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#d012bec215db6f46d016cbf98e845389">writeAsciiMatrix</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const MDuple &amp;start, const MDuple &amp;end, const bool trans=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a submatrix to a stream. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="fc37523a237b6045319ac5a9595c826d"></a><!-- doxytag: member="loos::writeAsciiMatrix" ref="fc37523a237b6045319ac5a9595c826d" args="(std::ostream &amp;os, const Math::Matrix&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false, F fmt=F())" -->
template&lt;class T, class P, template&lt; typename &gt; class S, class F&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#fc37523a237b6045319ac5a9595c826d">writeAsciiMatrix</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false, F fmt=F())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an entire matrix to a stream. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="97eba31ed56082f4c858460f64531d30"></a><!-- doxytag: member="loos::writeAsciiMatrix" ref="97eba31ed56082f4c858460f64531d30" args="(std::ostream &amp;os, const Math::Matrix&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false)" -->
template&lt;class T, class P, template&lt; typename &gt; class S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#97eba31ed56082f4c858460f64531d30">writeAsciiMatrix</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an entire matrix to a stream. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="bdc7f62769ba949db07453cb46960338"></a><!-- doxytag: member="loos::writeAsciiMatrix" ref="bdc7f62769ba949db07453cb46960338" args="(const std::string &amp;fname, const Math::Matrix&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const MDuple &amp;start, const MDuple &amp;end, const bool trans=false, F fmt=F())" -->
template&lt;class T, class P, template&lt; typename &gt; class S, class F&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#bdc7f62769ba949db07453cb46960338">writeAsciiMatrix</a> (const std::string &amp;fname, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const MDuple &amp;start, const MDuple &amp;end, const bool trans=false, F fmt=F())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a submatrix to a file. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ce14a09b2818951d4d158e2ec6bb9d31"></a><!-- doxytag: member="loos::writeAsciiMatrix" ref="ce14a09b2818951d4d158e2ec6bb9d31" args="(const std::string &amp;fname, const Math::Matrix&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const MDuple &amp;start, const MDuple &amp;end, const bool trans=false)" -->
template&lt;class T, class P, template&lt; typename &gt; class S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#ce14a09b2818951d4d158e2ec6bb9d31">writeAsciiMatrix</a> (const std::string &amp;fname, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const MDuple &amp;start, const MDuple &amp;end, const bool trans=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a submatrix to a file. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="61ae09c3955e11990bd04909cfd5972d"></a><!-- doxytag: member="loos::writeAsciiMatrix" ref="61ae09c3955e11990bd04909cfd5972d" args="(const std::string &amp;fname, const Math::Matrix&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false, F fmt=F())" -->
template&lt;class T, class P, template&lt; typename &gt; class S, class F&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#61ae09c3955e11990bd04909cfd5972d">writeAsciiMatrix</a> (const std::string &amp;fname, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false, F fmt=F())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an entire matrix to a file. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="939a03a5956bee849139878b20011603"></a><!-- doxytag: member="loos::writeAsciiMatrix" ref="939a03a5956bee849139878b20011603" args="(const std::string &amp;fname, const Math::Matrix&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false)" -->
template&lt;class T, class P, template&lt; typename &gt; class S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#939a03a5956bee849139878b20011603">writeAsciiMatrix</a> (const std::string &amp;fname, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an entire matrix to a file. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="514899a26c171f6c8048de4e48a289b8"></a><!-- doxytag: member="loos::FormattedUnitCell" ref="514899a26c171f6c8048de4e48a289b8" args="(std::ostream &amp;os, const UnitCell &amp;u)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>FormattedUnitCell</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_unit_cell.html">UnitCell</a> &amp;u)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bdec91122443dd4148e9405ec100d71a"></a><!-- doxytag: member="loos::XTALLine" ref="bdec91122443dd4148e9405ec100d71a" args="(std::ostream &amp;os, const GCoord &amp;box)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>XTALLine</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9debdbfb6bae45018ffce166f443b700"></a><!-- doxytag: member="loos::FormatConectRecords" ref="9debdbfb6bae45018ffce166f443b700" args="(std::ostream &amp;os, PDB &amp;p)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>FormatConectRecords</b> (std::ostream &amp;os, <a class="el" href="classloos_1_1_p_d_b.html">PDB</a> &amp;p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#6f25e576bead57392027cc21abee92fc">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classloos_1_1_p_d_b.html">PDB</a> &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output the group as a <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a>...  <a href="#6f25e576bead57392027cc21abee92fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dc7ce15a19bf0392a1d0e469ff133ba1"></a><!-- doxytag: member="loos::operator&lt;&lt;" ref="dc7ce15a19bf0392a1d0e469ff133ba1" args="(std::ostream &amp;os, const Remarks &amp;r)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_remarks.html">Remarks</a> &amp;r)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#972949e22a6fad942704a83051919218">createSystem</a> (const std::string &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory function for reading in structure files.  <a href="#972949e22a6fad942704a83051919218"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f269f7aa528f240757d94928d86f33fb"></a><!-- doxytag: member="loos::createSystemPtr" ref="f269f7aa528f240757d94928d86f33fb" args="(const std::string &amp;s)" -->
pAtomicGroup&nbsp;</td><td class="memItemRight" valign="bottom"><b>createSystemPtr</b> (const std::string &amp;s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">pTraj&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#5c3b7c1613a234d4b4d23f23b5d4af6f">createTrajectory</a> (const std::string &amp;, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory function for reading in a trajectory file.  <a href="#5c3b7c1613a234d4b4d23f23b5d4af6f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, class SortPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::vector&lt; uint &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#58bcdebad4068cd371fcc94218d9a09f">sortedIndex</a> (const T &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort a container in ascending sequence.  <a href="#58bcdebad4068cd371fcc94218d9a09f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="37985ff6232c16ead04dadca3ef1cb14"></a><!-- doxytag: member="loos::operator&lt;&lt;" ref="37985ff6232c16ead04dadca3ef1cb14" args="(std::ostream &amp;os, const Timer&lt; T &gt; &amp;t)" -->
template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_timer.html">Timer</a>&lt; T &gt; &amp;t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="363b240e30a710c8f48ad1bc7c08d5a8"></a><!-- doxytag: member="loos::findBaseName" ref="363b240e30a710c8f48ad1bc7c08d5a8" args="(const std::string &amp;)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#363b240e30a710c8f48ad1bc7c08d5a8">findBaseName</a> (const std::string &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pull off the file name extension (if present). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8dcba979f250f7217737e42921d40bb7"></a><!-- doxytag: member="loos::getNextLine" ref="8dcba979f250f7217737e42921d40bb7" args="(std::istream &amp;, int *)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#8dcba979f250f7217737e42921d40bb7">getNextLine</a> (std::istream &amp;, int *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the next line of input, skipping blanks and stripping comments. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d8b9d5eb754eb51c5481dd89159c22d"></a><!-- doxytag: member="loos::readIndexMap" ref="6d8b9d5eb754eb51c5481dd89159c22d" args="(std::istream &amp;)" -->
std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#6d8b9d5eb754eb51c5481dd89159c22d">readIndexMap</a> (std::istream &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a list of integers from a stream. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#9938bb182cff8aeddeb0eb7aac81b09f">invocationHeader</a> (int, char *[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an invocation header.  <a href="#9938bb182cff8aeddeb0eb7aac81b09f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_coord.html">GCoord</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#aa994f20daba9b26f90c194c2c472382">boxFromRemarks</a> (const <a class="el" href="classloos_1_1_remarks.html">Remarks</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract the Alan-style box-size from a <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> <a class="el" href="classloos_1_1_remarks.html" title="Class for handling PDB Remarks.">Remarks</a> block.  <a href="#aa994f20daba9b26f90c194c2c472382"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a99d766080fbbeea698c4c68594f9341"></a><!-- doxytag: member="loos::remarksHasBox" ref="a99d766080fbbeea698c4c68594f9341" args="(const Remarks &amp;)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#a99d766080fbbeea698c4c68594f9341">remarksHasBox</a> (const <a class="el" href="classloos_1_1_remarks.html">Remarks</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks to see if a <a class="el" href="classloos_1_1_remarks.html" title="Class for handling PDB Remarks.">Remarks</a> block has an Alan-style box size in it. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b82436be3d1bfa01542d6a8f3820a38b"></a><!-- doxytag: member="loos::rng_singleton" ref="b82436be3d1bfa01542d6a8f3820a38b" args="(void)" -->
base_generator_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#b82436be3d1bfa01542d6a8f3820a38b">rng_singleton</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suite-wide random number generator singleton. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#90106a26c7b34d85d9cac2be0ed823d1">randomSeedRNG</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Randomly seeds the RNG.  <a href="#90106a26c7b34d85d9cac2be0ed823d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#26ed849d7c6ab8f0dad7ac5665a47b83">parseRangeList</a> (const std::string &amp;text)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses a comma-separated list of Octave-style ranges.  <a href="#26ed849d7c6ab8f0dad7ac5665a47b83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#01ad12706a6b9884cc8f3a5677a899e3">selectAtoms</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;, const std::string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a string-based selection to an atomic group...  <a href="#01ad12706a6b9884cc8f3a5677a899e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c67409de5eaa690a57996609a36a34b6"></a><!-- doxytag: member="loos::timeAsString" ref="c67409de5eaa690a57996609a36a34b6" args="(const double t)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>timeAsString</b> (const double t)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="28e118ea997ee87dc4e5830e8d120720"></a><!-- doxytag: member="loos::parseStringAs&lt; std::string &gt;" ref="28e118ea997ee87dc4e5830e8d120720" args="(const std::string &amp;source, const uint pos, const uint nelem)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parseStringAs&lt; std::string &gt;</b> (const std::string &amp;source, const uint pos, const uint nelem)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="c5c11b6d9274ca5b65bf1f05ce96e84b"></a><!-- doxytag: member="loos::fixedSizeFormat" ref="c5c11b6d9274ca5b65bf1f05ce96e84b" args="(const std::string &amp;s, const uint n)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>fixedSizeFormat</b> (const std::string &amp;s, const uint n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="79bc7f779a522f273b9437a8280b60ee"></a><!-- doxytag: member="loos::parseStringAsHybrid36" ref="79bc7f779a522f273b9437a8280b60ee" args="(const std::string &amp;source, const uint pos=0, const uint nelem=0)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#79bc7f779a522f273b9437a8280b60ee">parseStringAsHybrid36</a> (const std::string &amp;source, const uint pos=0, const uint nelem=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a hybrid-36 encoded string into an int. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b01118ab9b5036271c399aedee6eccbb"></a><!-- doxytag: member="loos::hybrid36AsString" ref="b01118ab9b5036271c399aedee6eccbb" args="(int value, uint fieldsize)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos.html#b01118ab9b5036271c399aedee6eccbb">hybrid36AsString</a> (int value, uint fieldsize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert an int into a hybrid-36 encoded string. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::vector&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#837eea9a27f14eb46e6d852f468dd3f0">parseRange</a> (const std::string &amp;text)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse an Octave/Matlab-style range.  <a href="#837eea9a27f14eb46e6d852f468dd3f0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="e878e7be7628c017ba4a198211102d07"></a><!-- doxytag: member="loos::parseRangeList" ref="e878e7be7628c017ba4a198211102d07" args="(const std::vector&lt; std::string &gt; &amp;ranges)" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::vector&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#e878e7be7628c017ba4a198211102d07">parseRangeList</a> (const std::vector&lt; std::string &gt; &amp;ranges)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses a list of Octave-style ranges taken from a vector of strings. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#13fd2c6332dbe5d9a2e839d80978992e">swab</a> (const T &amp;datum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a byte-swapped copy of an arbitrary type.  <a href="#13fd2c6332dbe5d9a2e839d80978992e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="7585779a474911fb422ac94d1a98a264"></a><!-- doxytag: member="loos::parseStringAs" ref="7585779a474911fb422ac94d1a98a264" args="(const std::string &amp;source, const uint pos=0, const uint nelem=0)" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceloos.html#7585779a474911fb422ac94d1a98a264">parseStringAs</a> (const std::string &amp;source, const uint pos=0, const uint nelem=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts a field from a string. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="696ec259ca0a21acfdbc140543f5aaea"></a><!-- doxytag: member="loos::fixedSizeFormat" ref="696ec259ca0a21acfdbc140543f5aaea" args="(const T t, const uint n)" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>fixedSizeFormat</b> (const T t, const uint n)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9d31eb9566329001c9c066ca28284118"></a><!-- doxytag: member="loos::kilobytes" ref="9d31eb9566329001c9c066ca28284118" args="" -->
const uint&nbsp;</td><td class="memItemRight" valign="bottom"><b>kilobytes</b> = 1024</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ff8a839bdd5f8677e9f2fb3fbec971a2"></a><!-- doxytag: member="loos::megabytes" ref="ff8a839bdd5f8677e9f2fb3fbec971a2" args="" -->
const uint&nbsp;</td><td class="memItemRight" valign="bottom"><b>megabytes</b> = kilobytes * kilobytes</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="55aed2289adecf6edc63323e466bb7e5"></a><!-- doxytag: member="loos::gigabytes" ref="55aed2289adecf6edc63323e466bb7e5" args="" -->
const uint&nbsp;</td><td class="memItemRight" valign="bottom"><b>gigabytes</b> = megabytes * kilobytes</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Namespace for most things not already encapsulated within a class. <hr><h2>Function Documentation</h2>
<a class="anchor" name="a10ec538bd0a45ef4543c60489fb6a74"></a><!-- doxytag: member="loos::averageStructure" ref="a10ec538bd0a45ef4543c60489fb6a74" args="(const std::vector&lt; AtomicGroup &gt; &amp;ensemble, const std::vector&lt; XForm &gt; &amp;xforms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::averageStructure           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; AtomicGroup &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ensemble</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; XForm &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>xforms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the average structure of a set of <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> objects. 
<p>
Takes into consideration the passed set of transforms... 
<p>Definition at line <a class="el" href="ensembles_8cpp-source.html#l00059">59</a> of file <a class="el" href="ensembles_8cpp-source.html">ensembles.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="aa994f20daba9b26f90c194c2c472382"></a><!-- doxytag: member="loos::boxFromRemarks" ref="aa994f20daba9b26f90c194c2c472382" args="(const Remarks &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_coord.html">GCoord</a> loos::boxFromRemarks           </td>
          <td>(</td>
          <td class="paramtype">const Remarks &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract the Alan-style box-size from a <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> <a class="el" href="classloos_1_1_remarks.html" title="Class for handling PDB Remarks.">Remarks</a> block. 
<p>
Returns a GCoord(99999.99, 99999.99, 99999.99) if there is no box info found in the remarks block. 
<p>Definition at line <a class="el" href="utils_8cpp-source.html#l00145">145</a> of file <a class="el" href="utils_8cpp-source.html">utils.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="972949e22a6fad942704a83051919218"></a><!-- doxytag: member="loos::createSystem" ref="972949e22a6fad942704a83051919218" args="(const std::string &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::createSystem           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Factory function for reading in structure files. 
<p>
This function will try to determine the filetype for a structure file by examining the suffix of the file. It will return an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> copy of the input structure.<p>
<a class="el" href="classloos_1_1_amber.html" title="Class for reading in AMBER parmtop/coord files...">Amber</a> files are handled differently... If the filename ends with ".prmtop", then LOOS will check for a corresponding ".inpcrd" file. If one is found, then the coords will be loaded into the group. Otherwise, the prmtop will be loaded without coords and returned. 
<p>Definition at line <a class="el" href="sfactories_8cpp-source.html#l00048">48</a> of file <a class="el" href="sfactories_8cpp-source.html">sfactories.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="5c3b7c1613a234d4b4d23f23b5d4af6f"></a><!-- doxytag: member="loos::createTrajectory" ref="5c3b7c1613a234d4b4d23f23b5d4af6f" args="(const std::string &amp;, const AtomicGroup &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pTraj loos::createTrajectory           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AtomicGroup &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Factory function for reading in a trajectory file. 
<p>
This function will try to determine the filetype for a trajectory by examining the suffix of the file. It will return a boost shared pointer to a new <a class="el" href="classloos_1_1_trajectory.html" title="Base-class for polymorphic trajectories.">Trajectory</a> object.<p>
It is <em>very</em> <em>important</em> to understand that the object returned by this function must behave polymorphically. That's why it is wrapped in a boost shared pointer to the base class. Do not try to deference it and assign it to a <a class="el" href="classloos_1_1_trajectory.html" title="Base-class for polymorphic trajectories.">Trajectory</a> object... 
<p>Definition at line <a class="el" href="sfactories_8cpp-source.html#l00099">99</a> of file <a class="el" href="sfactories_8cpp-source.html">sfactories.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="a0e87f7aede1a7d0c40ac355deda1146"></a><!-- doxytag: member="loos::gridify" ref="a0e87f7aede1a7d0c40ac355deda1146" args="(DCD &amp;dcd, double *avg_box, double *avg_unitvol, int gridsizes[], const std::vector&lt; int &gt; indices, int frameno=0, int window=1, double scale=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * loos::gridify           </td>
          <td>(</td>
          <td class="paramtype">DCD &amp;&nbsp;</td>
          <td class="paramname"> <em>dcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>avg_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>avg_unitvol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gridsizes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt;&nbsp;</td>
          <td class="paramname"> <em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameno</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>window</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em> = <code>1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Map <a class="el" href="classloos_1_1_d_c_d.html" title="Class for reading DCD files.">DCD</a> coordinates onto a grid given a window and a range. 
<p>
Returns a raw double array representing a 3D grid of densities averaging over the specified window. Each coordinate in a <a class="el" href="classloos_1_1_d_c_d.html" title="Class for reading DCD files.">DCD</a> frame is considered a point of unit mass, for purposes of computing densities...<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dcd</em>&nbsp;</td><td>The <a class="el" href="classloos_1_1_d_c_d.html" title="Class for reading DCD files.">DCD</a> object to use for reading frames </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>avg_box</em>&nbsp;</td><td>Stores the average box size (extracted from crystal params) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>avg_unitvol</em>&nbsp;</td><td>Stores the average box-volume </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gridsizes</em>&nbsp;</td><td>Array giving the i, j, k dimensions of the grid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indices</em>&nbsp;</td><td>Indices into the <a class="el" href="classloos_1_1_d_c_d.html" title="Class for reading DCD files.">DCD</a> frame to operate over (i.e. which atoms) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frameno</em>&nbsp;</td><td>Which frame to start on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>window</em>&nbsp;</td><td>How many frames to operate over </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>Scales up the density </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="dcd__utils_8cpp-source.html#l00060">60</a> of file <a class="el" href="dcd__utils_8cpp-source.html">dcd_utils.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="9938bb182cff8aeddeb0eb7aac81b09f"></a><!-- doxytag: member="loos::invocationHeader" ref="9938bb182cff8aeddeb0eb7aac81b09f" args="(int, char *[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string loos::invocationHeader           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname">[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an invocation header. 
<p>
This is a string that can be embedded in output that records the invoking user, command-line, and a timestamp. 
<p>Definition at line <a class="el" href="utils_8cpp-source.html#l00108">108</a> of file <a class="el" href="utils_8cpp-source.html">utils.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="840d87d2be092c503fb70a6c4dc0a7fe"></a><!-- doxytag: member="loos::iterativeAlignment" ref="840d87d2be092c503fb70a6c4dc0a7fe" args="(const AtomicGroup &amp;g, pTraj &amp;traj, std::vector&lt; uint &gt; &amp;frame_indices, greal threshold=1e-6, int maxiter=1000)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::tuple&lt; std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt;, greal, int &gt; loos::iterativeAlignment           </td>
          <td>(</td>
          <td class="paramtype">const AtomicGroup &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pTraj &amp;&nbsp;</td>
          <td class="paramname"> <em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>frame_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">greal&nbsp;</td>
          <td class="paramname"> <em>threshold</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxiter</em> = <code>1000</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute an iterative superposition by reading in frames from the <a class="el" href="classloos_1_1_trajectory.html" title="Base-class for polymorphic trajectories.">Trajectory</a>. 
<p>
This function will internally cache an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> copy for each frame of the trajectory. This could chew up a lot of memory, but we make the assumption that you will usually be aligning against a fairly small subset of each frame... 
<p>Definition at line <a class="el" href="ensembles_8cpp-source.html#l00169">169</a> of file <a class="el" href="ensembles_8cpp-source.html">ensembles.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="edc39a10168a1da45d94c00da2711407"></a><!-- doxytag: member="loos::operator*" ref="edc39a10168a1da45d94c00da2711407" args="(const Matrix44&lt; T &gt; &amp;, const Coord&lt; T &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_coord.html">Coord</a>&lt; T &gt; loos::operator*           </td>
          <td>(</td>
          <td class="paramtype">const Matrix44&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coord&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Matrix-vector multiply This has to be a friend outside the class for GCC to be happy... 
<p>Definition at line <a class="el" href="_matrix44_8hpp-source.html#l00237">237</a> of file <a class="el" href="_matrix44_8hpp-source.html">Matrix44.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="6f25e576bead57392027cc21abee92fc"></a><!-- doxytag: member="loos::operator&lt;&lt;" ref="6f25e576bead57392027cc21abee92fc" args="(std::ostream &amp;os, PDB &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; loos::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PDB &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output the group as a <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a>... 
<p>
Output as a <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a>.<p>
There are some formatting changes that occur when the group has a large number of atoms or resids. The most significant is when you have 100,000 or more, in which case you lose the altloc and chainid fields on output. However, the output <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> will load into pymol... 
<p>Definition at line <a class="el" href="pdb_8cpp-source.html#l00377">377</a> of file <a class="el" href="pdb_8cpp-source.html">pdb.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="837eea9a27f14eb46e6d852f468dd3f0"></a><!-- doxytag: member="loos::parseRange" ref="837eea9a27f14eb46e6d852f468dd3f0" args="(const std::string &amp;text)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; loos::parseRange           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse an Octave/Matlab-style range. 
<p>
The Octave format is one of the following:<ul>
<li>value</li><li>start:stop</li><li>start:step:stop</li></ul>
<p>
The range is inclusive for both ends. Internally, a vector of T's is created. There is no checking to make sure that the vector doesn't completely fill up memory.<p>
Care should also be exercised when using unsigned types and reversed ranges, i.e. parseRange&lt;unsigned int&gt;("5:0") 
<p>Definition at line <a class="el" href="utils_8hpp-source.html#l00107">107</a> of file <a class="el" href="utils_8hpp-source.html">utils.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="26ed849d7c6ab8f0dad7ac5665a47b83"></a><!-- doxytag: member="loos::parseRangeList" ref="26ed849d7c6ab8f0dad7ac5665a47b83" args="(const std::string &amp;text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; loos::parseRangeList           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parses a comma-separated list of Octave-style ranges. 
<p>
Parses a list of Octave-style range specifiers (for compatability).<p>
This function breaks apart a string at the commas and passes each substring to parseRange. The union of all of the vectors returned by parseRange is then sorted in ascending order and duplicate values are removed. This vector is then returned to the caller. 
<p>Definition at line <a class="el" href="utils_8cpp-source.html#l00197">197</a> of file <a class="el" href="utils_8cpp-source.html">utils.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="90106a26c7b34d85d9cac2be0ed823d1"></a><!-- doxytag: member="loos::randomSeedRNG" ref="90106a26c7b34d85d9cac2be0ed823d1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::randomSeedRNG           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Randomly seeds the RNG. 
<p>
Currently uses time(3) to seed the RNG obtained from the singleton... 
<p>Definition at line <a class="el" href="utils_8cpp-source.html#l00190">190</a> of file <a class="el" href="utils_8cpp-source.html">utils.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="01ad12706a6b9884cc8f3a5677a899e3"></a><!-- doxytag: member="loos::selectAtoms" ref="01ad12706a6b9884cc8f3a5677a899e3" args="(const AtomicGroup &amp;, const std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::selectAtoms           </td>
          <td>(</td>
          <td class="paramtype">const AtomicGroup &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&nbsp;</td>
          <td class="paramname"> <em>selection</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies a string-based selection to an atomic group... 
<p>
This routine parses the passed string, turning it into a selector and applies it to <em>source</em>. If there is an exception in the parsing, this is repackaged into a more sensible error message (including the string that generated the error). No other exceptions are caught.<p>
We're also assuming that you're <em>always</em> wanting to select some atoms, so lack of selection constitutes an error and an exception is thrown. Note that in both the case of a parse error and null-selection, a runtime_error exception is thrown so the catcher cannot disambiguate between the two. 
<p>Definition at line <a class="el" href="utils_8cpp-source.html#l00213">213</a> of file <a class="el" href="utils_8cpp-source.html">utils.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="58bcdebad4068cd371fcc94218d9a09f"></a><!-- doxytag: member="loos::sortedIndex" ref="58bcdebad4068cd371fcc94218d9a09f" args="(const T &amp;A)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class SortPredicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint &gt; loos::sortedIndex           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sort a container in ascending sequence. 
<p>
Sort a container using the given sort policy, returning the indices that permutes the container into the sorted order. The container to be sorted must support T::size() and T::operator[]. What is returned is a vector of unsigned ints that represent the index into the container when it is sorted. 
<p>Definition at line <a class="el" href="sorting_8hpp-source.html#l00071">71</a> of file <a class="el" href="sorting_8hpp-source.html">sorting.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="13fd2c6332dbe5d9a2e839d80978992e"></a><!-- doxytag: member="loos::swab" ref="13fd2c6332dbe5d9a2e839d80978992e" args="(const T &amp;datum)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T loos::swab           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>datum</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a byte-swapped copy of an arbitrary type. 
<p>
Only valid for simple types (i.e. int, float, double) 
<p>Definition at line <a class="el" href="utils_8hpp-source.html#l00197">197</a> of file <a class="el" href="utils_8hpp-source.html">utils.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="7ca6d958f9e7c5cc09aab9527d21aef1"></a><!-- doxytag: member="loos::writeAsciiMatrix" ref="7ca6d958f9e7c5cc09aab9527d21aef1" args="(std::ostream &amp;os, const Math::Matrix&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const MDuple &amp;start, const MDuple &amp;end, const bool trans=false, F fmt=F())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class P, template&lt; typename &gt; class S, class F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; loos::writeAsciiMatrix           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Math::Matrix&lt; T, P, S &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>meta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MDuple &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MDuple &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>trans</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&nbsp;</td>
          <td class="paramname"> <em>fmt</em> = <code>F()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a submatrix to a stream. 
<p>
This family of functions write a matrix in ASCII format suitable for loading into Octave/Matlab or gnuplot. The <em>meta</em> information is written as part of the comment at the start of the file. The MDuple <em>start</em> and <em>end</em> are just pairs that give an <em></em>(j,i) starting and ending point within the matrix to write. Note that these arguments are not always honored (such as with a triangular matrix). The <em>trans</em> flag causes the output matrix to be the transpose of the stored matrix. The <em>fmt</em> arg is a functor that is expected for format each element of the matrix as a string. You can use this to adjust the precision of the output or delimit it, etc. The default is to use whatever the default operator&lt;&lt;() would be for type T. 
<p>Definition at line <a class="el" href="_matrix_write_8hpp-source.html#l00140">140</a> of file <a class="el" href="_matrix_write_8hpp-source.html">MatrixWrite.hpp</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Apr 22 16:42:11 2010 for LOOS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
