<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LOOS: AtomicGroup.hpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>AtomicGroup.hpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">  This file is part of LOOS.</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">  LOOS (Lightweight Object-Oriented Structure library)</span>
<a name="l00005"></a>00005 <span class="comment">  Copyright (c) 2008, Tod D. Romo, Alan Grossfield</span>
<a name="l00006"></a>00006 <span class="comment">  Department of Biochemistry and Biophysics</span>
<a name="l00007"></a>00007 <span class="comment">  School of Medicine &amp; Dentistry, University of Rochester</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">  This package (LOOS) is free software: you can redistribute it and/or modify</span>
<a name="l00010"></a>00010 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
<a name="l00011"></a>00011 <span class="comment">  the Free Software Foundation under version 3 of the License.</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">  This package is distributed in the hope that it will be useful,</span>
<a name="l00014"></a>00014 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00015"></a>00015 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00016"></a>00016 <span class="comment">  GNU General Public License for more details.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">  You should have received a copy of the GNU General Public License</span>
<a name="l00019"></a>00019 <span class="comment">  along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00020"></a>00020 <span class="comment">*/</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#if !defined(ATOMICGROUP_HPP)</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#define ATOMICGROUP_HPP</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;tr1/unordered_set&gt;</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;loos_defs.hpp&gt;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;Atom.hpp&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;XForm.hpp&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;UniqueStrings.hpp&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;PeriodicBox.hpp&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;utils.hpp&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;Matrix.hpp&gt;</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="keyword">namespace </span>loos {
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 
<a name="l00055"></a>00055 
<a name="l00056"></a><a class="code" href="structloos_1_1_atom_selector.html">00056</a>   <span class="keyword">struct </span><a class="code" href="structloos_1_1_atom_selector.html" title="Virtual base-class for selecting atoms from a group.">AtomSelector</a> {
<a name="l00060"></a>00060     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="structloos_1_1_atom_selector.html#445a67d3ac3130476cef180a64894cfa">operator()</a>(<span class="keyword">const</span> pAtom&amp; atom) <span class="keyword">const</span> =0;
<a name="l00061"></a>00061     <span class="keyword">virtual</span> ~<a class="code" href="structloos_1_1_atom_selector.html" title="Virtual base-class for selecting atoms from a group.">AtomSelector</a>() { }
<a name="l00062"></a>00062   };
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 
<a name="l00065"></a>00065   <span class="keyword">class </span><a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>;
<a name="l00066"></a>00066   <span class="keyword">typedef</span> boost::shared_ptr&lt;AtomicGroup&gt; pAtomicGroup;
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 
<a name="l00070"></a>00070 
<a name="l00087"></a><a class="code" href="classloos_1_1_atomic_group.html">00087</a>   <span class="keyword">class </span><a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> {
<a name="l00088"></a>00088   <span class="keyword">public</span>:
<a name="l00089"></a>00089     <span class="keyword">typedef</span> std::vector&lt;pAtom&gt;::iterator       iterator;
<a name="l00090"></a>00090     <span class="keyword">typedef</span> std::vector&lt;pAtom&gt;::const_iterator const_iterator;
<a name="l00091"></a>00091 
<a name="l00092"></a>00092   <span class="keyword">public</span>:
<a name="l00093"></a>00093     <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>() : _sorted(<span class="keyword">false</span>) { }
<a name="l00094"></a>00094 
<a name="l00096"></a>00096 
<a name="l00099"></a><a class="code" href="classloos_1_1_atomic_group.html#125a4b144bc5457366ae204e8f98f446">00099</a>     <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> n) : _sorted(true) {
<a name="l00100"></a>00100       assert(n &gt;= 1 &amp;&amp; <span class="stringliteral">"Invalid size in AtomicGroup(n)"</span>);
<a name="l00101"></a>00101       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;n; i++) {
<a name="l00102"></a>00102         pAtom pa(<span class="keyword">new</span> <a class="code" href="classloos_1_1_atom.html" title="Basic Atom class for handling atom properties.">Atom</a>);
<a name="l00103"></a>00103         pa-&gt;id(i);
<a name="l00104"></a>00104         atoms.push_back(pa);
<a name="l00105"></a>00105       }
<a name="l00106"></a>00106     }
<a name="l00107"></a>00107 
<a name="l00108"></a>00108     <span class="keyword">virtual</span> ~<a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>() { }
<a name="l00109"></a>00109 
<a name="l00111"></a>00111 
<a name="l00117"></a>00117     AtomicGroup <a class="code" href="classloos_1_1_atomic_group.html#1126df7bc01ffad44a95537f5ce40248" title="Creates a deep copy of this group.">copy</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00118"></a>00118 
<a name="l00120"></a>00120 
<a name="l00125"></a>00125     <span class="keyword">virtual</span> AtomicGroup* <a class="code" href="classloos_1_1_atomic_group.html#02ca8a6697b307b2ef86362c17b1c402" title="Creates a lightweight clone of this group (for polymorphism).">clone</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 
<a name="l00128"></a>00128     <span class="keywordtype">int</span> length(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span>(atoms.size()); }
<a name="l00129"></a>00129     <span class="keywordtype">int</span> size(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span>(atoms.size()); }
<a name="l00130"></a>00130     <span class="keywordtype">bool</span> empty(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span>(atoms.empty()); }
<a name="l00131"></a>00131 
<a name="l00133"></a>00133     pAtom <a class="code" href="classloos_1_1_atomic_group.html#f86dc40255ba8e1af05c81737988e20b" title="Get the ith atom from this group.">getAtom</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> i) <span class="keyword">const</span>;
<a name="l00134"></a>00134 
<a name="l00136"></a>00136     pAtom&amp; <a class="code" href="classloos_1_1_atomic_group.html#f5fdbd8588fe478c2b6c69ab6a421400" title="Same as getAtom(i).">operator[]</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> i);
<a name="l00137"></a>00137     <span class="keyword">const</span> pAtom&amp; <a class="code" href="classloos_1_1_atomic_group.html#f5fdbd8588fe478c2b6c69ab6a421400" title="Same as getAtom(i).">operator[]</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> i) <span class="keyword">const</span>;
<a name="l00138"></a>00138 
<a name="l00140"></a><a class="code" href="classloos_1_1_atomic_group.html#4824921ec3b1ff150d90f693d21ea913">00140</a>     <span class="keywordtype">void</span> <a class="code" href="classloos_1_1_atomic_group.html#4824921ec3b1ff150d90f693d21ea913" title="Append the atom onto the group.">append</a>(pAtom pa) { atoms.push_back(pa); _sorted = <span class="keyword">false</span>; }
<a name="l00142"></a>00142     <span class="keywordtype">void</span> <a class="code" href="classloos_1_1_atomic_group.html#4824921ec3b1ff150d90f693d21ea913" title="Append the atom onto the group.">append</a>(std::vector&lt;pAtom&gt; pas);
<a name="l00144"></a>00144     <span class="keywordtype">void</span> <a class="code" href="classloos_1_1_atomic_group.html#4824921ec3b1ff150d90f693d21ea913" title="Append the atom onto the group.">append</a>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; grp);
<a name="l00145"></a>00145 
<a name="l00147"></a><a class="code" href="classloos_1_1_atomic_group.html#e3b4bca61047cb6efdac1309a16ac74e">00147</a>     <span class="keywordtype">void</span> <span class="keyword">remove</span>(pAtom pa) { deleteAtom(pa); }
<a name="l00149"></a>00149     <span class="keywordtype">void</span> <span class="keyword">remove</span>(std::vector&lt;pAtom&gt; pas);
<a name="l00151"></a>00151     <span class="keywordtype">void</span> <span class="keyword">remove</span>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; grp);
<a name="l00152"></a>00152 
<a name="l00153"></a>00153     <span class="comment">// Concatenation of groups and/or atoms</span>
<a name="l00154"></a>00154     <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; operator+=(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; rhs);
<a name="l00155"></a>00155     <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; operator+=(<span class="keyword">const</span> pAtom&amp; rhs);
<a name="l00156"></a>00156     <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> operator+(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; rhs);
<a name="l00157"></a>00157     <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> operator+(<span class="keyword">const</span> pAtom&amp; rhs);
<a name="l00158"></a>00158 
<a name="l00160"></a>00160 
<a name="l00164"></a>00164     <span class="keywordtype">bool</span> <a class="code" href="classloos_1_1_atomic_group.html#838252229a0bae82a0c6184c4a7638ba" title="Equality test for two groups.">operator==</a>(<a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; rhs);
<a name="l00165"></a>00165 
<a name="l00167"></a>00167 
<a name="l00170"></a>00170     <span class="keywordtype">bool</span> <a class="code" href="classloos_1_1_atomic_group.html#838252229a0bae82a0c6184c4a7638ba" title="Equality test for two groups.">operator==</a>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; rhs) <span class="keyword">const</span>;
<a name="l00171"></a>00171 
<a name="l00173"></a><a class="code" href="classloos_1_1_atomic_group.html#6ca357a30a685ab4394d9b055d557727">00173</a>     <span class="keywordtype">bool</span> <a class="code" href="classloos_1_1_atomic_group.html#6ca357a30a685ab4394d9b055d557727" title="Inequality test for two groups.">operator!=</a>(<a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; rhs) {
<a name="l00174"></a>00174       <span class="keywordflow">return</span>(!(<span class="keyword">operator</span>==(rhs)));
<a name="l00175"></a>00175     }
<a name="l00176"></a>00176 
<a name="l00178"></a><a class="code" href="classloos_1_1_atomic_group.html#d1eb6a409784584453b13d5e2c5c7b8c">00178</a>     <span class="keywordtype">bool</span> <a class="code" href="classloos_1_1_atomic_group.html#6ca357a30a685ab4394d9b055d557727" title="Inequality test for two groups.">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; rhs)<span class="keyword"> const </span>{
<a name="l00179"></a>00179       <span class="keywordflow">return</span>(!(<span class="keyword">operator</span>==(rhs)));
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181 
<a name="l00183"></a>00183 
<a name="l00187"></a>00187     <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> <a class="code" href="classloos_1_1_atomic_group.html#aabbe2dcc5ce2aa4f9a46873d0d5a7e8" title="subset() and excise() args are patterned after perl&amp;#39;s substr...">subset</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> offset, <span class="keyword">const</span> <span class="keywordtype">int</span> len = 0);
<a name="l00188"></a>00188 
<a name="l00190"></a>00190     <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> <a class="code" href="classloos_1_1_atomic_group.html#8f001aeb52990a0b0c992bde74053376" title="excise returns the excised atoms as a group...">excise</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> offset, <span class="keyword">const</span> <span class="keywordtype">int</span> len = 0);
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 
<a name="l00194"></a>00194 
<a name="l00217"></a><a class="code" href="classloos_1_1_atomic_group.html#57637ba35d28352a694286e78ec5eda4">00217</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> EqualsOp&gt; <span class="keywordtype">bool</span> <a class="code" href="classloos_1_1_atomic_group.html#57637ba35d28352a694286e78ec5eda4" title="Determines if a pAtom is contained in this group using the EqualsOp atom-equality...">contains</a>(<span class="keyword">const</span> pAtom&amp; p, <span class="keyword">const</span> EqualsOp&amp; op) {
<a name="l00218"></a>00218       const_iterator ci = std::find_if(begin(), end(), bind2nd(op, p));
<a name="l00219"></a>00219       <span class="keywordflow">return</span>(ci != end());
<a name="l00220"></a>00220     }
<a name="l00221"></a>00221     
<a name="l00223"></a><a class="code" href="classloos_1_1_atomic_group.html#9833d3ea345fc8d4d835bb485d485907">00223</a>     <span class="keywordtype">bool</span> <a class="code" href="classloos_1_1_atomic_group.html#57637ba35d28352a694286e78ec5eda4" title="Determines if a pAtom is contained in this group using the EqualsOp atom-equality...">contains</a>(<span class="keyword">const</span> pAtom&amp; p) { <span class="keywordflow">return</span>(<a class="code" href="classloos_1_1_atomic_group.html#57637ba35d28352a694286e78ec5eda4" title="Determines if a pAtom is contained in this group using the EqualsOp atom-equality...">contains</a>(p, <a class="code" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid.">AtomEquals</a>())); }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 
<a name="l00227"></a><a class="code" href="classloos_1_1_atomic_group.html#136c6216bd4a9b31d889a8dc566ca24c">00227</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> EqualsOp&gt; <span class="keywordtype">bool</span> <a class="code" href="classloos_1_1_atomic_group.html#57637ba35d28352a694286e78ec5eda4" title="Determines if a pAtom is contained in this group using the EqualsOp atom-equality...">contains</a>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; g, <span class="keyword">const</span> EqualsOp&amp; op) {
<a name="l00228"></a>00228       <span class="keywordflow">for</span> (const_iterator cj = g.<a class="code" href="classloos_1_1_atomic_group.html#bbd5a8cc5a6d1fe8f391b1782d008007">begin</a>(); cj != g.<a class="code" href="classloos_1_1_atomic_group.html#e6c0bb921cb2484cec7ad8054fa64e7c">end</a>(); ++cj)
<a name="l00229"></a>00229         <span class="keywordflow">if</span> (std::find_if(begin(), end(), bind2nd(op, *cj)) == end())
<a name="l00230"></a>00230           <span class="keywordflow">return</span>(<span class="keyword">false</span>);
<a name="l00231"></a>00231       <span class="keywordflow">return</span>(<span class="keyword">true</span>);
<a name="l00232"></a>00232     }
<a name="l00233"></a>00233     
<a name="l00235"></a><a class="code" href="classloos_1_1_atomic_group.html#7846d36da782272c95a8b0e5456870dd">00235</a>     <span class="keywordtype">bool</span> <a class="code" href="classloos_1_1_atomic_group.html#57637ba35d28352a694286e78ec5eda4" title="Determines if a pAtom is contained in this group using the EqualsOp atom-equality...">contains</a>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; g) { <span class="keywordflow">return</span>(<a class="code" href="classloos_1_1_atomic_group.html#57637ba35d28352a694286e78ec5eda4" title="Determines if a pAtom is contained in this group using the EqualsOp atom-equality...">contains</a>(g, <a class="code" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid.">AtomEquals</a>())); }
<a name="l00236"></a>00236     
<a name="l00238"></a>00238 
<a name="l00241"></a><a class="code" href="classloos_1_1_atomic_group.html#7bd3074704883e3ec92af624acbac57c">00241</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> EqualsOp&gt; <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> <a class="code" href="classloos_1_1_atomic_group.html#7bd3074704883e3ec92af624acbac57c" title="Computes the intersection of two groups using the EqualsOp atom-equality policy.">intersect</a>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; g, <span class="keyword">const</span> EqualsOp&amp; op) {
<a name="l00242"></a>00242       <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> result;
<a name="l00243"></a>00243 
<a name="l00244"></a>00244       <span class="keywordflow">for</span> (const_iterator cj = begin(); cj != end(); ++ cj)
<a name="l00245"></a>00245         <span class="keywordflow">if</span> (std::find_if(g.<a class="code" href="classloos_1_1_atomic_group.html#bbd5a8cc5a6d1fe8f391b1782d008007">begin</a>(), g.<a class="code" href="classloos_1_1_atomic_group.html#e6c0bb921cb2484cec7ad8054fa64e7c">end</a>(), bind2nd(op, *cj)) != g.<a class="code" href="classloos_1_1_atomic_group.html#e6c0bb921cb2484cec7ad8054fa64e7c">end</a>())
<a name="l00246"></a>00246           result.<a class="code" href="classloos_1_1_atomic_group.html#ee2a18b2d6a789914b19bea93c0983b7">addAtom</a>(*cj);
<a name="l00247"></a>00247 
<a name="l00248"></a>00248       result.<a class="code" href="classloos_1_1_atomic_group.html#0c72fd2dcd3fcdddd75c43d711c9ad41">box</a> = box;
<a name="l00249"></a>00249       <span class="keywordflow">return</span>(result);
<a name="l00250"></a>00250     }
<a name="l00251"></a>00251 
<a name="l00253"></a><a class="code" href="classloos_1_1_atomic_group.html#3314820bb1af318a9fbbc492a8c41d92">00253</a>     <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> <a class="code" href="classloos_1_1_atomic_group.html#7bd3074704883e3ec92af624acbac57c" title="Computes the intersection of two groups using the EqualsOp atom-equality policy.">intersect</a>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; g) { <span class="keywordflow">return</span>(<a class="code" href="classloos_1_1_atomic_group.html#7bd3074704883e3ec92af624acbac57c" title="Computes the intersection of two groups using the EqualsOp atom-equality policy.">intersect</a>(g, <a class="code" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid.">AtomEquals</a>())); }
<a name="l00254"></a>00254 
<a name="l00256"></a>00256 
<a name="l00259"></a><a class="code" href="classloos_1_1_atomic_group.html#d5991d15078aec34d80a13c62c421f16">00259</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> EqualsOp&gt; <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> <a class="code" href="classloos_1_1_atomic_group.html#d5991d15078aec34d80a13c62c421f16" title="Union of two groups using the specified atom-equality policy.">merge</a>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; g, <span class="keyword">const</span> EqualsOp&amp; op) {
<a name="l00260"></a>00260       <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> result = <a class="code" href="classloos_1_1_atomic_group.html#1126df7bc01ffad44a95537f5ce40248" title="Creates a deep copy of this group.">copy</a>();
<a name="l00261"></a>00261 
<a name="l00262"></a>00262       <span class="keywordflow">for</span> (const_iterator ci = g.<a class="code" href="classloos_1_1_atomic_group.html#bbd5a8cc5a6d1fe8f391b1782d008007">begin</a>(); ci != g.<a class="code" href="classloos_1_1_atomic_group.html#e6c0bb921cb2484cec7ad8054fa64e7c">end</a>(); ++ci)
<a name="l00263"></a>00263         <span class="keywordflow">if</span> (std::find_if(begin(), end(), bind2nd(op, *ci)) == end())
<a name="l00264"></a>00264           result.<a class="code" href="classloos_1_1_atomic_group.html#ee2a18b2d6a789914b19bea93c0983b7">addAtom</a>(*ci);
<a name="l00265"></a>00265 
<a name="l00266"></a>00266       <span class="keywordflow">return</span>(result);
<a name="l00267"></a>00267     }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 
<a name="l00271"></a><a class="code" href="classloos_1_1_atomic_group.html#5e4f5469c4c73f9fc1c3d1ade297a913">00271</a>     <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> <a class="code" href="classloos_1_1_atomic_group.html#d5991d15078aec34d80a13c62c421f16" title="Union of two groups using the specified atom-equality policy.">merge</a>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; g) { <span class="keywordflow">return</span>(<a class="code" href="classloos_1_1_atomic_group.html#d5991d15078aec34d80a13c62c421f16" title="Union of two groups using the specified atom-equality policy.">merge</a>(g, <a class="code" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid.">AtomEquals</a>())); }
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 
<a name="l00275"></a>00275     <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> <a class="code" href="classloos_1_1_atomic_group.html#e36b81018fa18e77483f5014ffe8749d" title="Return a group consisting of atoms for which sel predicate returns true...">select</a>(<span class="keyword">const</span> <a class="code" href="structloos_1_1_atom_selector.html" title="Virtual base-class for selecting atoms from a group.">AtomSelector</a>&amp; sel) <span class="keyword">const</span>;
<a name="l00276"></a>00276 
<a name="l00278"></a>00278     std::vector&lt;AtomicGroup&gt; <a class="code" href="classloos_1_1_atomic_group.html#18396f6467d8bfad2492e3a444799855" title="Returns a vector of AtomicGroups split from the current group based on segid.">splitByUniqueSegid</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00279"></a>00279 
<a name="l00281"></a>00281     std::vector&lt;AtomicGroup&gt; <a class="code" href="classloos_1_1_atomic_group.html#56508c28c9c4cf4c5c2bda430eb8ae1c" title="Returns a vector of AtomicGroups split based on bond connectivity.">splitByMolecule</a>(<span class="keywordtype">void</span>);
<a name="l00282"></a>00282 
<a name="l00284"></a>00284     std::vector&lt;AtomicGroup&gt; <a class="code" href="classloos_1_1_atomic_group.html#946c264e25c6a8decfdf1efd7d0586ee" title="Returns a vector of AtomicGroups, each comprising a single residue.">splitByResidue</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00285"></a>00285 
<a name="l00287"></a>00287     std::map&lt;std::string, AtomicGroup&gt; <a class="code" href="classloos_1_1_atomic_group.html#8edb32f41f97125016d6f70908263ce5" title="Returns a vector of AtomicGroups, each containing atoms with the same name.">splitByName</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00288"></a>00288 
<a name="l00290"></a>00290     pAtom <a class="code" href="classloos_1_1_atomic_group.html#d6803797fad086314686b0cac97133f6" title="Find a contained atom by its atomid.">findById</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>);
<a name="l00291"></a>00291 
<a name="l00293"></a>00293     <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> <a class="code" href="classloos_1_1_atomic_group.html#05781ab3d4c1af46f35b12a8193b8a24" title="Create a new group from a vector of atomids.">groupFromID</a>(<span class="keyword">const</span> std::vector&lt;int&gt; &amp;id_list);
<a name="l00294"></a>00294 
<a name="l00297"></a>00297     <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> <a class="code" href="classloos_1_1_atomic_group.html#0b5f36f01919f6b54fa410e956c02816">getResidue</a>(pAtom res);
<a name="l00298"></a>00298 
<a name="l00300"></a>00300     <span class="keyword">friend</span> std::ostream&amp; <a class="code" href="classloos_1_1_atomic_group.html#c63f9cf552c3640708fc6462d6a6ae9e" title="Output the group in pseudo-XML format...">operator&lt;&lt;</a>(std::ostream&amp; os, <span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; grp);
<a name="l00301"></a>00301   
<a name="l00302"></a>00302     <span class="comment">// Some misc support routines...</span>
<a name="l00303"></a>00303 
<a name="l00305"></a>00305     <span class="keywordtype">void</span> <a class="code" href="classloos_1_1_atomic_group.html#db954f4f8e8ea1d561e79d03c4fbf6f3" title="Renumber the atomid&amp;#39;s of the contained atoms...">renumber</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> start = 1, <span class="keyword">const</span> <span class="keywordtype">int</span> stride = 1);
<a name="l00306"></a>00306     <span class="keywordtype">int</span> minId(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00307"></a>00307     <span class="keywordtype">int</span> maxId(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00308"></a>00308     <span class="keywordtype">int</span> minResid(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00309"></a>00309     <span class="keywordtype">int</span> maxResid(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00310"></a>00310     <span class="keywordtype">int</span> numberOfResidues(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00311"></a>00311     <span class="keywordtype">int</span> numberOfSegids(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00312"></a>00312 
<a name="l00314"></a>00314     <span class="keywordtype">bool</span> <a class="code" href="classloos_1_1_atomic_group.html#3ce7750b4ed8ec8a85f75364df457121" title="True if all atoms in the group have the passed property(ies).">allHaveProperty</a>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atom.html#2a758660bf774fc372bd294a3fc92e53" title="Bits in the bitmask that flag what properties have actually been set.">Atom::bits</a>&amp; property) <span class="keyword">const</span>;
<a name="l00315"></a>00315     
<a name="l00317"></a>00317     <span class="keywordtype">bool</span> <a class="code" href="classloos_1_1_atomic_group.html#dad234910f41d8d2c77e6340f31e7a9f" title="True if any atom in the group have the passed property(ies).">anyHaveProperty</a>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atom.html#2a758660bf774fc372bd294a3fc92e53" title="Bits in the bitmask that flag what properties have actually been set.">Atom::bits</a>&amp; property) <span class="keyword">const</span>;
<a name="l00318"></a>00318 
<a name="l00319"></a>00319     <span class="comment">// These are now deprecated in favor of the above functions...</span>
<a name="l00321"></a>00321 <span class="comment"></span>    <span class="keywordtype">bool</span> <a class="code" href="classloos_1_1_atomic_group.html#3169d34e68659c6ac04c210006178f90" title="Does any atom in the group have bond information???">hasBonds</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00322"></a>00322 
<a name="l00324"></a>00324     <span class="keywordtype">bool</span> <a class="code" href="classloos_1_1_atomic_group.html#77b1aad02e4a862a781a0d0e3f5b719e" title="Does all the atoms in the group have coordinates?">hasCoords</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00325"></a>00325 
<a name="l00327"></a>00327     <span class="keywordtype">void</span> <a class="code" href="classloos_1_1_atomic_group.html#207734a7387d8aadd0ded48652ca12ea" title="Remove any bonding information present in contained atoms.">clearBonds</a>(<span class="keywordtype">void</span>);
<a name="l00328"></a>00328 
<a name="l00330"></a><a class="code" href="classloos_1_1_atomic_group.html#85c44a3c614264f47bfa0cde05ad3db5">00330</a>     <span class="keywordtype">bool</span> <a class="code" href="classloos_1_1_atomic_group.html#85c44a3c614264f47bfa0cde05ad3db5" title="Is the array of atoms already sorted???">sorted</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span>(_sorted); }
<a name="l00331"></a>00331 
<a name="l00333"></a>00333     <span class="keywordtype">void</span> <a class="code" href="classloos_1_1_atomic_group.html#e4df4c4e55665b8c6f8d09fc467fc35c" title="Sort based on atomid.">sort</a>(<span class="keywordtype">void</span>);
<a name="l00334"></a>00334 
<a name="l00336"></a><a class="code" href="classloos_1_1_atomic_group.html#8338a644424edb15159502ade2ce1c33">00336</a>     <span class="keywordtype">bool</span> <a class="code" href="classloos_1_1_atomic_group.html#8338a644424edb15159502ade2ce1c33" title="Test whether or not periodic boundary conditions are set.">isPeriodic</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span>(box.<a class="code" href="classloos_1_1_shared_periodic_box.html#c95f7ecab7bb5b57f8b523453fc6caea">isPeriodic</a>()); }
<a name="l00337"></a>00337   
<a name="l00339"></a><a class="code" href="classloos_1_1_atomic_group.html#be7df3660d00eb14a49e33f40b80878d">00339</a>     <a class="code" href="classloos_1_1_coord.html">GCoord</a> <a class="code" href="classloos_1_1_atomic_group.html#be7df3660d00eb14a49e33f40b80878d" title="Fetch the periodic boundary conditions.">periodicBox</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span>(box.<a class="code" href="classloos_1_1_shared_periodic_box.html#838d7b6127a90f08a14dd3a5d97fb524">box</a>()); }
<a name="l00340"></a>00340 
<a name="l00342"></a><a class="code" href="classloos_1_1_atomic_group.html#eb9eab6e6bae0c319d8534b0f0cc3215">00342</a>     <span class="keywordtype">void</span> <a class="code" href="classloos_1_1_atomic_group.html#be7df3660d00eb14a49e33f40b80878d" title="Fetch the periodic boundary conditions.">periodicBox</a>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_coord.html">GCoord</a>&amp; c) { box.<a class="code" href="classloos_1_1_shared_periodic_box.html#838d7b6127a90f08a14dd3a5d97fb524">box</a>(c); }
<a name="l00343"></a>00343 
<a name="l00345"></a><a class="code" href="classloos_1_1_atomic_group.html#94e9fc4b412353e46cd78a390494c221">00345</a>     <span class="keywordtype">void</span> <a class="code" href="classloos_1_1_atomic_group.html#be7df3660d00eb14a49e33f40b80878d" title="Fetch the periodic boundary conditions.">periodicBox</a>(<span class="keyword">const</span> greal x, <span class="keyword">const</span> greal y, <span class="keyword">const</span> greal z) { 
<a name="l00346"></a>00346       box.<a class="code" href="classloos_1_1_shared_periodic_box.html#838d7b6127a90f08a14dd3a5d97fb524">box</a>(<a class="code" href="classloos_1_1_coord.html">GCoord</a>(x,y,z));
<a name="l00347"></a>00347     }
<a name="l00348"></a>00348 
<a name="l00351"></a>00351     <span class="keywordtype">void</span> <a class="code" href="classloos_1_1_atomic_group.html#7d8d3c09032f4d4779681353f3b60446">reimage</a>();
<a name="l00352"></a>00352   
<a name="l00354"></a>00354     <span class="keywordtype">void</span> <a class="code" href="classloos_1_1_atomic_group.html#bf2a62540a7bceaecc4231cd8948ba6c" title="Reimage atoms individually into the primary cell.">reimageByAtom</a>();
<a name="l00355"></a>00355   
<a name="l00358"></a>00358     <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> <a class="code" href="classloos_1_1_atomic_group.html#06ba4d231abd348245603b7de1a8b278">within</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> dist, <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; grp);
<a name="l00359"></a>00359 
<a name="l00361"></a>00361 
<a name="l00382"></a>00382 
<a name="l00383"></a>00383 
<a name="l00388"></a>00388     <span class="comment">// Larger distances cause problems with hydrogens...</span>
<a name="l00389"></a>00389     <span class="keywordtype">void</span> <a class="code" href="classloos_1_1_atomic_group.html#72059293eedbb77609601602bd85a1e9" title="Apply a functor or a function to each atom in the group.">findBonds</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> dist = 1.65);
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 
<a name="l00392"></a>00392     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; T apply(T func) {
<a name="l00393"></a>00393       <span class="keywordflow">for</span> (iterator i = atoms.begin(); i != atoms.end(); ++i)
<a name="l00394"></a>00394         func(*i);
<a name="l00395"></a>00395       <span class="keywordflow">return</span>(func);
<a name="l00396"></a>00396     }
<a name="l00397"></a>00397 
<a name="l00398"></a>00398     <span class="comment">// *** Helper classes...</span>
<a name="l00399"></a>00399 
<a name="l00401"></a>00401 
<a name="l00417"></a><a class="code" href="classloos_1_1_atomic_group_1_1_iterator.html">00417</a>     <span class="keyword">class </span><a class="code" href="classloos_1_1_atomic_group_1_1_iterator.html" title="Our own simple iterator for stepping over all managed atoms.">Iterator</a> {
<a name="l00418"></a>00418     <span class="keyword">public</span>:
<a name="l00419"></a>00419       <span class="keyword">explicit</span> <a class="code" href="classloos_1_1_atomic_group_1_1_iterator.html" title="Our own simple iterator for stepping over all managed atoms.">Iterator</a>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; grp) : iter(grp.<a class="code" href="classloos_1_1_atomic_group.html#a568698d3ece67936eacda77df4c5f84">atoms</a>.begin()), <span class="keyword">final</span>(grp.<a class="code" href="classloos_1_1_atomic_group.html#a568698d3ece67936eacda77df4c5f84">atoms</a>.end()) { }
<a name="l00420"></a>00420       pAtom operator()(<span class="keywordtype">void</span>) {
<a name="l00421"></a>00421         <span class="keywordflow">if</span> (iter &gt;= <span class="keyword">final</span>)
<a name="l00422"></a>00422           <span class="keywordflow">return</span>(pAtom());
<a name="l00423"></a>00423         <span class="keywordflow">return</span>(*iter++);
<a name="l00424"></a>00424       }
<a name="l00425"></a>00425     <span class="keyword">private</span>:
<a name="l00426"></a>00426       std::vector&lt;pAtom&gt;::const_iterator iter, <span class="keyword">final</span>;
<a name="l00427"></a>00427     };
<a name="l00428"></a>00428 
<a name="l00429"></a>00429     <span class="comment">// STL-iterator access</span>
<a name="l00430"></a>00430     <span class="comment">// Should these reset sort status?</span>
<a name="l00431"></a>00431     iterator begin(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span>(atoms.begin()); }
<a name="l00432"></a>00432     const_iterator begin(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span>(atoms.begin()); }
<a name="l00433"></a>00433 
<a name="l00434"></a>00434     iterator end(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span>(atoms.end()); }
<a name="l00435"></a>00435     const_iterator end(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span>(atoms.end()); }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 
<a name="l00438"></a>00438     <span class="comment">// Statistical routines...</span>
<a name="l00440"></a>00440 <span class="comment"></span>    std::vector&lt;GCoord&gt; <a class="code" href="classloos_1_1_atomic_group.html#dd1d65a15ea4b388fa2953ca1b8debb1" title="Bounding box for the group...">boundingBox</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00441"></a>00441 
<a name="l00443"></a>00443 
<a name="l00446"></a>00446     GCoord <a class="code" href="classloos_1_1_atomic_group.html#429f96e9a94724ec68796f4c856f76b5" title="Translates the group so that the centroid is at the origin.">centerAtOrigin</a>(<span class="keywordtype">void</span>);
<a name="l00447"></a>00447 
<a name="l00449"></a>00449     GCoord <a class="code" href="classloos_1_1_atomic_group.html#d26667576771cba32914ee97113a3b7f" title="Centroid of atoms (ignores mass, operates in group coordinates).">centroid</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00450"></a>00450 
<a name="l00452"></a>00452     greal <a class="code" href="classloos_1_1_atomic_group.html#b021179ca4f8cba324d41815cf9340ce" title="Maximum radius from centroid of all atoms (not gyration).">radius</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00453"></a>00453 
<a name="l00455"></a>00455     GCoord <a class="code" href="classloos_1_1_atomic_group.html#366b5e348b26199400a46d0bdf55dcbe" title="Center of mass of the group (in group coordinates).">centerOfMass</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00456"></a>00456 
<a name="l00458"></a>00458     GCoord <a class="code" href="classloos_1_1_atomic_group.html#a0914f4528860eb7d729f702782fa3ae" title="Analogous to center of mass.">centerOfElectrons</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00459"></a>00459 
<a name="l00461"></a>00461     GCoord <a class="code" href="classloos_1_1_atomic_group.html#134a2fa951b17bd310854782622e1d5c" title="Dipole moment, relative to group&amp;#39;s centroid.">dipoleMoment</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00462"></a>00462     greal totalCharge(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00463"></a>00463     greal totalMass(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00464"></a>00464     greal radiusOfGyration(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00465"></a>00465 
<a name="l00467"></a>00467 
<a name="l00470"></a>00470     greal <a class="code" href="classloos_1_1_atomic_group.html#727648708aee3f4a3af63aa76cc9b73f" title="Compute the RMSD between two groups.">rmsd</a>(<span class="keyword">const</span> AtomicGroup&amp;);
<a name="l00471"></a>00471 
<a name="l00472"></a>00472     <span class="comment">// Geometric transformations...</span>
<a name="l00473"></a>00473   
<a name="l00475"></a>00475 
<a name="l00478"></a>00478     std::vector&lt;GCoord&gt; <a class="code" href="classloos_1_1_atomic_group.html#b786587c1ed62f04afa1d64781ad06cc" title="Returns a vector of coordinates transformed by the passed XForm.">getTransformedCoords</a>(<span class="keyword">const</span> XForm&amp;) <span class="keyword">const</span>;
<a name="l00479"></a>00479   
<a name="l00480"></a>00480     <span class="keywordtype">void</span> translate(<span class="keyword">const</span> GCoord &amp; v);
<a name="l00481"></a>00481 
<a name="l00483"></a>00483     <span class="keywordtype">void</span> <a class="code" href="classloos_1_1_atomic_group.html#52542da1e67eeb3a14fd8ecf2c7a8c87" title="Apply the given transform to the group&amp;#39;s coordinates...">applyTransform</a>(<span class="keyword">const</span> XForm&amp;);
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 
<a name="l00487"></a>00487 
<a name="l00491"></a><a class="code" href="classloos_1_1_atomic_group.html#1f23a69f5a9c008e970554bf2df5cfdc">00491</a>     <span class="keywordtype">void</span> <a class="code" href="classloos_1_1_atomic_group.html#1f23a69f5a9c008e970554bf2df5cfdc" title="Copy coordinates from one group into another...">copyCoordinates</a>(<a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp; g) {
<a name="l00492"></a>00492       iterator i, j;
<a name="l00493"></a>00493 
<a name="l00494"></a>00494       <span class="keywordflow">for</span> (i = atoms.begin(), j = g.<a class="code" href="classloos_1_1_atomic_group.html#a568698d3ece67936eacda77df4c5f84">atoms</a>.begin(); i != atoms.end(); i++, j++)
<a name="l00495"></a>00495         (*i)-&gt;coords((*j)-&gt;coords());
<a name="l00496"></a>00496     }
<a name="l00497"></a>00497 
<a name="l00499"></a>00499     <span class="keywordtype">void</span> <a class="code" href="classloos_1_1_atomic_group.html#fd02e8969d6e05ea36e5531014d72084" title="Each atom is moved in a random direction by a vector of the passed size.">perturbCoords</a>(<span class="keyword">const</span> greal);
<a name="l00500"></a>00500 
<a name="l00502"></a>00502 
<a name="l00527"></a>00527     std::vector&lt;GCoord&gt; <a class="code" href="classloos_1_1_atomic_group.html#b9ce39f2d7a53db0f5cc858db1b3607a" title="Compute the principal axes of a group.">principalAxes</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 
<a name="l00531"></a>00531 
<a name="l00537"></a>00537     std::vector&lt;GCoord&gt; <a class="code" href="classloos_1_1_atomic_group.html#0a0204deda6ace2293fe0675812f4f8d" title="Computes the moments of inertia for a group.">momentsOfInertia</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00538"></a>00538 
<a name="l00540"></a>00540 
<a name="l00545"></a>00545     <a class="code" href="classloos_1_1_matrix44.html" title="Specialized 4x4 Matrix class for handling coordinate transforms.">GMatrix</a> <a class="code" href="classloos_1_1_atomic_group.html#fc303bb0118c356d6878f75855742733" title="Calculates the transformation matrix for superposition of groups.">superposition</a>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp;);
<a name="l00546"></a>00546 
<a name="l00548"></a>00548 
<a name="l00553"></a>00553     <a class="code" href="classloos_1_1_matrix44.html" title="Specialized 4x4 Matrix class for handling coordinate transforms.">GMatrix</a> <a class="code" href="classloos_1_1_atomic_group.html#9d1966c971d7730391d417bcdfd1486e" title="Superimposes the current group onto the passed group.">alignOnto</a>(<span class="keyword">const</span> <a class="code" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>&amp;);
<a name="l00554"></a>00554 
<a name="l00555"></a>00555   <span class="keyword">private</span>:
<a name="l00556"></a>00556 
<a name="l00557"></a>00557     <span class="comment">// *** Internal routines ***  See the .cpp file for details...</span>
<a name="l00558"></a>00558     <span class="keywordtype">void</span> <a class="code" href="classloos_1_1_atomic_group.html#85c44a3c614264f47bfa0cde05ad3db5" title="Is the array of atoms already sorted???">sorted</a>(<span class="keywordtype">bool</span> b) { _sorted = b; }
<a name="l00559"></a>00559 
<a name="l00560"></a>00560     <span class="keywordtype">int</span> rangeCheck(<span class="keywordtype">int</span>) <span class="keyword">const</span>;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562     <span class="keywordtype">void</span> addAtom(pAtom pa) { atoms.push_back(pa); _sorted = <span class="keyword">false</span>; }
<a name="l00563"></a>00563     <span class="keywordtype">void</span> deleteAtom(pAtom pa);
<a name="l00564"></a>00564 
<a name="l00565"></a>00565     boost::tuple&lt;iterator, iterator&gt; calcSubsetIterators(<span class="keyword">const</span> <span class="keywordtype">int</span> offset, <span class="keyword">const</span> <span class="keywordtype">int</span> len = 0);
<a name="l00566"></a>00566 
<a name="l00567"></a>00567     <span class="keywordtype">void</span> copyCoordinatesById(AtomicGroup&amp; g);
<a name="l00568"></a>00568 
<a name="l00569"></a>00569     <span class="comment">// Some helper classes for using the STL</span>
<a name="l00570"></a>00570     <span class="keyword">struct </span>CmpById {
<a name="l00571"></a>00571       <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> pAtom&amp; a, <span class="keyword">const</span> pAtom&amp; b) {
<a name="l00572"></a>00572         <span class="keywordflow">return</span>(a-&gt;id() &lt; b-&gt;id());
<a name="l00573"></a>00573       }
<a name="l00574"></a>00574     };
<a name="l00575"></a>00575 
<a name="l00576"></a>00576     <span class="keyword">struct </span>BindId {
<a name="l00577"></a>00577       BindId(<span class="keyword">const</span> <span class="keywordtype">int</span> i) : id(i) { }
<a name="l00578"></a>00578       <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> pAtom&amp; a) { <span class="keywordflow">return</span>(a-&gt;id() == id); }
<a name="l00579"></a>00579       <span class="keywordtype">int</span> id;
<a name="l00580"></a>00580     };
<a name="l00581"></a>00581     
<a name="l00582"></a>00582     <span class="keyword">typedef</span> std::tr1::unordered_set&lt;int&gt; HashInt;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584     <span class="keywordtype">void</span> walkBonds(AtomicGroup&amp; mygroup, HashInt&amp; seen, pAtom moi);
<a name="l00585"></a>00585 
<a name="l00586"></a>00586 
<a name="l00587"></a>00587     <span class="keywordtype">double</span> *coordsAsArray(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00588"></a>00588     <span class="keywordtype">double</span> *transformedCoordsAsArray(<span class="keyword">const</span> XForm&amp;) <span class="keyword">const</span>;
<a name="l00589"></a>00589 
<a name="l00590"></a>00590     <span class="keywordtype">bool</span> _sorted;
<a name="l00591"></a>00591 
<a name="l00592"></a>00592   <span class="keyword">protected</span>:
<a name="l00593"></a>00593     std::vector&lt;pAtom&gt; atoms;
<a name="l00594"></a>00594     SharedPeriodicBox box;
<a name="l00595"></a>00595 
<a name="l00596"></a>00596   };
<a name="l00597"></a>00597 
<a name="l00598"></a>00598   AtomicGroup operator+(<span class="keyword">const</span> pAtom&amp; lhs, <span class="keyword">const</span> pAtom&amp; rhs);
<a name="l00599"></a>00599   AtomicGroup operator+(<span class="keyword">const</span> pAtom&amp; lhs, <span class="keyword">const</span> AtomicGroup&amp; rhs);
<a name="l00600"></a>00600 
<a name="l00601"></a>00601 
<a name="l00602"></a>00602 }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Apr 22 16:42:07 2010 for LOOS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
