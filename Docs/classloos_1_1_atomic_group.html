<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LOOS: loos::AtomicGroup Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceloos.html">loos</a>::<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>
  </div>
</div>
<div class="contents">
<h1>loos::AtomicGroup Class Reference</h1><!-- doxytag: class="loos::AtomicGroup" -->Class for handling groups of Atoms (pAtoms, actually).  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_atomic_group_8hpp-source.html">AtomicGroup.hpp</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for loos::AtomicGroup:</div>
<div class="dynsection">
<p><center><img src="classloos_1_1_atomic_group__inherit__graph.png" border="0" usemap="#loos_1_1_atomic_group__inherit__map" alt="Inheritance graph"></center>
<map name="loos_1_1_atomic_group__inherit__map">
<area shape="rect" href="classloos_1_1_amber.html" title="Class for reading in AMBER parmtop/coord files..." alt="" coords="5,88,99,123"><area shape="rect" href="classloos_1_1_gromacs.html" title="Implements a GROMACS model file (.gro)." alt="" coords="123,88,232,123"><area shape="rect" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class." alt="" coords="256,88,336,123"><area shape="rect" href="classloos_1_1_p_s_f.html" title="Class for reading a subset of the PSF format." alt="" coords="360,88,437,123"><area shape="rect" href="classloos_1_1_tinker_x_y_z.html" title="Class for reading a subset of the TinkerXYZ format." alt="" coords="461,88,584,123"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for loos::AtomicGroup:</div>
<div class="dynsection">
<p><center><img src="classloos_1_1_atomic_group__coll__graph.png" border="0" usemap="#loos_1_1_atomic_group__coll__map" alt="Collaboration graph"></center>
<map name="loos_1_1_atomic_group__coll__map">
<area shape="rect" href="classloos_1_1_shared_periodic_box.html" title="This class manages a shared Periodicbox." alt="" coords="5,5,173,40"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classloos_1_1_atomic_group-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f3cf1aeeacb960a6a45f91a8ec931659"></a><!-- doxytag: member="loos::AtomicGroup::iterator" ref="f3cf1aeeacb960a6a45f91a8ec931659" args="" -->
typedef std::vector&lt; pAtom &gt;<br>
::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6221d23a16953e033ce19749dc011c63"></a><!-- doxytag: member="loos::AtomicGroup::const_iterator" ref="6221d23a16953e033ce19749dc011c63" args="" -->
typedef std::vector&lt; pAtom &gt;<br>
::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#125a4b144bc5457366ae204e8f98f446">AtomicGroup</a> (const int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> with <em>n</em> un-initialized atoms.  <a href="#125a4b144bc5457366ae204e8f98f446"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#1126df7bc01ffad44a95537f5ce40248">copy</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a deep copy of this group.  <a href="#1126df7bc01ffad44a95537f5ce40248"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#02ca8a6697b307b2ef86362c17b1c402">clone</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a lightweight clone of this group (for polymorphism).  <a href="#02ca8a6697b307b2ef86362c17b1c402"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="916c47c9174e5f5b04500476127536e5"></a><!-- doxytag: member="loos::AtomicGroup::length" ref="916c47c9174e5f5b04500476127536e5" args="(void) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>length</b> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="abd5a070c2ae00c7bc7b02e21c48c241"></a><!-- doxytag: member="loos::AtomicGroup::size" ref="abd5a070c2ae00c7bc7b02e21c48c241" args="(void) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>size</b> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f7b98d8d1d88bb159216b073c0f72bb8"></a><!-- doxytag: member="loos::AtomicGroup::empty" ref="f7b98d8d1d88bb159216b073c0f72bb8" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>empty</b> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f86dc40255ba8e1af05c81737988e20b"></a><!-- doxytag: member="loos::AtomicGroup::getAtom" ref="f86dc40255ba8e1af05c81737988e20b" args="(const int i) const " -->
pAtom&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#f86dc40255ba8e1af05c81737988e20b">getAtom</a> (const int i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the ith atom from this group. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f5fdbd8588fe478c2b6c69ab6a421400"></a><!-- doxytag: member="loos::AtomicGroup::operator[]" ref="f5fdbd8588fe478c2b6c69ab6a421400" args="(const int i)" -->
pAtom &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#f5fdbd8588fe478c2b6c69ab6a421400">operator[]</a> (const int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as getAtom(i). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4bf6c5276a4ffc9eaa4e3f13ec212361"></a><!-- doxytag: member="loos::AtomicGroup::operator[]" ref="4bf6c5276a4ffc9eaa4e3f13ec212361" args="(const int i) const " -->
const pAtom &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const int i) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4824921ec3b1ff150d90f693d21ea913"></a><!-- doxytag: member="loos::AtomicGroup::append" ref="4824921ec3b1ff150d90f693d21ea913" args="(pAtom pa)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#4824921ec3b1ff150d90f693d21ea913">append</a> (pAtom pa)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append the atom onto the group. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="48cba37e5df1afac8493d6c45f58616c"></a><!-- doxytag: member="loos::AtomicGroup::append" ref="48cba37e5df1afac8493d6c45f58616c" args="(std::vector&lt; pAtom &gt; pas)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#48cba37e5df1afac8493d6c45f58616c">append</a> (std::vector&lt; pAtom &gt; pas)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a vector of atoms. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="47c5a2a5be73485df00b92a025669d24"></a><!-- doxytag: member="loos::AtomicGroup::append" ref="47c5a2a5be73485df00b92a025669d24" args="(const AtomicGroup &amp;grp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#47c5a2a5be73485df00b92a025669d24">append</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an entire <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> onto this one (concatenation). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e3b4bca61047cb6efdac1309a16ac74e"></a><!-- doxytag: member="loos::AtomicGroup::remove" ref="e3b4bca61047cb6efdac1309a16ac74e" args="(pAtom pa)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#e3b4bca61047cb6efdac1309a16ac74e">remove</a> (pAtom pa)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a single atom. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a54af251aa13f39212a11cf0efa254ca"></a><!-- doxytag: member="loos::AtomicGroup::remove" ref="a54af251aa13f39212a11cf0efa254ca" args="(std::vector&lt; pAtom &gt; pas)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a54af251aa13f39212a11cf0efa254ca">remove</a> (std::vector&lt; pAtom &gt; pas)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes a set of atoms. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4bcc59276616fbefcce6d54236a79d65"></a><!-- doxytag: member="loos::AtomicGroup::remove" ref="4bcc59276616fbefcce6d54236a79d65" args="(const AtomicGroup &amp;grp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#4bcc59276616fbefcce6d54236a79d65">remove</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes all atoms in the passed grp that are also in the current group. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f7f4f60bd3c46b587d5ecc3d481fc09c"></a><!-- doxytag: member="loos::AtomicGroup::operator+=" ref="f7f4f60bd3c46b587d5ecc3d481fc09c" args="(const AtomicGroup &amp;rhs)" -->
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0b11da8e2cdc6e8a5fa0d5b1f26d854e"></a><!-- doxytag: member="loos::AtomicGroup::operator+=" ref="0b11da8e2cdc6e8a5fa0d5b1f26d854e" args="(const pAtom &amp;rhs)" -->
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const pAtom &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e894af21108bb06b5f1cf1aaeecdb0c7"></a><!-- doxytag: member="loos::AtomicGroup::operator+" ref="e894af21108bb06b5f1cf1aaeecdb0c7" args="(const AtomicGroup &amp;rhs)" -->
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3213e4858ec14a9293f107215082fa99"></a><!-- doxytag: member="loos::AtomicGroup::operator+" ref="3213e4858ec14a9293f107215082fa99" args="(const pAtom &amp;rhs)" -->
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const pAtom &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#838252229a0bae82a0c6184c4a7638ba">operator==</a> (<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality test for two groups.  <a href="#838252229a0bae82a0c6184c4a7638ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#e0288588db8433e56c11899419ac8fa8">operator==</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality test for const groups.  <a href="#e0288588db8433e56c11899419ac8fa8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6ca357a30a685ab4394d9b055d557727"></a><!-- doxytag: member="loos::AtomicGroup::operator!=" ref="6ca357a30a685ab4394d9b055d557727" args="(AtomicGroup &amp;rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#6ca357a30a685ab4394d9b055d557727">operator!=</a> (<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality test for two groups. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d1eb6a409784584453b13d5e2c5c7b8c"></a><!-- doxytag: member="loos::AtomicGroup::operator!=" ref="d1eb6a409784584453b13d5e2c5c7b8c" args="(const AtomicGroup &amp;rhs) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#d1eb6a409784584453b13d5e2c5c7b8c">operator!=</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality test for two groups. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#aabbe2dcc5ce2aa4f9a46873d0d5a7e8">subset</a> (const int offset, const int len=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classloos_1_1_atomic_group.html#aabbe2dcc5ce2aa4f9a46873d0d5a7e8" title="subset() and excise() args are patterned after perl&#39;s substr...">subset()</a> and <a class="el" href="classloos_1_1_atomic_group.html#8f001aeb52990a0b0c992bde74053376" title="excise returns the excised atoms as a group...">excise()</a> args are patterned after perl's substr...  <a href="#aabbe2dcc5ce2aa4f9a46873d0d5a7e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8f001aeb52990a0b0c992bde74053376"></a><!-- doxytag: member="loos::AtomicGroup::excise" ref="8f001aeb52990a0b0c992bde74053376" args="(const int offset, const int len=0)" -->
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#8f001aeb52990a0b0c992bde74053376">excise</a> (const int offset, const int len=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">excise returns the excised atoms as a group... <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class EqualsOp&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#57637ba35d28352a694286e78ec5eda4">contains</a> (const pAtom &amp;p, const EqualsOp &amp;op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if a pAtom is contained in this group using the EqualsOp atom-equality policy.  <a href="#57637ba35d28352a694286e78ec5eda4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9833d3ea345fc8d4d835bb485d485907"></a><!-- doxytag: member="loos::AtomicGroup::contains" ref="9833d3ea345fc8d4d835bb485d485907" args="(const pAtom &amp;p)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#9833d3ea345fc8d4d835bb485d485907">contains</a> (const pAtom &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if a pAtom is contained in this group using the <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid.">AtomEquals</a> policy (ie the default comparison policy). <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="136c6216bd4a9b31d889a8dc566ca24c"></a><!-- doxytag: member="loos::AtomicGroup::contains" ref="136c6216bd4a9b31d889a8dc566ca24c" args="(const AtomicGroup &amp;g, const EqualsOp &amp;op)" -->
template&lt;class EqualsOp&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#136c6216bd4a9b31d889a8dc566ca24c">contains</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, const EqualsOp &amp;op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if the passed group is a subset of the current group using the EqualsOp atom-equality policy. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7846d36da782272c95a8b0e5456870dd"></a><!-- doxytag: member="loos::AtomicGroup::contains" ref="7846d36da782272c95a8b0e5456870dd" args="(const AtomicGroup &amp;g)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#7846d36da782272c95a8b0e5456870dd">contains</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if a group is a subset of the current group using the default <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid.">AtomEquals</a> policy. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class EqualsOp&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#7bd3074704883e3ec92af624acbac57c">intersect</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, const EqualsOp &amp;op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the intersection of two groups using the EqualsOp atom-equality policy.  <a href="#7bd3074704883e3ec92af624acbac57c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3314820bb1af318a9fbbc492a8c41d92"></a><!-- doxytag: member="loos::AtomicGroup::intersect" ref="3314820bb1af318a9fbbc492a8c41d92" args="(const AtomicGroup &amp;g)" -->
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#3314820bb1af318a9fbbc492a8c41d92">intersect</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of two groups. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class EqualsOp&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#d5991d15078aec34d80a13c62c421f16">merge</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, const EqualsOp &amp;op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Union of two groups using the specified atom-equality policy.  <a href="#d5991d15078aec34d80a13c62c421f16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5e4f5469c4c73f9fc1c3d1ade297a913"></a><!-- doxytag: member="loos::AtomicGroup::merge" ref="5e4f5469c4c73f9fc1c3d1ade297a913" args="(const AtomicGroup &amp;g)" -->
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#5e4f5469c4c73f9fc1c3d1ade297a913">merge</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Union of two groups using the default <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid.">AtomEquals</a> atom-equality policy. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e36b81018fa18e77483f5014ffe8749d"></a><!-- doxytag: member="loos::AtomicGroup::select" ref="e36b81018fa18e77483f5014ffe8749d" args="(const AtomSelector &amp;sel) const " -->
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#e36b81018fa18e77483f5014ffe8749d">select</a> (const <a class="el" href="structloos_1_1_atom_selector.html">AtomSelector</a> &amp;sel) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a group consisting of atoms for which sel predicate returns true... <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="18396f6467d8bfad2492e3a444799855"></a><!-- doxytag: member="loos::AtomicGroup::splitByUniqueSegid" ref="18396f6467d8bfad2492e3a444799855" args="(void) const " -->
std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#18396f6467d8bfad2492e3a444799855">splitByUniqueSegid</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a vector of AtomicGroups split from the current group based on segid. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#56508c28c9c4cf4c5c2bda430eb8ae1c">splitByMolecule</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a vector of AtomicGroups split based on bond connectivity.  <a href="#56508c28c9c4cf4c5c2bda430eb8ae1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#946c264e25c6a8decfdf1efd7d0586ee">splitByResidue</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a vector of AtomicGroups, each comprising a single residue.  <a href="#946c264e25c6a8decfdf1efd7d0586ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8edb32f41f97125016d6f70908263ce5"></a><!-- doxytag: member="loos::AtomicGroup::splitByName" ref="8edb32f41f97125016d6f70908263ce5" args="(void) const " -->
std::map&lt; std::string, <br>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#8edb32f41f97125016d6f70908263ce5">splitByName</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a vector of AtomicGroups, each containing atoms with the same name. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d6803797fad086314686b0cac97133f6"></a><!-- doxytag: member="loos::AtomicGroup::findById" ref="d6803797fad086314686b0cac97133f6" args="(const int id)" -->
pAtom&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#d6803797fad086314686b0cac97133f6">findById</a> (const int id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a contained atom by its atomid. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#05781ab3d4c1af46f35b12a8193b8a24">groupFromID</a> (const std::vector&lt; int &gt; &amp;id_list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new group from a vector of atomids.  <a href="#05781ab3d4c1af46f35b12a8193b8a24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#0b5f36f01919f6b54fa410e956c02816">getResidue</a> (pAtom res)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="db954f4f8e8ea1d561e79d03c4fbf6f3"></a><!-- doxytag: member="loos::AtomicGroup::renumber" ref="db954f4f8e8ea1d561e79d03c4fbf6f3" args="(const int start=1, const int stride=1)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#db954f4f8e8ea1d561e79d03c4fbf6f3">renumber</a> (const int start=1, const int stride=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renumber the atomid's of the contained atoms... <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ba5faf41086f89352626b0d8e93e00a0"></a><!-- doxytag: member="loos::AtomicGroup::minId" ref="ba5faf41086f89352626b0d8e93e00a0" args="(void) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>minId</b> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e73b7940caa47ed4b3834a8e9eacf4a3"></a><!-- doxytag: member="loos::AtomicGroup::maxId" ref="e73b7940caa47ed4b3834a8e9eacf4a3" args="(void) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>maxId</b> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="081b805047d02270094386c8564385a1"></a><!-- doxytag: member="loos::AtomicGroup::minResid" ref="081b805047d02270094386c8564385a1" args="(void) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>minResid</b> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="197b960527be80af05c269ac76315e68"></a><!-- doxytag: member="loos::AtomicGroup::maxResid" ref="197b960527be80af05c269ac76315e68" args="(void) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>maxResid</b> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="57be13b14440df21544468bc2764eac0"></a><!-- doxytag: member="loos::AtomicGroup::numberOfResidues" ref="57be13b14440df21544468bc2764eac0" args="(void) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>numberOfResidues</b> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d50ce1e25cecb4bf15a16f12ee705c57"></a><!-- doxytag: member="loos::AtomicGroup::numberOfSegids" ref="d50ce1e25cecb4bf15a16f12ee705c57" args="(void) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>numberOfSegids</b> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3ce7750b4ed8ec8a85f75364df457121"></a><!-- doxytag: member="loos::AtomicGroup::allHaveProperty" ref="3ce7750b4ed8ec8a85f75364df457121" args="(const Atom::bits &amp;property) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#3ce7750b4ed8ec8a85f75364df457121">allHaveProperty</a> (const <a class="el" href="classloos_1_1_atom.html#2a758660bf774fc372bd294a3fc92e53">Atom::bits</a> &amp;property) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if all atoms in the group have the passed property(ies). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dad234910f41d8d2c77e6340f31e7a9f"></a><!-- doxytag: member="loos::AtomicGroup::anyHaveProperty" ref="dad234910f41d8d2c77e6340f31e7a9f" args="(const Atom::bits &amp;property) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#dad234910f41d8d2c77e6340f31e7a9f">anyHaveProperty</a> (const <a class="el" href="classloos_1_1_atom.html#2a758660bf774fc372bd294a3fc92e53">Atom::bits</a> &amp;property) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if any atom in the group have the passed property(ies). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3169d34e68659c6ac04c210006178f90"></a><!-- doxytag: member="loos::AtomicGroup::hasBonds" ref="3169d34e68659c6ac04c210006178f90" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#3169d34e68659c6ac04c210006178f90">hasBonds</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does any atom in the group have bond information??? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="77b1aad02e4a862a781a0d0e3f5b719e"></a><!-- doxytag: member="loos::AtomicGroup::hasCoords" ref="77b1aad02e4a862a781a0d0e3f5b719e" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#77b1aad02e4a862a781a0d0e3f5b719e">hasCoords</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does all the atoms in the group have coordinates? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="207734a7387d8aadd0ded48652ca12ea"></a><!-- doxytag: member="loos::AtomicGroup::clearBonds" ref="207734a7387d8aadd0ded48652ca12ea" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#207734a7387d8aadd0ded48652ca12ea">clearBonds</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove any bonding information present in contained atoms. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="85c44a3c614264f47bfa0cde05ad3db5"></a><!-- doxytag: member="loos::AtomicGroup::sorted" ref="85c44a3c614264f47bfa0cde05ad3db5" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#85c44a3c614264f47bfa0cde05ad3db5">sorted</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is the array of atoms already sorted??? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e4df4c4e55665b8c6f8d09fc467fc35c"></a><!-- doxytag: member="loos::AtomicGroup::sort" ref="e4df4c4e55665b8c6f8d09fc467fc35c" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#e4df4c4e55665b8c6f8d09fc467fc35c">sort</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort based on atomid. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8338a644424edb15159502ade2ce1c33"></a><!-- doxytag: member="loos::AtomicGroup::isPeriodic" ref="8338a644424edb15159502ade2ce1c33" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#8338a644424edb15159502ade2ce1c33">isPeriodic</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether or not periodic boundary conditions are set. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="be7df3660d00eb14a49e33f40b80878d"></a><!-- doxytag: member="loos::AtomicGroup::periodicBox" ref="be7df3660d00eb14a49e33f40b80878d" args="(void) const " -->
<a class="el" href="classloos_1_1_coord.html">GCoord</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#be7df3660d00eb14a49e33f40b80878d">periodicBox</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the periodic boundary conditions. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eb9eab6e6bae0c319d8534b0f0cc3215"></a><!-- doxytag: member="loos::AtomicGroup::periodicBox" ref="eb9eab6e6bae0c319d8534b0f0cc3215" args="(const GCoord &amp;c)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#eb9eab6e6bae0c319d8534b0f0cc3215">periodicBox</a> (const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the periodic boundary conditions. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="94e9fc4b412353e46cd78a390494c221"></a><!-- doxytag: member="loos::AtomicGroup::periodicBox" ref="94e9fc4b412353e46cd78a390494c221" args="(const greal x, const greal y, const greal z)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#94e9fc4b412353e46cd78a390494c221">periodicBox</a> (const greal x, const greal y, const greal z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the periodic boundary conditions. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#7d8d3c09032f4d4779681353f3b60446">reimage</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bf2a62540a7bceaecc4231cd8948ba6c"></a><!-- doxytag: member="loos::AtomicGroup::reimageByAtom" ref="bf2a62540a7bceaecc4231cd8948ba6c" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#bf2a62540a7bceaecc4231cd8948ba6c">reimageByAtom</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reimage atoms individually into the primary cell. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#06ba4d231abd348245603b7de1a8b278">within</a> (const double dist, <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#72059293eedbb77609601602bd85a1e9">findBonds</a> (const double dist=1.65)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply a functor or a function to each atom in the group.  <a href="#72059293eedbb77609601602bd85a1e9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="328684bc9997a1e8e1dfcbc95239f582"></a><!-- doxytag: member="loos::AtomicGroup::apply" ref="328684bc9997a1e8e1dfcbc95239f582" args="(T func)" -->
template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>apply</b> (T func)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bbd5a8cc5a6d1fe8f391b1782d008007"></a><!-- doxytag: member="loos::AtomicGroup::begin" ref="bbd5a8cc5a6d1fe8f391b1782d008007" args="(void)" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9b52c54af3ee70f45771362691cd14f3"></a><!-- doxytag: member="loos::AtomicGroup::begin" ref="9b52c54af3ee70f45771362691cd14f3" args="(void) const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e6c0bb921cb2484cec7ad8054fa64e7c"></a><!-- doxytag: member="loos::AtomicGroup::end" ref="e6c0bb921cb2484cec7ad8054fa64e7c" args="(void)" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="10ce1b0595601eb08d18882ebde751e5"></a><!-- doxytag: member="loos::AtomicGroup::end" ref="10ce1b0595601eb08d18882ebde751e5" args="(void) const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dd1d65a15ea4b388fa2953ca1b8debb1"></a><!-- doxytag: member="loos::AtomicGroup::boundingBox" ref="dd1d65a15ea4b388fa2953ca1b8debb1" args="(void) const " -->
std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#dd1d65a15ea4b388fa2953ca1b8debb1">boundingBox</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bounding box for the group... <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_coord.html">GCoord</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#429f96e9a94724ec68796f4c856f76b5">centerAtOrigin</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translates the group so that the centroid is at the origin.  <a href="#429f96e9a94724ec68796f4c856f76b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d26667576771cba32914ee97113a3b7f"></a><!-- doxytag: member="loos::AtomicGroup::centroid" ref="d26667576771cba32914ee97113a3b7f" args="(void) const " -->
<a class="el" href="classloos_1_1_coord.html">GCoord</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#d26667576771cba32914ee97113a3b7f">centroid</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Centroid of atoms (ignores mass, operates in group coordinates). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b021179ca4f8cba324d41815cf9340ce"></a><!-- doxytag: member="loos::AtomicGroup::radius" ref="b021179ca4f8cba324d41815cf9340ce" args="(void) const " -->
greal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#b021179ca4f8cba324d41815cf9340ce">radius</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum radius from centroid of all atoms (not gyration). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="366b5e348b26199400a46d0bdf55dcbe"></a><!-- doxytag: member="loos::AtomicGroup::centerOfMass" ref="366b5e348b26199400a46d0bdf55dcbe" args="(void) const " -->
<a class="el" href="classloos_1_1_coord.html">GCoord</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#366b5e348b26199400a46d0bdf55dcbe">centerOfMass</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Center of mass of the group (in group coordinates). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0914f4528860eb7d729f702782fa3ae"></a><!-- doxytag: member="loos::AtomicGroup::centerOfElectrons" ref="a0914f4528860eb7d729f702782fa3ae" args="(void) const " -->
<a class="el" href="classloos_1_1_coord.html">GCoord</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a0914f4528860eb7d729f702782fa3ae">centerOfElectrons</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to center of mass. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="134a2fa951b17bd310854782622e1d5c"></a><!-- doxytag: member="loos::AtomicGroup::dipoleMoment" ref="134a2fa951b17bd310854782622e1d5c" args="(void) const " -->
<a class="el" href="classloos_1_1_coord.html">GCoord</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#134a2fa951b17bd310854782622e1d5c">dipoleMoment</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dipole moment, relative to group's centroid. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fee3d2984aca0ca7341766bd5d3a7d00"></a><!-- doxytag: member="loos::AtomicGroup::totalCharge" ref="fee3d2984aca0ca7341766bd5d3a7d00" args="(void) const " -->
greal&nbsp;</td><td class="memItemRight" valign="bottom"><b>totalCharge</b> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="59520b699fbba866352b818b7b5b9bd3"></a><!-- doxytag: member="loos::AtomicGroup::totalMass" ref="59520b699fbba866352b818b7b5b9bd3" args="(void) const " -->
greal&nbsp;</td><td class="memItemRight" valign="bottom"><b>totalMass</b> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e5911852e216c7059f46a620d8ce5a32"></a><!-- doxytag: member="loos::AtomicGroup::radiusOfGyration" ref="e5911852e216c7059f46a620d8ce5a32" args="(void) const " -->
greal&nbsp;</td><td class="memItemRight" valign="bottom"><b>radiusOfGyration</b> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">greal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#727648708aee3f4a3af63aa76cc9b73f">rmsd</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the RMSD between two groups.  <a href="#727648708aee3f4a3af63aa76cc9b73f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#b786587c1ed62f04afa1d64781ad06cc">getTransformedCoords</a> (const <a class="el" href="classloos_1_1_x_form.html">XForm</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a vector of coordinates transformed by the passed <a class="el" href="classloos_1_1_x_form.html" title="Matrix class for handling coordinate transforms...">XForm</a>.  <a href="#b786587c1ed62f04afa1d64781ad06cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="093499187c8cb7e4c919ce36e7b873ab"></a><!-- doxytag: member="loos::AtomicGroup::translate" ref="093499187c8cb7e4c919ce36e7b873ab" args="(const GCoord &amp;v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>translate</b> (const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="52542da1e67eeb3a14fd8ecf2c7a8c87"></a><!-- doxytag: member="loos::AtomicGroup::applyTransform" ref="52542da1e67eeb3a14fd8ecf2c7a8c87" args="(const XForm &amp;)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#52542da1e67eeb3a14fd8ecf2c7a8c87">applyTransform</a> (const <a class="el" href="classloos_1_1_x_form.html">XForm</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply the given transform to the group's coordinates... <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#1f23a69f5a9c008e970554bf2df5cfdc">copyCoordinates</a> (<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy coordinates from one group into another...  <a href="#1f23a69f5a9c008e970554bf2df5cfdc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fd02e8969d6e05ea36e5531014d72084"></a><!-- doxytag: member="loos::AtomicGroup::perturbCoords" ref="fd02e8969d6e05ea36e5531014d72084" args="(const greal)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#fd02e8969d6e05ea36e5531014d72084">perturbCoords</a> (const greal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Each atom is moved in a random direction by a vector of the passed size. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#b9ce39f2d7a53db0f5cc858db1b3607a">principalAxes</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the principal axes of a group.  <a href="#b9ce39f2d7a53db0f5cc858db1b3607a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#0a0204deda6ace2293fe0675812f4f8d">momentsOfInertia</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the moments of inertia for a group.  <a href="#0a0204deda6ace2293fe0675812f4f8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_matrix44.html">GMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#fc303bb0118c356d6878f75855742733">superposition</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the transformation matrix for superposition of groups.  <a href="#fc303bb0118c356d6878f75855742733"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classloos_1_1_matrix44.html">GMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#9d1966c971d7730391d417bcdfd1486e">alignOnto</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Superimposes the current group onto the passed group.  <a href="#9d1966c971d7730391d417bcdfd1486e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a568698d3ece67936eacda77df4c5f84"></a><!-- doxytag: member="loos::AtomicGroup::atoms" ref="a568698d3ece67936eacda77df4c5f84" args="" -->
std::vector&lt; pAtom &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>atoms</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c72fd2dcd3fcdddd75c43d711c9ad41"></a><!-- doxytag: member="loos::AtomicGroup::box" ref="0c72fd2dcd3fcdddd75c43d711c9ad41" args="" -->
<a class="el" href="classloos_1_1_shared_periodic_box.html">SharedPeriodicBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>box</b></td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c63f9cf552c3640708fc6462d6a6ae9e"></a><!-- doxytag: member="loos::AtomicGroup::operator&lt;&lt;" ref="c63f9cf552c3640708fc6462d6a6ae9e" args="(std::ostream &amp;os, const AtomicGroup &amp;grp)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#c63f9cf552c3640708fc6462d6a6ae9e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output the group in pseudo-XML format... <br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>BindId</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>CmpById</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group_1_1_iterator.html">Iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Our own simple iterator for stepping over all managed atoms.  <a href="classloos_1_1_atomic_group_1_1_iterator.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class for handling groups of Atoms (pAtoms, actually). 
<p>
This class contains a collection of shared pointers to Atoms (i.e. pAtoms). Copying an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> is a light-copy. You can, however, perform a deep copy by using the <a class="el" href="classloos_1_1_atomic_group.html#1126df7bc01ffad44a95537f5ce40248" title="Creates a deep copy of this group.">AtomicGroup::copy()</a> method. Note that atomid's are assumed to be unique for any given <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>.<p>
Valid operators are '+' and '+=' and can combine either <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> objects or pAtom objects.<p>
AtomicGroups also support periodic boundary conditions via the <a class="el" href="classloos_1_1_atomic_group.html#be7df3660d00eb14a49e33f40b80878d" title="Fetch the periodic boundary conditions.">periodicBox()</a> method. If a box has been set, then <a class="el" href="classloos_1_1_atomic_group.html#8338a644424edb15159502ade2ce1c33" title="Test whether or not periodic boundary conditions are set.">isPeriodic()</a> will return true. The periodic box is shared between the parent group and all derived groups. <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> copies have non-shared periodic boxes... 
<p>Definition at line <a class="el" href="_atomic_group_8hpp-source.html#l00087">87</a> of file <a class="el" href="_atomic_group_8hpp-source.html">AtomicGroup.hpp</a>.</p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="125a4b144bc5457366ae204e8f98f446"></a><!-- doxytag: member="loos::AtomicGroup::AtomicGroup" ref="125a4b144bc5457366ae204e8f98f446" args="(const int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">loos::AtomicGroup::AtomicGroup           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> with <em>n</em> un-initialized atoms. 
<p>
The atoms will all have ascending atomid's beginning with 1, but otherwise no other properties will be set. 
<p>Definition at line <a class="el" href="_atomic_group_8hpp-source.html#l00099">99</a> of file <a class="el" href="_atomic_group_8hpp-source.html">AtomicGroup.hpp</a>.</p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1126df7bc01ffad44a95537f5ce40248"></a><!-- doxytag: member="loos::AtomicGroup::copy" ref="1126df7bc01ffad44a95537f5ce40248" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::copy           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a deep copy of this group. 
<p>
This creates a non-polymorphic deep copy of an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a>. The additional catch is that it may end up involving extra data-movement as the copy is constructed and then copied back out to wherever you're putting it. 
<p>Reimplemented in <a class="el" href="classloos_1_1_amber.html#9e40574cf0386b975b4b8102b28a52c2">loos::Amber</a>, <a class="el" href="classloos_1_1_p_d_b.html#27fe1a6d71b0ee3632e59529ec280503">loos::PDB</a>, <a class="el" href="classloos_1_1_p_s_f.html#047b375a8f3cc6a566bdf90a00a25681">loos::PSF</a>, and <a class="el" href="classloos_1_1_tinker_x_y_z.html#7fccde4ee8f28db1c30368a1c374573a">loos::TinkerXYZ</a>.</p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp-source.html#l00043">43</a> of file <a class="el" href="_atomic_group_8cpp-source.html">AtomicGroup.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="02ca8a6697b307b2ef86362c17b1c402"></a><!-- doxytag: member="loos::AtomicGroup::clone" ref="02ca8a6697b307b2ef86362c17b1c402" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> * loos::AtomicGroup::clone           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a lightweight clone of this group (for polymorphism). 
<p>
Despite the name, this is meant for polymorphic use. It is <em>not</em> a deep copy. If you don't understand what any of this means, then you almost certainly want to be using the <a class="el" href="classloos_1_1_atomic_group.html#1126df7bc01ffad44a95537f5ce40248" title="Creates a deep copy of this group.">copy()</a> method instead. 
<p>Reimplemented in <a class="el" href="classloos_1_1_amber.html#bbed41ab7a29e2de2cdb95357a10affb">loos::Amber</a>, <a class="el" href="classloos_1_1_p_d_b.html#f3d225dd1d98480d16eaf4d5fc6f9db7">loos::PDB</a>, <a class="el" href="classloos_1_1_p_s_f.html#8e3af32c07a708706a2ef55351a616ac">loos::PSF</a>, and <a class="el" href="classloos_1_1_tinker_x_y_z.html#5f81294d0382b5f29782604f5e281f7f">loos::TinkerXYZ</a>.</p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp-source.html#l00038">38</a> of file <a class="el" href="_atomic_group_8cpp-source.html">AtomicGroup.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="838252229a0bae82a0c6184c4a7638ba"></a><!-- doxytag: member="loos::AtomicGroup::operator==" ref="838252229a0bae82a0c6184c4a7638ba" args="(AtomicGroup &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool loos::AtomicGroup::operator==           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality test for two groups. 
<p>
The test for equality is based on whether or not the contained atom pointers are the same. This operator will also force both sides of the equation to be sorted. 
<p>Definition at line <a class="el" href="_atomic_group_8cpp-source.html#l00659">659</a> of file <a class="el" href="_atomic_group_8cpp-source.html">AtomicGroup.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="e0288588db8433e56c11899419ac8fa8"></a><!-- doxytag: member="loos::AtomicGroup::operator==" ref="e0288588db8433e56c11899419ac8fa8" args="(const AtomicGroup &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool loos::AtomicGroup::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality test for const groups. 
<p>
Similar to the non-const version, but it will sort <em>copies</em> of the atom lists if they are not already sorted... 
<p>Definition at line <a class="el" href="_atomic_group_8cpp-source.html#l00679">679</a> of file <a class="el" href="_atomic_group_8cpp-source.html">AtomicGroup.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="aabbe2dcc5ce2aa4f9a46873d0d5a7e8"></a><!-- doxytag: member="loos::AtomicGroup::subset" ref="aabbe2dcc5ce2aa4f9a46873d0d5a7e8" args="(const int offset, const int len=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::subset           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>len</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classloos_1_1_atomic_group.html#aabbe2dcc5ce2aa4f9a46873d0d5a7e8" title="subset() and excise() args are patterned after perl&#39;s substr...">subset()</a> and <a class="el" href="classloos_1_1_atomic_group.html#8f001aeb52990a0b0c992bde74053376" title="excise returns the excised atoms as a group...">excise()</a> args are patterned after perl's substr... 
<p>
If offset is negative, then it's relative to the end of the group. If length is 0, then everything from offset to the appropriate end is used... 
<p>Definition at line <a class="el" href="_atomic_group_8cpp-source.html#l00252">252</a> of file <a class="el" href="_atomic_group_8cpp-source.html">AtomicGroup.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="57637ba35d28352a694286e78ec5eda4"></a><!-- doxytag: member="loos::AtomicGroup::contains" ref="57637ba35d28352a694286e78ec5eda4" args="(const pAtom &amp;p, const EqualsOp &amp;op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EqualsOp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool loos::AtomicGroup::contains           </td>
          <td>(</td>
          <td class="paramtype">const pAtom &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EqualsOp &amp;&nbsp;</td>
          <td class="paramname"> <em>op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if a pAtom is contained in this group using the EqualsOp atom-equality policy. 
<p>
The problem with determining containment/intersection/etc is how to define when two atoms are equal... This is done by specifying a comparison functor (the EqualsOp) as a policy. There are two comparison policies currently in LOOS: <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid.">AtomEquals</a> and <a class="el" href="structloos_1_1_atom_coords_equals.html" title="Compares two atoms based on name, id, resid, resname, segid, and coords.">AtomCoordsEquals</a>. The default behavior is to use <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid.">AtomEquals</a> which only compares a subset of the available <a class="el" href="classloos_1_1_atom.html" title="Basic Atom class for handling atom properties.">Atom</a> metadata. You can specify the more restrictive policy (or an user-defined policy) like: <div class="fragment"><pre class="fragment"> <span class="keywordtype">bool</span> b = group.contains(an_atom, <a class="code" href="structloos_1_1_atom_coords_equals.html" title="Compares two atoms based on name, id, resid, resname, segid, and coords.">loos::AtomCoordsEquals</a>());
</pre></div><p>
Or as another example, comparing only residue numbers... <div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>ResidEquals : <span class="keyword">public</span> std::binary_function&lt;pAtom, pAtom, bool&gt; {
   <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> pAtom&amp; a, <span class="keyword">const</span> pAtom&amp; b) { <span class="keywordflow">return</span>(a.resid() == b.resid()); }
 };

 <span class="keywordtype">bool</span> b = group.contains(an_atom, ResidEquals());
</pre></div> 
<p>Definition at line <a class="el" href="_atomic_group_8hpp-source.html#l00217">217</a> of file <a class="el" href="_atomic_group_8hpp-source.html">AtomicGroup.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="7bd3074704883e3ec92af624acbac57c"></a><!-- doxytag: member="loos::AtomicGroup::intersect" ref="7bd3074704883e3ec92af624acbac57c" args="(const AtomicGroup &amp;g, const EqualsOp &amp;op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EqualsOp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::intersect           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EqualsOp &amp;&nbsp;</td>
          <td class="paramname"> <em>op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the intersection of two groups using the EqualsOp atom-equality policy. 
<p>
See <a class="el" href="classloos_1_1_atomic_group.html#57637ba35d28352a694286e78ec5eda4" title="Determines if a pAtom is contained in this group using the EqualsOp atom-equality...">AtomicGroup::contains(const pAtom&amp;, const EqualsOp&amp;)</a> for more details 
<p>Definition at line <a class="el" href="_atomic_group_8hpp-source.html#l00241">241</a> of file <a class="el" href="_atomic_group_8hpp-source.html">AtomicGroup.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="d5991d15078aec34d80a13c62c421f16"></a><!-- doxytag: member="loos::AtomicGroup::merge" ref="d5991d15078aec34d80a13c62c421f16" args="(const AtomicGroup &amp;g, const EqualsOp &amp;op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EqualsOp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::merge           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EqualsOp &amp;&nbsp;</td>
          <td class="paramname"> <em>op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Union of two groups using the specified atom-equality policy. 
<p>
Note that the periodic box of the current group is unchanged by this operation 
<p>Definition at line <a class="el" href="_atomic_group_8hpp-source.html#l00259">259</a> of file <a class="el" href="_atomic_group_8hpp-source.html">AtomicGroup.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="56508c28c9c4cf4c5c2bda430eb8ae1c"></a><!-- doxytag: member="loos::AtomicGroup::splitByMolecule" ref="56508c28c9c4cf4c5c2bda430eb8ae1c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; loos::AtomicGroup::splitByMolecule           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a vector of AtomicGroups split based on bond connectivity. 
<p>
The idea is that we iterate over the list of contained atoms. For each atom, we recurse through the list of bonded atoms. Each time we visit an atom, we mark it as having been seen via the hash_set. In the recursive function, every time we find a new unseen atom, we append it to the current group and mark it as seen, then recurse through all of its bonded atoms.<p>
Since <a class="el" href="classloos_1_1_atomic_group.html#56508c28c9c4cf4c5c2bda430eb8ae1c" title="Returns a vector of AtomicGroups split based on bond connectivity.">splitByMolecule()</a> recurses through the connectivity list, the ordering of the atoms returned will not necessarily be the same as the input group. We therefore sort each group returned to hopefully maintain correct relative ordering.<p>
If we find a bond that goes to an atom that does not exist in the current group, a std::runtime_error is thrown. 
<p>Definition at line <a class="el" href="_atomic_group_8cpp-source.html#l00359">359</a> of file <a class="el" href="_atomic_group_8cpp-source.html">AtomicGroup.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="946c264e25c6a8decfdf1efd7d0586ee"></a><!-- doxytag: member="loos::AtomicGroup::splitByResidue" ref="946c264e25c6a8decfdf1efd7d0586ee" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; loos::AtomicGroup::splitByResidue           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a vector of AtomicGroups, each comprising a single residue. 
<p>
Splits an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> into individual residues. The residue boundary is marked by either a change in the resid or in the segid. 
<p>Definition at line <a class="el" href="_atomic_group_8cpp-source.html#l00432">432</a> of file <a class="el" href="_atomic_group_8cpp-source.html">AtomicGroup.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="05781ab3d4c1af46f35b12a8193b8a24"></a><!-- doxytag: member="loos::AtomicGroup::groupFromID" ref="05781ab3d4c1af46f35b12a8193b8a24" args="(const std::vector&lt; int &gt; &amp;id_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::groupFromID           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>id_list</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new group from a vector of atomids. 
<p>
Note: when calling this, you'll want to make sure you use the outermost group (eg the psf or pdb you used to create things, rather than using a subselection, unless you're sure the subsection contains these atoms as well. The main use of this routine is to create a group of atoms bound to another atom. 
<p>Definition at line <a class="el" href="_atomic_group_8cpp-source.html#l00482">482</a> of file <a class="el" href="_atomic_group_8cpp-source.html">AtomicGroup.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="0b5f36f01919f6b54fa410e956c02816"></a><!-- doxytag: member="loos::AtomicGroup::getResidue" ref="0b5f36f01919f6b54fa410e956c02816" args="(pAtom res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::getResidue           </td>
          <td>(</td>
          <td class="paramtype">pAtom&nbsp;</td>
          <td class="paramname"> <em>res</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given an <a class="el" href="classloos_1_1_atom.html" title="Basic Atom class for handling atom properties.">Atom</a>, return a group of all the atoms contained by its containing residue 
<p>Definition at line <a class="el" href="_atomic_group_8cpp-source.html#l00498">498</a> of file <a class="el" href="_atomic_group_8cpp-source.html">AtomicGroup.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="7d8d3c09032f4d4779681353f3b60446"></a><!-- doxytag: member="loos::AtomicGroup::reimage" ref="7d8d3c09032f4d4779681353f3b60446" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::reimage           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Translate the entire group so that the centroid is in the primary cell 
<p>Definition at line <a class="el" href="_atomic_group_8cpp-source.html#l00713">713</a> of file <a class="el" href="_atomic_group_8cpp-source.html">AtomicGroup.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="06ba4d231abd348245603b7de1a8b278"></a><!-- doxytag: member="loos::AtomicGroup::within" ref="06ba4d231abd348245603b7de1a8b278" args="(const double dist, AtomicGroup &amp;grp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::within           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>grp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find atoms in <em>grp</em> that are within <em>dist</em> angstroms of atoms in the current group.<p>
Uses a not-very-bright algorithm that compares all atoms against all atoms... 
<p>Definition at line <a class="el" href="_atomic_group_8cpp-source.html#l00741">741</a> of file <a class="el" href="_atomic_group_8cpp-source.html">AtomicGroup.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="72059293eedbb77609601602bd85a1e9"></a><!-- doxytag: member="loos::AtomicGroup::findBonds" ref="72059293eedbb77609601602bd85a1e9" args="(const double dist=1.65)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::findBonds           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>dist</em> = <code>1.65</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply a functor or a function to each atom in the group. 
<p>
apply() let's you apply a functor or a function pointer to each atom in the group. The functor is passed a pAtom. The functor object is also returned (in case it retained state). For example, the following code snippet shows how to calculate the centroid of a group using apply and a functor... <div class="fragment"><pre class="fragment">     <span class="keyword">struct </span>Functor {
     Functor() : C(GCoord(0,0,0)), n(0) { }
     <span class="keywordtype">void</span> operator()(pAtom&amp; p) { C += p-&gt;coords(); ++n; }
     GCoord center(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span>(C/n); }

     GCoord C;
     <span class="keywordtype">int</span> n;
     };

     Functor f = group.apply(Functor());
     GCoord <a class="code" href="classloos_1_1_atomic_group.html#d26667576771cba32914ee97113a3b7f" title="Centroid of atoms (ignores mass, operates in group coordinates).">centroid</a> = f.center();
</pre></div> Distance-based search for bonds Searches for bonds within an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually).">AtomicGroup</a> based on distance. does NOT clear the existing bond list prior to building new bonds. The default distance cutoff is 1.25 
<p>Definition at line <a class="el" href="_atomic_group_8cpp-source.html#l00784">784</a> of file <a class="el" href="_atomic_group_8cpp-source.html">AtomicGroup.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="429f96e9a94724ec68796f4c856f76b5"></a><!-- doxytag: member="loos::AtomicGroup::centerAtOrigin" ref="429f96e9a94724ec68796f4c856f76b5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_coord.html">GCoord</a> loos::AtomicGroup::centerAtOrigin           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Translates the group so that the centroid is at the origin. 
<p>
Returns the old centroid of the group 
<p>Definition at line <a class="el" href="_a_g__numerical_8cpp-source.html#l00273">273</a> of file <a class="el" href="_a_g__numerical_8cpp-source.html">AG_numerical.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="727648708aee3f4a3af63aa76cc9b73f"></a><!-- doxytag: member="loos::AtomicGroup::rmsd" ref="727648708aee3f4a3af63aa76cc9b73f" args="(const AtomicGroup &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">greal loos::AtomicGroup::rmsd           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the RMSD between two groups. 
<p>
Sorts both groups (if necessary), then assumes a 1:1 correspondence between ith atoms. 
<p>Definition at line <a class="el" href="_a_g__numerical_8cpp-source.html#l00180">180</a> of file <a class="el" href="_a_g__numerical_8cpp-source.html">AG_numerical.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="b786587c1ed62f04afa1d64781ad06cc"></a><!-- doxytag: member="loos::AtomicGroup::getTransformedCoords" ref="b786587c1ed62f04afa1d64781ad06cc" args="(const XForm &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; loos::AtomicGroup::getTransformedCoords           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_x_form.html">XForm</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a vector of coordinates transformed by the passed <a class="el" href="classloos_1_1_x_form.html" title="Matrix class for handling coordinate transforms...">XForm</a>. 
<p>
Does not alter the group's coordinates... 
<p>Definition at line <a class="el" href="_a_g__numerical_8cpp-source.html#l00201">201</a> of file <a class="el" href="_a_g__numerical_8cpp-source.html">AG_numerical.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="1f23a69f5a9c008e970554bf2df5cfdc"></a><!-- doxytag: member="loos::AtomicGroup::copyCoordinates" ref="1f23a69f5a9c008e970554bf2df5cfdc" args="(AtomicGroup &amp;g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::copyCoordinates           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy coordinates from one group into another... 
<p>
Requires that the groups be the same size and that the ith atom in group g matches the ith atom in the current group. 
<p>Definition at line <a class="el" href="_atomic_group_8hpp-source.html#l00491">491</a> of file <a class="el" href="_atomic_group_8hpp-source.html">AtomicGroup.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="b9ce39f2d7a53db0f5cc858db1b3607a"></a><!-- doxytag: member="loos::AtomicGroup::principalAxes" ref="b9ce39f2d7a53db0f5cc858db1b3607a" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; loos::AtomicGroup::principalAxes           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the principal axes of a group. 
<p>
Calculates the eigendecomposition of AA' where A is column-wise concatenation of coordinates from all atoms in the group. The mean coordinate is automatically subtracted from A... Returns a vector of GCoord's in order of decreasing magnitude of the corresponding eigenvalue. The eigenvalues are returned as a GCoord after the eigenvectors.<p>
Example <div class="fragment"><pre class="fragment">     vector&lt;GCoord&gt; V = group_of_atoms.principalAxes();
     GCoord eigenvalues = V[3];
     GCoord first_eigenvector = V[0];   <span class="comment">// Most significant</span>
     GCoord second_eigenvector = V[1];
     GCoord third_eigenvector = V[2];   <span class="comment">// Least significant</span>
</pre></div><p>
Notes<ul>
<li>Any errors encountered in the BLAS/LAPACK routines cause a runtime exception to be thrown...</li></ul>
<p>
<ul>
<li><a class="el" href="classloos_1_1_coord.html" title="Basic 3-D coordinates class.">Coord</a> type of contained atoms will always be upcast to double.</li></ul>
<p>
<ul>
<li>Potential issue with f77int under linux when not on a 64-bit architecture. </li></ul>

<p>Definition at line <a class="el" href="_a_g__linalg_8cpp-source.html#l00102">102</a> of file <a class="el" href="_a_g__linalg_8cpp-source.html">AG_linalg.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="0a0204deda6ace2293fe0675812f4f8d"></a><!-- doxytag: member="loos::AtomicGroup::momentsOfInertia" ref="0a0204deda6ace2293fe0675812f4f8d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; loos::AtomicGroup::momentsOfInertia           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the moments of inertia for a group. 
<p>
Calculates the principal moments and principal axes (from the moment of inertia). This is distinct from the <a class="el" href="classloos_1_1_atomic_group.html#b9ce39f2d7a53db0f5cc858db1b3607a" title="Compute the principal axes of a group.">principalAxes()</a> function which calculates the distribution of points about the centroid. 
<p>Definition at line <a class="el" href="_a_g__linalg_8cpp-source.html#l00046">46</a> of file <a class="el" href="_a_g__linalg_8cpp-source.html">AG_linalg.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="fc303bb0118c356d6878f75855742733"></a><!-- doxytag: member="loos::AtomicGroup::superposition" ref="fc303bb0118c356d6878f75855742733" args="(const AtomicGroup &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_matrix44.html">GMatrix</a> loos::AtomicGroup::superposition           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>grp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the transformation matrix for superposition of groups. 
<p>
Uses the Kabsch alignment method (via SVD) to calculate the transformation matrix that superimposes the current group onto the passed group. Returns the matrix. 
<p>Definition at line <a class="el" href="_a_g__linalg_8cpp-source.html#l00187">187</a> of file <a class="el" href="_a_g__linalg_8cpp-source.html">AG_linalg.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="9d1966c971d7730391d417bcdfd1486e"></a><!-- doxytag: member="loos::AtomicGroup::alignOnto" ref="9d1966c971d7730391d417bcdfd1486e" args="(const AtomicGroup &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_matrix44.html">GMatrix</a> loos::AtomicGroup::alignOnto           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>grp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Superimposes the current group onto the passed group. 
<p>
Calls superposition to calculate the transformation matrix to superimpose the current group onto the passed one, then applies the transformation to the current group's coordinates. 
<p>Definition at line <a class="el" href="_a_g__linalg_8cpp-source.html#l00277">277</a> of file <a class="el" href="_a_g__linalg_8cpp-source.html">AG_linalg.cpp</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_atomic_group_8hpp-source.html">AtomicGroup.hpp</a><li><a class="el" href="_a_g__linalg_8cpp-source.html">AG_linalg.cpp</a><li><a class="el" href="_a_g__numerical_8cpp-source.html">AG_numerical.cpp</a><li><a class="el" href="_atomic_group_8cpp-source.html">AtomicGroup.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Apr 22 16:42:12 2010 for LOOS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
