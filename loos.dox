/*!

\mainpage Lightweight Object-Oriented Structure library (LOOS)

\image html grossfield_logo.jpg

\image html gplv3.png

<hr>
\section copyright Copyright and License

<I>LOOS (Lightweight Object-Oriented Structure library)</I>\n
Copyright &copy; 2008, Tod D. Romo, Alan Grossfield\n
Department of Biochemistry and Biophysics\n
School of Medicine & Dentistry, University of Rochester\n

This package (LOOS) is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation under version 3 of the License.

This package is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

<hr>

\section Introduction

Welcome to the LOOS library,  a product of the Grossfield Lab at the University
of Rochester Medical School and the Department of Biochemistry and Biophysics.
The idea behind LOOS is to provide a lightweight C++ library for analysis of
molecular dynamics simulations.  This includes parsing a number of PDB
variants, PSF's, and DCD's.  LOOS is not intended to be an all-encompassing
library and it is primarily geared towards reading data in and processing
rather than manipulating the files and structures and writing them out.

LOOS operates mainly on groups of atoms, called an AtomicGroup.  The
atoms are stored as Boost shared pointers, so multiple groups can
contain the same atom without having to actually copy it.  This does
mean that you should be careful though when modifying an atom since
you may be affecting multiple groups in potentially unknown ways.

For assistance using LOOS, to suggest a patch, to request a feature, or simply
to offer positive feedback, email Tod Romo (tod_romo [AT] urmc.rochester.edu)
or Alan Grossfield (alan_grossfield [AT] urmc.rochester.edu).  

\section Features
One of the features of LOOS is the multiple ways it supports atom
selection.  AtomicGroup objects can create subsets of themselves by
using an AtomSelector (a predicate).  There are several useful ones
already pre-defined, such as CAlphaSelector and SolventSelector.
These can even be combined with logical operations.  The
SolventSelector is actually written this way.

Alternatively, LOOS supports selections created from user-input.  LOOS
can parse a selection string (in a format based on C expression
syntax) and use this for picking atoms.  For example, it's trivial to
write you tool so that a user can pick which atoms to consider at
run-time with a string like:
\verbatim
(resid >= 10 && resid <= 100) && (segid == "PROT" || segid == "HEME") && !(name =~ "H")
\endverbatim
which picks atoms with resid's between 10 and 100, a segid of either
"HEME" or "PROT", and all non-hydrogen atoms.  PERL-style regular
expressions are also supported using the "=~" operator.

More information is available here:
     \subpage selections "Selection Language"

\section Applications

Although LOOS is primarily intended as a platform for developing analysis
tools,it is distributed with a number of prebuilt applications, located in
the Tools/ directory.  These tools were developed for use in our research,
but they should be of general utility.  Moreover, they provide examples of
the intended use of the LOOS library, and will probably make helpful
templates for people looking to develop new tools.  

For more information, see the 
    \subpage tools "Tools page"


\section Bugs
There are none...only features.  So don't worry about them!
(email us directly if you find a bug^H^H^H unintended feature)

\section build Building and Installing
LOOS requires <A href="http://www.scons.org" target="_blank">SCons</A> to build.  It also
requires the vecLib framework and Developer's Tools for OS X or <A
href="http://math-atlas.sourceforge.net" target="_blank">Atlas</A> for Linux.  It also
requires the <A href="http://boost.org" target="_blank">Boost</A> libraries for both
(including the regular expression library).  To build from scratch, you will also need the
GNU utilities <A href="http://www.gnu.org/software/flex/">flex</A> and
<A href="http://www.gnu.org/software/bison/">bison</A>.

If your libraries are installed in non-standard locations, you may need to 
tell LOOS where its required components are.  To do this, do the following:
\verbatim
cp custom.py-proto custom.py
\endverbatim
Then edit your \c custom.py file to tell SCons and LOOS where your
libraries are.  You can temporarily override the defaults (and what's
set in your \c custom.py file by specifying the appropriate variables
on the command-line (run \c scons \c -h for more information)

To build just the library, cd to the top-level directory and run
SCons:
\verbatim
cd /path/to/LOOS
scons
\endverbatim

To build the library and tools as well, use:

\verbatim
scons all
\endverbatim

For more detailed information about the build process, see
\subpage building "Building LOOS"

To use LOOS, you will want to include the top-level LOOS directory in
both your include path and your library paths, so something like the
following for linux
\verbatim
g++ -o mytool mytool.cpp -I/Users/myself/LOOS -L/Users/myself/LOOS -lloos -lboost_regex -llapack -latlas
\endverbatim
or the following for OS X
\verbatim
g++ -framework vecLib -o mytool mytool.cpp -I/Users/myself/LOOS -L/Users/myself/LOOS -lloos -lboost_regex
\endverbatim


*/


/*! \page selections Selection Language

\section Language Description

The selection string parser is a relatively simpled parser patterned
after C/PERL expressions and includes support for PERL-style regular
expressions via Boost.  There are two kinds of literals supported:
strings and numbers.  Numbers are any valid integer.  Strings are
delimited by either single quotes or double quotes, so both of the
following are valid strings: 
\verbatim
"a string"
'another string'
\endverbatim

An important caveat to integer numbers is that LOOS assumes that none
will be negative.  In other words, no atomid nor resid nor number
extracted from a segid (see \ref magops_explained magical ops
below) will evaluate to a 
negative number.  The relational operators &lt; and &lt;= will behave
differently if either operand is a negative number.  In this case,
they will evaluate to false, for reasons that will become obvious when
you read about the magical operators below...

The parser also recognizes a small set of keywords that evaluate to
Atom properties.  These keywords fall into two types as well: those
that evaluate to a number (id, resid) and those that evaluate to a
string (name, resname, segname or segid).  Keep in mind that keywords
are not substitutions, but are more like a pre-defined function that
returns that atom property.  So you cannot put a keyword in a string
and expect it to be substituted with the appropriate value, for example.

\subsection relops Relational Operators
<table align="center">
<tr align="center"><th>Operator</th><th>Operation</th> <th>Strings</th><th>Numbers</th><th>Example</th></tr>
<tr align="center"><td>&gt;</td><td>Greater than</td><td>yes</td><td>yes</td><td>resid &gt; 10</td></td>
<tr align="center"><td>&gt;=</td><td>Greater than or equals</td><td>yes</td><td>yes</td><td>resid &gt;= 10</td></td>
<tr align="center"><td>&lt;=</td><td>Less than or equals</td><td>yes</td><td>yes</td><td>resid &lt;= 50</td></td>
<tr align="center"><td>&lt;</td><td>Less than</td><td>yes</td><td>yes</td><td>resid &lt; 50</td></td>
<tr align="center"><td>==</td><td>Exactly equals</td><td>yes</td><td>yes</td><td>name == "CA"</td></td>
<tr align="center"><td>!=</td><td>Doesn't equals exactly</td><td>yes</td><td>yes</td><td>segname != "SOLV"</td></td>
<tr align="center"><td>=~</td><td>Regular expression match</td><td>yes</td><td>no</td><td>name =~ "^(C[A]?|N|O)$"</td></td>
</table>

\subsection logops Logical Operators
<table align="center">
<tr align="center"><th>Operator</th><th>Operation</th><th>Example</th></tr>
<tr align="center"><td>&&</td><td>Logical And</td><td>name == "CA" && segid == "PROT"</td></tr>
<tr align="center"><td>||</td><td>Logical Or</td><td>segid == "SOLV" || segid == "BULK"</td></tr>
<tr align="center"><td>!</td><td>Not (Negate)</td><td>!(segid == "SOLV")</td></tr>
</table>


\subsection magops Magical Operators
<table align="center">
<tr align="center"><th>Operator</th><th>Operation</th><th>Example</th></tr>
<tr align="center"><td>-></td><td>Extracts a number from a string</td><td>segid -> "L(\d+)"</td></tr>
</table>


\subsection keywords Keywords
<table align="center">
<tr align="center"><th>Keyword</th><th>Atom Property</th><th>Evaluates to...</th><th>Operators</th></tr>
<tr align="center"><td>name</td><td>Atom name</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~</td></tr>
<tr align="center"><td>id</td><td>Atom ID</td><td>number</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=</td></tr>
<tr align="center"><td>resname</td><td>Residue name</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~</td></tr>
<tr align="center"><td>resid</td><td>Residue ID</td><td>number</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=</td></tr>
<tr align="center"><td>segid</td><td>Atom segid</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~</td></tr>
<tr align="center"><td>segname</td><td>Synonym for segid</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~</td></tr>
<tr align="center"><td>all</td><td>Evaluates to true</td><td>number</td><td></td></tr>
<tr align="center"><td>hydrogen</td><td>Evaluates to true if atom is a hydrogen</td><td>number</td><td></td></tr>
</table>

Notes:\n
The \c all keyword is used to force a selection string to match all
atoms in instances where a selection is required.  For example, a
program to align frames of a trajectory DCD to a reference structure
might require a selection to pick which atoms to use when computing
the rotations and then another selection to pick which atoms are
actually rotated.  If you wanted to apply the rotation to all atoms,
you just use the \c all keyword, i.e.
\verbatim
aligner --selection='name='CA' && segid =~ "BAR[12]"' --transform='all' foo.pdb foo.dcd newfoo
\endverbatim


\subsection regexps Regular Expression Matching
The regular expression matching operator "=~" deserves special
attention.  It's use is more restrictive than the other operators in
that it can only take a keyword that evaluates to a string on the
left-hand side and a string on the right-hand side.  So, the following
expressions are valid:
\verbatim
name =~ "CA"
name =~ "^(C|O|N)$"
segid =~ "PROT|HEME"
\endverbatim
While the following are not valid:
\verbatim
resid =~ "10[0-9][0-9]"
segid =~ 0010
name =~ resname
\endverbatim

The regular expression syntax supported is the PERL syntax as
implemented by the Boost libraries.  While you can write regular
expressions that look a lot like globbing (a la VMD selections), keep
in mind that it isn't globbing.  It's a regular expression, which is
more powerful anyway...  You do need to be careful though that your
shell does not munge any of the regex operators.  It's a good idea to
use single quotes when you're writing regex's in a shell.

The string equality operators ("==" and "!=") both consider the
<I>entire</I> string.
\verbatim
"CA" == "C"  --> false
 "C" == "C"  --> true
\endverbatim
You can use the "=~" operator to perform a substring match.
\verbatim
"CA" == "C"  --> false
 "C" == "C"  --> true
"CA" =~ "C"  --> true
\endverbatim
This brings up an important point about using regular expressions: be
careful of unexpected substring matches.  For example, let's say you
are wanting to pick out all backbone atoms and you write this
selection string:
\verbatim
name =~ "C|CA|O|N"
\endverbatim
Now look what happens when the following atom names are matched:
\verbatim
 "CG" --> true
"CD1" --> true
 "NE" --> true
"OH2" --> true
\endverbatim
The problem is that the regular expression is not constrained, so even
though you explicitly put "CA" and "CB" in there, you also have a "C"
which says <I>any</I> atom name with a "C" in it is a match.  If
you want to match a string <I>exactly</I> with a regular expression,
you must anchor it:
\verbatim
name =~ "^(C|CA|CB|O|N)$"
\endverbatim

\subsection magops_explained Magical Operations
There is currently only one "magical operator" defined: "->".  This
operator takes a string keyword on the left-hand side (i.e. name,
resname, or segid/segname) and a string on the right-hand side
representing a regular expression pattern.  It will then try to
extract a numeric value (integer) from the subexpression matches.  For
example, suppose you have a range of segments that all follow a
pattern such as "PG1", "PG2", "PG3", ..., "PG120".  The regular
expression "PG(\d+)" matches these and the pattern within the
parenthesis is a subexpression.  So,
\verbatim
(segid->"L(\d+)") >= 10 && (segid->"L(\d+)") <= 50
\endverbatim
will match segid's "L10" through "L50".  Since each matched
subexpression will be examined for a valid integer conversion, the
following will work as expected:
\verbatim
segid->"(L|PG)(\d+)"
\endverbatim

There is a small hitch with the magical operator.  If there is no
match, it evaluates to -1.  But this is a valid int, so you cannot do
the following:
\verbatim
segid->"L(\d+)" <= 100
\endverbatim
since it will match all segids.  You can't, unless the &lt;= operator
is also a little bit special.  Fortunately, it is.  If either operand
is a negative number, both the &lt; and &lt;= operands assume that
this is a flag for a null-match, and will result in a false value
being returned.  It's a bit of a kludge, but it works...

<hr>
\section kahuna Putting It All Together...
When you perform a selection on an AtomicGroup using the selection
language, the expression is evaluated once for each atom in the
group.  If it evaluates to "true" (integer 1), then the atom is added
to the new selection.  Only one atom is considered at a time.

Here are some example selections:
\verbatim
Extract C-alphas:
  name == "CA"

Solvent:
  segid == "SOLV" || segid == "BULK"

Solvent heavy atoms (oxygens only)
  name =~ "O" && (segid == "SOLV" || segid == "BULK")

C-alphas from a range of residues:
  name == "CA" && resid >= 10 && resid <= 50
\endverbatim

\subsection Usage
Most tools based on LOOS will accept selection strings from the
command-line.  They must be enclosed in quotes though so they are all
one argument to the tool.  If you're using regular expressions, it's a
good idea to use single quotes to prevent your shell from
misinterpreting the regular expression operators and as mentioned
before, back-slash escapes may need doubling.

You can store your selection in a file if you want.  To use it then,
use the back-quote feature of your shell to "cat" your selection
file.  Since your selection must be one argument, you must enclose the
back-quote within double-quotes, i.e.
\verbatim
  a_tool_name "`cat myselection.txt`" arg arg arg
\endverbatim

If you store your selection in a file, then you can also use
comments.  A comment is anything after a "#" on a line.  Here's an
example of a selection in a file:
\verbatim
### Select water oxygens only...
# Pick out any atom that contains an oxygen
name =~ "O" &&
(segid == "SOLV" || # any segment named SOLV
segid == "BULK")    # or named BULK
\endverbatim


*/



/*! \page building Building LOOS

\section Build Configuration

There are several build targets available:

<table align="center">
<tr align="left"><th>Target</th><th>Description</th></tr>
<tr align="left"><td>(default)</td><td>Just build the library</td></tr>
<tr align="left"><td>all</td><td>Builds the library plus tools</td></tr>
<tr align="left"><td>tests</td><td>Builds and runs the verification tests</td></tr>
<tr align="left"><td>docs</td><td>Uses Doxygen to generate new docs.</td></tr>
<tr align="left"><td>caboodle</td><td>Builds everything, including docs and tests</td></tr>
</table>

There are several different build options that are available for
LOOS.  These are handled on the command-line by SCons as "foo=1" to
turn the option on or "foo=0" to turn it off.  Most options default to
off.  Finally, you can query the available options by passing the "-h"
flag to SCons.  The following table lists the principal build options:

<table align="center">
<tr align="left"><th>Option</th><th>Default</th><th>Description</th></tr>
<tr align="left"><td>debug</td><td>0</td><td>Adds "-DDEBUG" to build</td></tr>
<tr align="left"><td>release</td><td>0</td><td>Turns on aggressive optimization (-O3)</td></tr>
<tr align="left"><td>regenerate</td><td>0</td><td>Regenerates the test verification data</td></tr>
<tr align="left"><td>reparse</td><td>0</td><td>Runs bison/flex to create the C++ files for parsing selections</td></tr>
</table>

\subsection Regeneration
The verification tests include sample output that is compared against
the current build.  If differences are found, they are flagged as
potential problems with the library.  If you update a test, change
systems (such as running on OS X as opposed to Linux), or perhaps
didn't get the test data from the SVN, then you will need to 
generate new test data and verify it manually.  To do so, use the
SCons command:
\verbatim
scons regenerate=1 tests
\endverbatim

\subsection Reparsing
To remove the dependency on Bison/Flex, the output from these tools
for the grammar and scanner are included.  If you want to rebuild
them, you will need to use the 'reparse=1' option.  The catch is that
if you have a different version of flex installed, there is a good
chance there will be a conflict with the bundled FlexLexer.h include
file.  If you see odd compiler errors, try removing that file and
rebuilding.  Alternatively, forcibly remove all generated files by
doing "rm *.cc *.hh" (assuming you've added no files with those
suffixes), then rebuild.

\subsection Distro Building a distribution
To build a distribution that doesn't require Doxygen and Bison/Flex,
the following is recommended:
\verbatim
scons regenerate=1 tests
scons docs
scons -c tests
\endverbatim

As a side-note, regenerating the verification data is potentially
hazardous if you have not been making sure your builds already pass,
so caveat bugger...

*/

/*! \page tools Summary of Tools

Below is a summary of the tools currently distributed with LOOS.  To get a
detailed summary of the command line arguments, run the program without
arguments or using "-h".  Many of the programs are simulation package
agnostic (meaning they'll work equally well with CHARMM/NAMD or Amber file
formats), but some still specifically assume CHARMM formats.  These are
mostly membrane-specific programs, which we felt are less likely to be used
with Amber formats. 

NOTE: At present, LOOS assumes that all periodic boxes are rectagular, and
will produce incorrect answers if trajectories using different box shapes
(eg truncated octahedron) are used in programs which make use of
periodicity (eg rdf).

\section aligner aligner

Align structures in a trajectory to a reference structure.

\section amber2dcd amber2dcd

Transform an Amber trajectory file into a CHARMM/NAMD dcd file.

\section amber2pdb amber2pdb

Tranform an Amber parmtop file into a pdb file.

\section atomic-rdf atomic-rdf

Compute the radial distribution function for 2 selections of atoms taken
from a trajectory, treating each selection as a set of individual atoms.
For contrast, see rdf.

\section averager averager

Compute the average structure for a set of molecules from a trajectory,
using an iterative scheme.

\section bounding bounding

Write out the bounding box for a selection of atoms from a pdb file.

\section center-pdb center-pdb

Read in a pdb file, shift its centroid to the origin, and write a new
pdb file to stdout.  Currently assumes PSF and DCD formats.

\section contacts contacts

Loop over a trajectory and count the number of contacts between two
sets of atoms.  Currently assumes PSF and DCD formats.

\section crossing-waters crossing-waters

Loop over a trajectory and compute the number waters crossing a membrane.
Currently assumes PSF and DCD formats.

\section dcdframe2pdb dcdframe2pdb

Extract a frame from a CHARMM/NAMD dcd trajectory file and write it as a pdb 
file.

\section density-dist density-dist

Compute the charge/electron/mass density distribution for the system along
the z-axis. Produces the distribution for the whole system and an arbitrary
number of selections.  Currently assumes PSF and DCD formats.

\section density-dist-windowed density-dist-windowed

Compute the charge/electron/mass density distribution for the system along
the z-axis for blocks of time within a trajectory, producing a density
distribution time series.  Currently assumes PSF and DCD formats.

\section octavex octavex

Extract embedded OCTAVE data from a LOOS output/log.

\section order_params order_params

Compute the deuterium quadrupolar splitting order parameters for lipid
molecules.  Currently assumes PSF and DCD formats.

\section pdb2matlab pdb2matlab

Takes a PDB and a selection and an optional selection and writes out the
coordinates to stdout in matlab format.

\section pdbselect pdbselect

Given a selection string and a pdb file, print out the selected atoms.
Very useful for testing and debugging complex selection strings.

\section rdf rdf

Loop over a trajectory file and compute the radial distribution function
for two selections.  The selections are split up by molecule and the center
of mass is used.  For example, selecting all water molecules will cause it
to compute the radial distribution of the centers of mass of individual
water molecules.  For contrast, see atomic-rdf.

\section rmsds rmsds

Loops over a trajectory and computes the pairwise RMSDs for a selection of
atoms.

\section svd svd

Performs principal component analysis for a trajectory using singular value
decomposition, writing out the eigenvalues, left singular vectors
(eigenvectors) and the right singular vectors (projection timeseries) as
OCTAVE-formatted text files. 

\section svdcolmap svdcolmap

Map the magnitude of a left singular vector onto a PDB file's B-value
column.  Useful for visualizing which portions of a molecule are mobile for
a given SVD mode.

\section xy_rdf xy_rdf

Compute a two dimension radial distribution function in the xy plane,
splitting the system into upper and lower leaflets.  Primarily intended for
analyzing lateral organization of lipid-water interfaces.  Currently assumes
PSF and DCD formats.

\section xy_rdf_timeseries xy_rdf_timeseries

Same as xy_rdf, except producing a series of block averages rather than
averaging over the whole trajectory.  

*/

