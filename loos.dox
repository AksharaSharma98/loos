/*!

\mainpage Lightweight Object-Oriented Structure library (LOOS)

\image html grossfield_logo.jpg

\image html gplv3.png

<hr>
\section copyright Copyright and License

<I>LOOS (Lightweight Object-Oriented Structure library)</I>\n
Copyright &copy; 2008, Tod D. Romo, Alan Grossfield\n
Department of Biochemistry and Biophysics\n
School of Medicine & Dentistry, University of Rochester\n

This package (LOOS) is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation under version 3 of the License.

This package is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

<hr>

\section Introduction

Welcome to the LOOS library,  a product of the Grossfield Lab at the University
of Rochester Medical School and the Department of Biochemistry and Biophysics.
The idea behind LOOS is to provide a lightweight C++ library for analysis of
molecular dynamics simulations.  This includes parsing a number of PDB
variants, as well as the native system description and trajectory formats for
CHARMM, NAMD, and Amber.  LOOS is not intended to be an all-encompassing
library and it is primarily geared towards reading data in and processing
rather than manipulating the files and structures and writing them out.

LOOS operates mainly on groups of atoms, called an AtomicGroup.  The
atoms are stored as Boost shared pointers, so multiple groups can
contain the same atom without having to actually copy it.  This does
mean that you should be careful though when modifying an atom since
you may be affecting multiple groups in potentially unknown ways.

For assistance using LOOS, to suggest a patch, to request a feature, or simply
to offer positive feedback, email LOOS-maintainer [AT] urmc.rochester.edu.  The
latest version of LOOS can be found at <A
HREF="http://loos.sourceforge.net">
http://loos.sourceforge.net</A>.

<B> Important information regarding the latest
changes are available here:</B>
	\subpage Changes "Change Log"

\section Features
One of the features of LOOS is the multiple ways it supports atom
selection.  AtomicGroup objects can create subsets of themselves by
using an AtomSelector (a predicate).  There are several useful ones
already pre-defined, such as CAlphaSelector and SolventSelector.
These can even be combined with logical operations.  The
SolventSelector is actually written this way.

Alternatively, LOOS supports selections created from user-input.  LOOS
can parse a selection string (in a format based on C expression
syntax) and use this for picking atoms.  For example, it's trivial to
write you tool so that a user can pick which atoms to consider at
run-time with a string like:
\verbatim
(resid >= 10 && resid <= 100) && (segid == "PROT" || segid == "HEME") && !(name =~ "H")
\endverbatim
which picks atoms with resid's between 10 and 100, a segid of either
"HEME" or "PROT", and all non-hydrogen atoms.  PERL-style regular
expressions are also supported using the "=~" operator.

More information is available here:
     \subpage selections "Selection Language"

\section Applications

Although LOOS is primarily intended as a platform for developing analysis
tools,it is distributed with a number of prebuilt applications, located in
the Tools/ directory.  These tools were developed for use in our research,
but they should be of general utility.  Moreover, they provide examples of
the intended use of the LOOS library, and will probably make helpful
templates for people looking to develop new tools.  

For more information, see the 
    \subpage tools "Tools page"


\section Bugs
There are none...only features.  So don't worry about them!
(email us directly if you find a bug^H^H^H unintended feature)

\section build Building and Installing
LOOS requires <A href="http://www.scons.org" target="_blank">SCons</A> to build.  It also
requires the vecLib framework and Developer's Tools for OS X or <A
href="http://math-atlas.sourceforge.net" target="_blank">Atlas</A> for Linux.  It also
requires the <A href="http://boost.org" target="_blank">Boost</A> libraries for both
(including the regular expression library).  To build from scratch, you will also need the
GNU utilities <A href="http://www.gnu.org/software/flex/">flex</A> and
<A href="http://www.gnu.org/software/bison/">bison</A>.

If your libraries are installed in non-standard locations, you may need to 
tell LOOS where its required components are.  To do this, do the following:
\verbatim
cp custom.py-proto custom.py
\endverbatim
Then edit your \c custom.py file to tell SCons and LOOS where your
libraries are.  \b NOTE:  If you're compiling under MacOS X, you will
almost certainly need to use a custom.py to correctly name your BOOST
libraries.  Look at the \c BOOSTREGEX and \c BOOSTPO variables for the
boost regular expression library and the program options library respectively.

You can temporarily override the defaults (and what's
set in your \c custom.py file by specifying the appropriate variables
on the command-line (run \c scons \c -h for more information)

To build just the library, cd to the top-level directory and run
SCons:
\verbatim
cd /path/to/LOOS
scons lib
\endverbatim

To build the library and tools as well, use:

\verbatim
scons
\endverbatim

For more detailed information about the build process, see
\subpage building "Building LOOS"

To use LOOS, you will want to include the top-level LOOS directory in
both your include path and your library paths, so something like the
following for linux
\verbatim
g++ -o mytool mytool.cpp -I/Users/myself/LOOS -L/Users/myself/LOOS -lloos -lboost_regex -llapack -latlas
\endverbatim
or the following for OS X
\verbatim
g++ -framework vecLib -o mytool mytool.cpp -I/Users/myself/LOOS -L/Users/myself/LOOS -lloos -lboost_regex
\endverbatim

Alternatively, look in the <I>Examples</I> directory for a simple
example program and prototypical SConstruct/SConscript files.  There
is also a Makefile in there if you'd rather not use SCons...

\section future Future Plans

<ul>
    <li> Support for other simulation packages (Tinker, Gromacs, etc)

    <li> Python bindings for easier scripting support
</ul>

*/


/*! \page selections Selection Language

\section Language Description

The selection string parser is a relatively simpled parser patterned
after C/PERL expressions and includes support for PERL-style regular
expressions via Boost.  There are two kinds of literals supported:
strings and numbers.  Numbers are any valid integer.  Strings are
delimited by either single quotes or double quotes, so both of the
following are valid strings: 
\verbatim
"a string"
'another string'
\endverbatim

An important caveat to integer numbers is that LOOS assumes that none
will be negative.  In other words, no atomid nor resid nor number
extracted from a segid (see \ref magops_explained magical ops
below) will evaluate to a 
negative number.  The relational operators &lt; and &lt;= will behave
differently if either operand is a negative number.  In this case,
they will evaluate to false, for reasons that will become obvious when
you read about the magical operators below...

The parser also recognizes a small set of keywords that evaluate to
Atom properties.  These keywords fall into two types as well: those
that evaluate to a number (id, resid) and those that evaluate to a
string (name, resname, segname or segid).  Keep in mind that keywords
are not substitutions, but are more like a pre-defined function that
returns that atom property.  So you cannot put a keyword in a string
and expect it to be substituted with the appropriate value, for example.

\subsection relops Relational Operators
<table align="center">
<tr align="center"><th>Operator</th><th>Operation</th> <th>Strings</th><th>Numbers</th><th>Example</th></tr>
<tr align="center"><td>&gt;</td><td>Greater than</td><td>yes</td><td>yes</td><td>resid &gt; 10</td></td>
<tr align="center"><td>&gt;=</td><td>Greater than or equals</td><td>yes</td><td>yes</td><td>resid &gt;= 10</td></td>
<tr align="center"><td>&lt;=</td><td>Less than or equals</td><td>yes</td><td>yes</td><td>resid &lt;= 50</td></td>
<tr align="center"><td>&lt;</td><td>Less than</td><td>yes</td><td>yes</td><td>resid &lt; 50</td></td>
<tr align="center"><td>==</td><td>Exactly equals</td><td>yes</td><td>yes</td><td>name == "CA"</td></td>
<tr align="center"><td>!=</td><td>Doesn't equals exactly</td><td>yes</td><td>yes</td><td>segname != "SOLV"</td></td>
<tr align="center"><td>=~</td><td>Regular expression match</td><td>yes</td><td>no</td><td>name =~ "^(C[A]?|N|O)$"</td></td>
</table>

\subsection logops Logical Operators
<table align="center">
<tr align="center"><th>Operator</th><th>Operation</th><th>Example</th></tr>
<tr align="center"><td>&&</td><td>Logical And</td><td>name == "CA" && segid == "PROT"</td></tr>
<tr align="center"><td>||</td><td>Logical Or</td><td>segid == "SOLV" || segid == "BULK"</td></tr>
<tr align="center"><td>!</td><td>Not (Negate)</td><td>!(segid == "SOLV")</td></tr>
</table>


\subsection magops Magical Operators
<table align="center">
<tr align="center"><th>Operator</th><th>Operation</th><th>Example</th></tr>
<tr align="center"><td>-></td><td>Extracts a number from a string</td><td>segid -> "L(\d+)"</td></tr>
</table>


\subsection keywords Keywords
<table align="center">
<tr align="center"><th>Keyword</th><th>Atom Property</th><th>Evaluates to...</th><th>Operators</th></tr>
<tr align="center"><td>name</td><td>Atom name</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~</td></tr>
<tr align="center"><td>id</td><td>Atom ID</td><td>number</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=</td></tr>
<tr align="center"><td>resname</td><td>Residue name</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~</td></tr>
<tr align="center"><td>resid</td><td>Residue ID</td><td>number</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=</td></tr>
<tr align="center"><td>segid</td><td>Atom segid</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~</td></tr>
<tr align="center"><td>segname</td><td>Synonym for segid</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~</td></tr>
<tr align="center"><td>all</td><td>Evaluates to true</td><td>number</td><td></td></tr>
<tr align="center"><td>hydrogen</td><td>Evaluates to true if atom is a hydrogen</td><td>number</td><td></td></tr>
</table>

Notes:\n
The \c all keyword is used to force a selection string to match all
atoms in instances where a selection is required.  For example, a
program to align frames of a trajectory DCD to a reference structure
might require a selection to pick which atoms to use when computing
the rotations and then another selection to pick which atoms are
actually rotated.  If you wanted to apply the rotation to all atoms,
you just use the \c all keyword, i.e.
\verbatim
aligner --selection='name='CA' && segid =~ "BAR[12]"' --transform='all' foo.pdb foo.dcd newfoo
\endverbatim


\subsection regexps Regular Expression Matching
The regular expression matching operator "=~" deserves special
attention.  It's use is more restrictive than the other operators in
that it can only take a keyword that evaluates to a string on the
left-hand side and a string on the right-hand side.  So, the following
expressions are valid:
\verbatim
name =~ "CA"
name =~ "^(C|O|N)$"
segid =~ "PROT|HEME"
\endverbatim
While the following are not valid:
\verbatim
resid =~ "10[0-9][0-9]"
segid =~ 0010
name =~ resname
\endverbatim

The regular expression syntax supported is the PERL syntax as
implemented by the Boost libraries.  While you can write regular
expressions that look a lot like globbing (a la VMD selections), keep
in mind that it isn't globbing.  It's a regular expression, which is
more powerful anyway...  You do need to be careful though that your
shell does not munge any of the regex operators.  It's a good idea to
use single quotes when you're writing regex's in a shell.

The string equality operators ("==" and "!=") both consider the
<I>entire</I> string.
\verbatim
"CA" == "C"  --> false
 "C" == "C"  --> true
\endverbatim
You can use the "=~" operator to perform a substring match.
\verbatim
"CA" == "C"  --> false
 "C" == "C"  --> true
"CA" =~ "C"  --> true
\endverbatim
This brings up an important point about using regular expressions: be
careful of unexpected substring matches.  For example, let's say you
are wanting to pick out all backbone atoms and you write this
selection string:
\verbatim
name =~ "C|CA|O|N"
\endverbatim
Now look what happens when the following atom names are matched:
\verbatim
 "CG" --> true
"CD1" --> true
 "NE" --> true
"OH2" --> true
\endverbatim
The problem is that the regular expression is not constrained, so even
though you explicitly put "CA" and "CB" in there, you also have a "C"
which says <I>any</I> atom name with a "C" in it is a match.  If
you want to match a string <I>exactly</I> with a regular expression,
you must anchor it:
\verbatim
name =~ "^(C|CA|CB|O|N)$"
\endverbatim

\subsection magops_explained Magical Operations
There is currently only one "magical operator" defined: "->".  This
operator takes a string keyword on the left-hand side (i.e. name,
resname, or segid/segname) and a string on the right-hand side
representing a regular expression pattern.  It will then try to
extract a numeric value (integer) from the subexpression matches.  For
example, suppose you have a range of segments that all follow a
pattern such as "PG1", "PG2", "PG3", ..., "PG120".  The regular
expression "PG(\d+)" matches these and the pattern within the
parenthesis is a subexpression.  So,
\verbatim
(segid->"L(\d+)") >= 10 && (segid->"L(\d+)") <= 50
\endverbatim
will match segid's "L10" through "L50".  Since each matched
subexpression will be examined for a valid integer conversion, the
following will work as expected:
\verbatim
segid->"(L|PG)(\d+)"
\endverbatim

There is a small hitch with the magical operator.  If there is no
match, it evaluates to -1.  But this is a valid int, so you cannot do
the following:
\verbatim
segid->"L(\d+)" <= 100
\endverbatim
since it will match all segids.  You can't, unless the &lt;= operator
is also a little bit special.  Fortunately, it is.  If either operand
is a negative number, both the &lt; and &lt;= operands assume that
this is a flag for a null-match, and will result in a false value
being returned.  It's a bit of a kludge, but it works...

<hr>
\section kahuna Putting It All Together...
When you perform a selection on an AtomicGroup using the selection
language, the expression is evaluated once for each atom in the
group.  If it evaluates to "true" (integer 1), then the atom is added
to the new selection.  Only one atom is considered at a time.

Here are some example selections:
\verbatim
Extract C-alphas:
  name == "CA"

Solvent:
  segid == "SOLV" || segid == "BULK"

Solvent heavy atoms (oxygens only)
  name =~ "O" && (segid == "SOLV" || segid == "BULK")

C-alphas from a range of residues:
  name == "CA" && resid >= 10 && resid <= 50
\endverbatim

\subsection Usage
Most tools based on LOOS will accept selection strings from the
command-line.  They must be enclosed in quotes though so they are all
one argument to the tool.  If you're using regular expressions, it's a
good idea to use single quotes to prevent your shell from
misinterpreting the regular expression operators and as mentioned
before, back-slash escapes may need doubling.

You can store your selection in a file if you want.  To use it then,
use the back-quote feature of your shell to "cat" your selection
file.  Since your selection must be one argument, you must enclose the
back-quote within double-quotes, i.e.
\verbatim
  a_tool_name "`cat myselection.txt`" arg arg arg
\endverbatim

If you store your selection in a file, then you can also use
comments.  A comment is anything after a "#" on a line.  Here's an
example of a selection in a file:
\verbatim
### Select water oxygens only...
# Pick out any atom that contains an oxygen
name =~ "O" &&
(segid == "SOLV" || # any segment named SOLV
segid == "BULK")    # or named BULK
\endverbatim


*/



/*! \page building Building LOOS

\section Build Configuration

There are several build targets available:

<table align="center">
<tr align="left"><th>Target</th><th>Description</th></tr>
<tr align="left"><td>(default)</td><td>Build the library and the tools</td></tr>
<tr align="left"><td>lib</td><td>Builds the library only</td></tr>
<tr align="left"><td>tests</td><td>Builds and runs the verification tests</td></tr>
<tr align="left"><td>docs</td><td>Uses Doxygen to generate new docs.</td></tr>
<tr align="left"><td>caboodle</td><td>Builds everything, including docs and tests</td></tr>
</table>

There are several different build options that are available for
LOOS.  These are handled on the command-line by SCons as "foo=1" to
turn the option on or "foo=0" to turn it off.  Most options default to
off.  Finally, you can query the available options by passing the "-h"
flag to SCons.  The following table lists the principal build options:

<table align="center">
<tr align="left"><th>Option</th><th>Default</th><th>Description</th></tr>
<tr align="left"><td>debug</td><td>0</td><td>Adds "-DDEBUG" to build</td></tr>
<tr align="left"><td>release</td><td>0</td><td>Turns on aggressive optimization (-O3)</td></tr>
<tr align="left"><td>regenerate</td><td>0</td><td>Regenerates the test verification data</td></tr>
<tr align="left"><td>reparse</td><td>0</td><td>Runs bison/flex to create the C++ files for parsing selections</td></tr>
</table>

\subsection Regeneration
The verification tests include sample output that is compared against
the current build.  If differences are found, they are flagged as
potential problems with the library.  If you update a test, change
systems (such as running on OS X as opposed to Linux), or perhaps
didn't get the test data from the SVN, then you will need to 
generate new test data and verify it manually.  To do so, use the
SCons command:
\verbatim
scons regenerate=1 tests
\endverbatim

\subsection Reparsing
To remove the dependency on Bison/Flex, the output from these tools
for the grammar and scanner are included.  If you want to rebuild
them, you will need to use the 'reparse=1' option.  The catch is that
if you have a different version of flex installed, there is a good
chance there will be a conflict with the bundled FlexLexer.h include
file.  If you see odd compiler errors, try removing that file and
rebuilding.  Alternatively, forcibly remove all generated files by
doing "rm *.cc *.hh" (assuming you've added no files with those
suffixes), then rebuild.

\subsection Distro Building a distribution
To build a distribution that doesn't require Doxygen and Bison/Flex,
the following is recommended:
\verbatim
scons regenerate=1 tests
scons docs
scons -c tests
\endverbatim

As a side-note, regenerating the verification data is potentially
hazardous if you have not been making sure your builds already pass,
so caveat bugger...

*/

/*! \page tools Summary of Tools

Below is a summary of the tools currently distributed with LOOS.  To get a
detailed summary of the command line arguments, run the program without
arguments or using "-h".  Many of the programs are simulation package
agnostic (meaning they'll work equally well with CHARMM/NAMD or Amber file
formats), but some still specifically assume CHARMM formats.  These are
mostly membrane-specific programs, which we felt are less likely to be used
with Amber formats. 

NOTE: At present, LOOS assumes that all periodic boxes are rectagular, and
will produce incorrect answers if trajectories using different box shapes
(eg truncated octahedron) are used in programs which make use of
periodicity (eg rdf).

\section aligner aligner

Align structures in a trajectory against the average using an
iterative refinement scheme.  Can read any LOOS trajectory format, but
will write the aligned trajectory as a DCD.

\section amber2dcd amber2dcd

Transform an Amber trajectory file into a CHARMM/NAMD dcd file.

\section amber2pdb amber2pdb

Tranform an Amber parmtop file into a pdb file.

\section atomic-rdf atomic-rdf

Compute the radial distribution function for 2 selections of atoms taken
from a trajectory, treating each selection as a set of individual atoms.
For contrast, see rdf.

\section averager averager

Compute the average structure for a set of molecules from a trajectory,
using an iterative scheme.

\section bounding bounding

Write out the bounding box for a selection of atoms from a pdb file.

\section center-pdb center-pdb

Read in a pdb file, shift its centroid to the origin, and write a new
pdb file to stdout.  Currently assumes PSF and DCD formats.

\section contacts contacts

Loop over a trajectory and count the number of contacts between two
sets of atoms.  Currently assumes PSF and DCD formats.

\section crossing-waters crossing-waters

Loop over a trajectory and compute the number waters crossing a membrane.
Currently assumes PSF and DCD formats.

\section dcdframe2pdb dcdframe2pdb

Extract a frame from a CHARMM/NAMD dcd trajectory file and write it as a pdb 
file.

\section density-dist density-dist

Compute the charge/electron/mass density distribution for the system along
the z-axis. Produces the distribution for the whole system and an arbitrary
number of selections.  Currently assumes PSF and DCD formats.

\section density-dist-windowed density-dist-windowed

Compute the charge/electron/mass density distribution for the system along
the z-axis for blocks of time within a trajectory, producing a density
distribution time series.  Currently assumes PSF and DCD formats.

\section octavex octavex

Extract embedded OCTAVE data from a LOOS output/log.

\section order_params order_params

Compute the deuterium quadrupolar splitting order parameters for lipid
molecules.  Currently assumes PSF and DCD formats.

\section pdb2matlab pdb2matlab

Takes a PDB and a selection and an optional selection and writes out the
coordinates to stdout in matlab format.

\section pdbselect pdbselect

Given a selection string and a pdb file, print out the selected atoms.
Very useful for testing and debugging complex selection strings.

\section rdf rdf

Loop over a trajectory file and compute the radial distribution function
for two selections.  The selections are split up by molecule and the center
of mass is used.  For example, selecting all water molecules will cause it
to compute the radial distribution of the centers of mass of individual
water molecules.  For contrast, see atomic-rdf.

\section rmsds rmsds

Loops over a trajectory and computes the pairwise RMSDs for a selection of
atoms.

\section svd svd

Performs principal component analysis for a trajectory using singular value
decomposition, writing out the eigenvalues, left singular vectors
(eigenvectors) and the right singular vectors (projection timeseries) as
OCTAVE-formatted text files. 

\section svdcolmap svdcolmap

Map the magnitude of a left singular vector onto a PDB file's B-value
column.  Useful for visualizing which portions of a molecule are mobile for
a given SVD mode.

\section xy_rdf xy_rdf

Compute a two dimension radial distribution function in the xy plane,
splitting the system into upper and lower leaflets.  Primarily intended for
analyzing lateral organization of lipid-water interfaces.  Currently assumes
PSF and DCD formats.

\section xy_rdf_timeseries xy_rdf_timeseries

Same as xy_rdf, except producing a series of block averages rather than
averaging over the whole trajectory.  

*/




/*! \page Changes Change Log
\section release130 Version 1.3.0 (12-18-2008)

\subsection r130_namespace Namespace Changes
This release represents some major changes to the internal structure
of LOOS.  First and foremost, virtually all of LOOS is now
encapsulated within the "loos" namespace whereas before much of loos
was in the global namespace.  This means that <tt>Atom a;</tt>
becomes <tt>loos::Atom a;</tt>.  Alternatively, you can place a using
directive at the top of your code,
\code
using namespace loos;

Atom a;
\endcode

LOOS also now respects your global namespace by not forcing the
importation of names that it uses, such as from the \c std namespace
or \c boost.  In fact, in versions prior to 1.3.0, LOOS would import
\c std into the global namespace.  If you were relying on this
behavior, you will now need to manually import in your code.  We
therefore recommend that you add the following to the start of all of
your code:
\code
using namespace std;
using namespace loos;
\endcode

Another \b major change in version 1.3.0 is the matrix handling code.
There is now a generic \c loos::Math::Matrix class that supports several different
ways of laying out the raw data (i.e. row major vs column major) and
can even support sparse storage.  This class in in the \c loos::Math
namespace.  It is important to note that the goal of this class is to
provide a controllable wrapper around a block of memory for
interfacing with ATLAS.  It is not meant to be a generic matrix in a
mathematical sense, despite being located in the \c loos::Math
namespace.  The polymorphic matrix I/O classes (i.e. \c MatrixReader and
\c MatrixWriter) are now gone, replaced by template functions \c
loos::writeAsciiMatrix() and \c loos::readAsciiMatrix().  The format used is just
a block of ASCII data that can be read in my Octave/MATLAB and
GnuPlot.  These reading and writing functions are in the \c loos
namespace, not the \c loos::Math namespace.  The reason for this is to
support the following pattern,
\code
using namespace std;
using namespace loos;

typedef Math::Matrix<double, Math::Triangular> Matrix;
...
Matrix M;
writeAsciiMatrix(filename, M, "My matrix");
\endcode

Additionally, math functions that were at a global scope, such as \c angle() and \c
torsion() are now in the \c loos::Math namespace.

\subsection r130_added_changed Added or Altered Functionality

<UL>
 <LI> When \c loos::createSystem() sees an Amber prmtop file, it will
 automatically look for a corresponding .inpcrd file and load the
 coordinates from that.  Otherwise, it returns an AtomicGroup sans
 coordinates.
 <LI> The ensemble functions (such as \c loos::averageStructure()) now
 take a \c loos::pTraj instead of a reference to a \c
 loos::Trajectory&.
 <LI> Many of the tools now use the boost program_options library
 <LI> The alignment tool (<tt>aligner</tt>) now writes out the average
 structure as well, and has an option to center the aligned
 trajectory.
 <LI> Added <tt>subsetter</tt> tool that pulls a subset of a model out
 of a trajectory into a new, smaller trajectory.
 <LI> The \c PDB reader now only emits warnings for each unique
 unknown record read rather than a whole mess of 'em...
</UL>

\subsection r130_bugs Bug Fixes
<UL>
 <LI> \c AtomicGroup::splitByMolecule() now handles groups without
 connectivity.
 <LI> Fixed a problem with the PDB reading code that mangled wide
 CONECT records.
</UL>



<hr>

\section release121 Version 1.2.1 (11-3-2008)
\subsection r121_bugs Bug Fixes
<UL>
 <LI> Fixed bug in crossing-waters tool
 <LI> Fixed bug in \c loos::Atom::clearPropertyBit() that caused it to
 not always toggle the correct bit.
</UL>


<hr>


\section release120 Version 1.2.0 (10-24-2008)
\subsection r120_changes Changes
<UL>
 <LI>Added <tt>helix_kink</tt> tool to determine bend-angles in
 helices.
 <LI> Added \c HeavySolventSelector
 <LI> Updated tools to use new convenience/factory functions, also
 making them a tad more universal in what inputs they can take.
 <LI> Added \c AtomicGroup::clearBonds() to remove connectivity in a
 group.
 <LI> \c PDB will out write out CONECT records when there are 10K
 atoms or greater, to prevent field overflow.
 <LI> \c Coord<T> can now extract itself from a stream.
 <LI> Added \c loos::selectAtoms() to parse a selection string and
 apply it to an \c AtomicGroup.
 <LI> Added support for writing out \c PDB CONECT records.

</UL>

\subsection r120_bugs Bug Fixes
<UL>
 <LI> Fixed problem with \c PDB output when there are more than 10K
 residues
 <LI> Fixed bug in \c DCDWriter that caused the output periodic
 box to be set to (1,1,1) regardless of what was passed in.
 <LI> Fixed problem when writing a \c PDB with bonds to missing
 atoms.  Bonds are now dereferenced prior to writing.  This means that
 the \c PDB is now no longer const when written and could be sorted.
 <LI> Fixed bug in width of CONECT record fields
 <LI> Fixed bug in \c DCD trajectories affecting seeking frames
 <LI> Fixed bug in \c DCD trajectories potentially affecting the
 number of frames sensed in a trajectory that comes from NAMD.
 <LI> Fixed bug in \c Atom::checkProperty() that caused
 erroneous results.
</UL>


<hr>

\section release110 Version 1.1.0 (9-12-2008)
\subsection r110_changes Changes
<UL>
 <LI> Major reorganization of the \c Trajectory class using a template
 pattern.
 <LI> Added \c CCPDB class for concatenated PDBs that you can treat as
 a \c Trajectory
 <LI> Added \c PDBTraj class for handling non-contiguous PDB
 trajectories
 <LI> Added \c TinkerArc class for TinkerArc (concatenated XYZ files)
 trajectories
 <LI> Changed \c Atom defaults to initialize atomid and resid to 1
 rather than -1
 <LI> Added tool to compute the RMSD between a selection and its
 average structure over the course of a trajectory
 <LI> Improved self-tests
 <LI> Added a new tool to reimage a trajectory by molecule
 <LI> Added \c AtomicGroup::apply() to call a functor or a function
 pointer on each \c Atom in an \c AtomicGroup.
 <LI> \c DCDWriter now long requires you to specify how many frames
 will be written--you can append and it will automatically update the
 header correctly.
</UL>


\subsection r110_bugs Bug Fixes
<UL>
 <LI> Fixed problem with typedefs in MacOS 10.5
 <LI> Fixed bug in \c ATom where setting coords using a \c GCoord ref
 not correctly setting the coords-bit.
 <LI> Fixed big in <tt>aligner</tt> where the first frame of the DCD
 was not transformed.
 <LI> Fixed bug in \c AtomicGroup::splitByMolecule() where the \c
 PeriodicBox was not propagated beyond the first group split.
 <LI> Fixed bug in <tt>svdcolmap</tt> tool that affected certain
 instances of using atomid maps.
 <LI> Fixed bug in \c loos::iterativeAlignment() where the returned \c
 XForms were incorrect.  The passed ensemble of \c AtomicGroup objects
 were correctly transformed, but anything that used the \c XForms were
 affected by varying degrees.
</UL>

*/
