/*!

\mainpage Lightweight Object-Oriented Structure library (LOOS)

\section Introduction

Welcome to the LOOS library.  The first product of the Grossfield Lab
at the University of Rochester Medical School and the Department of
Biochemistry.  The idea behind LOOS is to provide a lightweight C++
library for analysis of molecular dynamics simulations.  This includes
parsing a number of PDB variants, PSF's, and DCD's.  LOOS is not
intended to be an all-encompassing library and it is primarily geared
towards reading data in and processing rather than manipulating the
files and structures and writing them out.

LOOS operates mainly on groups of atoms, called an AtomicGroup.  The
atoms are stored as boost shared pointers, so multiple groups can
contain the same atom without having to actually copy it.  This does
mean that you should be careful though when modifying an atom since
you may be affecting multiple groups in potentially unknown ways.

\section Features
One of the features of LOOS is the multiple ways it supports atom
selection.  AtomicGroup objects can create subsets of themselves by
using an AtomSelector (a predicate).  There are several useful ones
already pre-defined, such as CAlphaSelector and SolventSelector.
These can even be combined with logical operations.  The
SolventSelector is actually written this way.

Alternatively, LOOS supports selections created from user-input.  LOOS
can parse a selection string (in a format based on C expression
syntax) and use this for picking atoms.  For example, it's trivial to
write you tool so that a user can pick which atoms to consider at
run-time with a string like:
\verbatim
(resid >= 10 && resid <= 100) && (segid == "PROT" || segid == "HEME") && !(name =~ "H")
\endverbatim
which picks atoms with resid's between 10 and 100, a segid of either
"HEME" or "PROT", and all non-hydrogen atoms.  PERL-style regular
expressions are also supported using the "=~" operator.

More information is available here:
     \subpage selections "Selection Language"


\section Bugs
There are none...only features.  So don't worry about them!
(email me directly for now)

\section build Building and Installing
LOOS requires <A href="http://www.scons.org" target="_blank">SCons</A> to build.  It also
requires the vecLib framework and Developer's Tools for OS X or <A
href="http://math-atlas.sourceforge.net" target="_blank">Atlas</A> for Linux.  It also
requires the <A href="http://boost.org" target="_blank">Boost</A> libraries for both
(including the regular expression library).  To build from scratch, you will also need the
GNU utilities <A href="http://www.gnu.org/software/flex/">flex</A> and
<A href="http://www.gnu.org/software/bison/">bison</A>.

To build just the library, cd to the top-level directory and run
SCons:
\verbatim
cd /Users/myself/LOOS
scons
\endverbatim

To build the examples and tools as well, use:

\verbatim
scons all
\endverbatim

For more detailed information about the build process, see
\subpage building "Building LOOS"

To use LOOS, you will want to include the top-level LOOS directory in
both your include path and your library paths, so something like the
following for linux
\verbatim
g++ -o mytool mytool.cpp -I/Users/myself/LOOS -L/Users/myself/LOOS -lloos -lboost_regex -llapack -latlas
\endverbatim
or the following for OS X
\verbatim
g++ -framework vecLib -o mytool mytool.cpp -I/Users/myself/LOOS -L/Users/myself/LOOS -lloos -lboost_regex
\endverbatim

*/


/*! \page selections Selection Language

\section Language Description

The selection string parser is a relatively simpled parser patterned
after C/PERL expressions and includes support for PERL-style regular
expressions via Boost.  There are two kinds of literals supported:
strings and numbers.  Numbers are any valid integer.  Strings are
delimited by either single quotes or double quotes, so both of the
following are valid strings: 
\verbatim
"a string"
'another string'
\endverbatim

The parser also recognizes a small set of keywords that evaluate to
Atom properties.  These keywords fall into two types as well: those
that evaluate to a number (id, resid) and those that evaluate to a
string (name, resname, segname or segid).  Keep in mind that keywords
are not substitutions, but are more like a pre-defined function that
returns that atom property.  So you cannot put a keyword in a string
and expect it to be substituted with the appropriate value, for example.

\subsection relops Relational Operators
<table align="center">
<tr align="center"><th>Operator</th><th>Operation</th> <th>Strings</th><th>Numbers</th><th>Example</th></tr>
<tr align="center"><td>&gt;</td><td>Greater than</td><td>yes</td><td>yes</td><td>resid &gt; 10</td></td>
<tr align="center"><td>&gt;=</td><td>Greater than or equals</td><td>yes</td><td>yes</td><td>resid &gt;= 10</td></td>
<tr align="center"><td>&lt;=</td><td>Less than or equals</td><td>yes</td><td>yes</td><td>resid &lt;= 50</td></td>
<tr align="center"><td>&lt;</td><td>Less than</td><td>yes</td><td>yes</td><td>resid &lt; 50</td></td>
<tr align="center"><td>==</td><td>Exactly equals</td><td>yes</td><td>yes</td><td>name == "CA"</td></td>
<tr align="center"><td>!=</td><td>Doesn't equals exactly</td><td>yes</td><td>yes</td><td>segname != "SOLV"</td></td>
<tr align="center"><td>=~</td><td>Regular expression match</td><td>yes</td><td>no</td><td>name =~ "^(C[A]?|N|O)$"</td></td>
</table>

\subsection logops Logical Operators
<table align="center">
<tr align="center"><th>Operator</th><th>Operation</th><th>Example</th></tr>
<tr align="center"><td>&&</td><td>Logical And</td><td>name == "CA" && segid == "PROT"</td></tr>
<tr align="center"><td>||</td><td>Logical Or</td><td>segid == "SOLV" || segid == "BULK"</td></tr>
<tr align="center"><td>!</td><td>Not (Negate)</td><td>!(segid == "SOLV")</td></tr>
</table>


\subsection magops Magical Operators
<table align="center">
<tr align="center"><th>Operator</th><th>Operation</th><th>Example</th></tr>
<tr align="center"><td>-></td><td>Extracts a number from a string</td><td>segid -> "L(\d+)"</td></tr>
</table>


\subsection keywords Keywords
<table align="center">
<tr align="center"><th>Keyword</th><th>Atom Property</th><th>Evaluates to...</th><th>Operators</th></tr>
<tr align="center"><td>name</td><td>Atom name</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~</td></tr>
<tr align="center"><td>id</td><td>Atom ID</td><td>number</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=</td></tr>
<tr align="center"><td>resname</td><td>Residue name</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~</td></tr>
<tr align="center"><td>resid</td><td>Residue ID</td><td>number</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=</td></tr>
<tr align="center"><td>segid</td><td>Atom segid</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~</td></tr>
<tr align="center"><td>segname</td><td>Synonym for segid</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~</td></tr>
</table>

\subsection regexps Regular Expression Matching
The regular expression matching operator "=~" deserves special
attention.  It's use is more restrictive than the other operators in
that it can only take a keyword that evaluates to a string on the
left-hand side and a string on the right-hand side.  So, the following
expressions are valid:
\verbatim
name =~ "CA"
name =~ "^(C|O|N)$"
segid =~ "PROT|HEME"
\endverbatim
While the following are not valid:
\verbatim
resid =~ "10[0-9][0-9]"
segid =~ 0010
name =~ resname
\endverbatim

The regular expression syntax supported is the PERL syntax as
implemented by the Boost libraries.  While you can write regular
expressions that look a lot like globbing (a la VMD selections), keep
in mind that it isn't globbing.  It's a regular expression, which is
more powerful anyway...  You do need to be careful though that your
shell does not munge any of the regex operators.  It's a good idea to
use single quotes when you're writing regex's in a shell.

The string equality operators ("==" and "!=") both consider the
<I>entire</I> string.
\verbatim
"CA" == "C"  --> false
 "C" == "C"  --> true
\endverbatim
You can use the "=~" operator to perform a substring match.
\verbatim
"CA" == "C"  --> false
 "C" == "C"  --> true
"CA" =~ "C"  --> true
\endverbatim
This brings up an important point about using regular expressions: be
careful of unexpected substring matches.  For examples, let's say you
are wanting to pick out all backbone atoms and you write this
selection string:
\verbatim
name =~ "C|CA|O|N"
\endverbatim
Now look what happens when the following atom names are matched:
\verbatim
 "CG" --> true
"CD1" --> true
 "NE" --> true
"OH2" --> true
\endverbatim
The problem is that the regular expression is not constrained, so even
though you explicitly put "CA" and "CB" in there, you also have a "C"
which says <I>any</I> atom name with a "C" in it is a match.  If
you want to match a string <I>exactly</I> with a regular expression,
you must anchor it:
\verbatim
name =~ "^(C|CA|CB|O|N)$"
\endverbatim

\subsection magops_explained Magical Operations
There is currently only one "magical operator" defined: "->".  This
operator takes a string keyword on the left-hand side (i.e. name,
resname, or segid/segname) and a string on the right-hand side
representing a regular expression pattern.  It will then try to
extract a numeric value (integer) from the subexpression matches.  For
example, suppose you have a range of segments that all follow a
pattern such as "PG1", "PG2", "PG3", ..., "PG120".  The regular
expression "PG(\d+)" matches these and the pattern within the
parenthesis is a subexpression.  So,
\verbatim
(segid->"L(\d+)") >= 10 && (segid->"L(\d+)") <= 50
\endverbatim
will match segid's "L10" through "L50".  Since each matched
subexpression will be examined for a valid integer conversion, the
following will work as expected:
\verbatim
segid->"(L|PG)(\d+)"
\endverbatim

<hr>
\section kahuna Putting It All Together...
When you perform a selection on an AtomicGroup using the selection
language, the expression is evaluated once for each atom in the
group.  If it evaluates to "true" (integer 1), then the atom is added
to the new selection.  Only one atom is considered at a time.

Here are some example selections:
\verbatim
Extract C-alphas:
  name == "CA"

Solvent:
  segid == "SOLV" || segid == "BULK"

Solvent heavy atoms (oxygens only)
  name =~ "O" && (segid == "SOLV" || segid == "BULK")

C-alphas from a range of residues:
  name == "CA" && resid >= 10 && resid <= 50
\endverbatim

\subsection Usage
Most tools based on LOOS will accept selection strings from the
command-line.  They must be enclosed in quotes though so they are all
one argument to the tool.  If you're using regular expressions, it's a
good idea to use single quotes to prevent your shell from
misinterpreting the regular expression operators and as mentioned
before, back-slash escapes may need doubling.

You can store your selection in a file if you want.  To use it then,
use the back-quote feature of your shell to "cat" your selection
file.  Since your selection must be one argument, you must enclose the
back-quote within double-quotes, i.e.
\verbatim
  a_tool_name "`cat myselection.txt`" arg arg arg
\endverbatim

If you store your selection in a file, then you can also use
comments.  A comment is anything after a "#" on a line.  Here's an
example of a selection in a file:
\verbatim
### Select water oxygens only...
# Pick out any atom that contains an oxygen
name =~ "O" &&
(segid == "SOLV" || # any segment named SOLV
segid == "BULK")    # or named BULK
\endverbatim


*/



/*! \page building Building LOOS

\section Build Configuration

There are several build targets available:

<table align="center">
<tr align="left"><th>Target</th><th>Description</th></tr>
<tr align="left"><td>(default)</td><td>Just build the library</td></tr>
<tr align="left"><td>all</td><td>Builds the library plus examples and tools</td></tr>
<tr align="left"><td>tests</td><td>Builds and runs the verification tests</td></tr>
<tr align="left"><td>docs</td><td>Uses Doxygen to generate new docs.</td></tr>
<tr align="left"><td>caboodle</td><td>Builds everything, including docs and tests</td></tr>
</table>

There are several different build options that are available for
LOOS.  These are handled on the command-line by SCons as "foo=1" to
turn the option on or "foo=0" to turn it off.  Most options default to
off.  Finally, you can query the available options by passing the "-h"
flag to SCons.  The following table lists the principal build options:

<table align="center">
<tr align="left"><th>Option</th><th>Default</th><th>Description</th></tr>
<tr align="left"><td>debug</td><td>0</td><td>Adds "-DDEBUG" to build</td></tr>
<tr align="left"><td>release</td><td>0</td><td>Turns on aggressive optimization (-O3)</td></tr>
<tr align="left"><td>regenerate</td><td>0</td><td>Regenerates the test verification data</td></tr>
<tr align="left"><td>reparse</td><td>0</td><td>Runs bison/flex to create the C++ files for parsing selections</td></tr>
</table>

\subsection Regeneration
The verification tests include sample output that is compared against
the current build.  If differences are found, they are flagged as
potential problems with the library.  If you update a test, change
systems (such as running on OS X as opposed to Linux), or perhaps
didn't get the test data from the SVN, then you will need to 
generate new test data and verify it manually.  To do so, use the
SCons command:
\verbatim
scons regenerate=1 tests
\endverbatim

\subsection Reparsing
To remove the dependency on Bison/Flex, the output from these tools
for the grammar and scanner are included.  If you want to rebuild
them, you will need to use the 'reparse=1' option.  The catch is that
if you have a different version of flex installed, there is a good
chance there will be a conflict with the bundled FlexLexer.h include
file.  If you see odd compiler errors, try removing that file and
rebuilding.  Alternatively, forcibly remove all generated files by
doing "rm *.cc *.hh" (assuming you've added no files with those
suffixes), then rebuild.
*/
