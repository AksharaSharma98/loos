<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>LOOS: loos::AtomicGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LOOS
   &#160;<span id="projectnumber">v3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classloos_1_1_atomic_group.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classloos_1_1_atomic_group-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">loos::AtomicGroup Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for handling groups of Atoms (pAtoms, actually)  
 <a href="classloos_1_1_atomic_group.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_atomic_group_8hpp_source.html">AtomicGroup.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for loos::AtomicGroup:</div>
<div class="dyncontent">
<div class="center"><img src="classloos_1_1_atomic_group__inherit__graph.png" border="0" usemap="#loos_1_1_atomic_group_inherit__map" alt="Inheritance graph"/></div>
<map name="loos_1_1_atomic_group_inherit__map" id="loos_1_1_atomic_group_inherit__map">
<area shape="rect" id="node2" href="classloos_1_1_amber.html" title="Class for reading in AMBER parmtop/coord files... " alt="" coords="5,79,98,104"/>
<area shape="rect" id="node3" href="classloos_1_1_c_h_a_r_m_m.html" title="Class for reading a CHARMM coordinate file. " alt="" coords="122,79,235,104"/>
<area shape="rect" id="node4" href="classloos_1_1_gromacs.html" title="Implements a GROMACS model file (.gro) " alt="" coords="259,79,367,104"/>
<area shape="rect" id="node5" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class. " alt="" coords="390,79,471,104"/>
<area shape="rect" id="node6" href="classloos_1_1_p_s_f.html" title="Class for reading a subset of the PSF format. " alt="" coords="495,79,574,104"/>
<area shape="rect" id="node7" href="classloos_1_1_tinker_x_y_z.html" title="Class for reading a subset of the TinkerXYZ format. " alt="" coords="598,79,713,104"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for loos::AtomicGroup:</div>
<div class="dyncontent">
<div class="center"><img src="classloos_1_1_atomic_group__coll__graph.png" border="0" usemap="#loos_1_1_atomic_group_coll__map" alt="Collaboration graph"/></div>
<map name="loos_1_1_atomic_group_coll__map" id="loos_1_1_atomic_group_coll__map">
<area shape="rect" id="node2" href="classloos_1_1_shared_periodic_box.html" title="This class manages a shared Periodicbox. " alt="" coords="5,179,173,204"/>
<area shape="rect" id="node4" title="STL class. " alt="" coords="212,92,326,117"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group_1_1_iterator.html">Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our own simple iterator for stepping over all managed atoms.  <a href="classloos_1_1_atomic_group_1_1_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6221d23a16953e033ce19749dc011c63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6221d23a16953e033ce19749dc011c63"></a>
typedef std::vector&lt; pAtom &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a6221d23a16953e033ce19749dc011c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cf1aeeacb960a6a45f91a8ec931659"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3cf1aeeacb960a6a45f91a8ec931659"></a>
typedef std::vector&lt; pAtom &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:af3cf1aeeacb960a6a45f91a8ec931659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0e13a72c353cf309f652aed6bff90c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc0e13a72c353cf309f652aed6bff90c"></a>
typedef pAtom&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:afc0e13a72c353cf309f652aed6bff90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a125a4b144bc5457366ae204e8f98f446"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a125a4b144bc5457366ae204e8f98f446">AtomicGroup</a> (const int n)</td></tr>
<tr class="memdesc:a125a4b144bc5457366ae204e8f98f446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> with <em>n</em> un-initialized atoms.  <a href="#a125a4b144bc5457366ae204e8f98f446">More...</a><br /></td></tr>
<tr class="separator:a125a4b144bc5457366ae204e8f98f446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8a428dd6a010ab86dda09d5a461fd2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d8a428dd6a010ab86dda09d5a461fd2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a9d8a428dd6a010ab86dda09d5a461fd2">AtomicGroup</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>
<tr class="memdesc:a9d8a428dd6a010ab86dda09d5a461fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (atoms and box shared) <br /></td></tr>
<tr class="separator:a9d8a428dd6a010ab86dda09d5a461fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1966c971d7730391d417bcdfd1486e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_matrix44.html">GMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a9d1966c971d7730391d417bcdfd1486e">alignOnto</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;)</td></tr>
<tr class="memdesc:a9d1966c971d7730391d417bcdfd1486e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Superimposes the current group onto the passed group.  <a href="#a9d1966c971d7730391d417bcdfd1486e">More...</a><br /></td></tr>
<tr class="separator:a9d1966c971d7730391d417bcdfd1486e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce7750b4ed8ec8a85f75364df457121"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ce7750b4ed8ec8a85f75364df457121"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a3ce7750b4ed8ec8a85f75364df457121">allHaveProperty</a> (const <a class="el" href="classloos_1_1_atom.html#a2a758660bf774fc372bd294a3fc92e53">Atom::bits</a> &amp;property) const </td></tr>
<tr class="memdesc:a3ce7750b4ed8ec8a85f75364df457121"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if all atoms in the group have the passed property(ies) <br /></td></tr>
<tr class="separator:a3ce7750b4ed8ec8a85f75364df457121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad234910f41d8d2c77e6340f31e7a9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adad234910f41d8d2c77e6340f31e7a9f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#adad234910f41d8d2c77e6340f31e7a9f">anyHaveProperty</a> (const <a class="el" href="classloos_1_1_atom.html#a2a758660bf774fc372bd294a3fc92e53">Atom::bits</a> &amp;property) const </td></tr>
<tr class="memdesc:adad234910f41d8d2c77e6340f31e7a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if any atom in the group have the passed property(ies) <br /></td></tr>
<tr class="separator:adad234910f41d8d2c77e6340f31e7a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2aaffd7cfb10698499e9301041ff3d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2aaffd7cfb10698499e9301041ff3d1"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#aa2aaffd7cfb10698499e9301041ff3d1">append</a> (pAtom pa)</td></tr>
<tr class="memdesc:aa2aaffd7cfb10698499e9301041ff3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the atom onto the group. <br /></td></tr>
<tr class="separator:aa2aaffd7cfb10698499e9301041ff3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292faf9da4066b9425d0b3334bcf9e43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a292faf9da4066b9425d0b3334bcf9e43"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a292faf9da4066b9425d0b3334bcf9e43">append</a> (std::vector&lt; pAtom &gt; pas)</td></tr>
<tr class="memdesc:a292faf9da4066b9425d0b3334bcf9e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a vector of atoms. <br /></td></tr>
<tr class="separator:a292faf9da4066b9425d0b3334bcf9e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22f0f96ac05fbf0bc1d886bc48a73cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac22f0f96ac05fbf0bc1d886bc48a73cf"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ac22f0f96ac05fbf0bc1d886bc48a73cf">append</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp)</td></tr>
<tr class="memdesc:ac22f0f96ac05fbf0bc1d886bc48a73cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an entire <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> onto this one (concatenation) <br /></td></tr>
<tr class="separator:ac22f0f96ac05fbf0bc1d886bc48a73cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300ee7d7bb26e246c1cd78829191a4fd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a300ee7d7bb26e246c1cd78829191a4fd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a300ee7d7bb26e246c1cd78829191a4fd">apply</a> (T func)</td></tr>
<tr class="memdesc:a300ee7d7bb26e246c1cd78829191a4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor or a function to each atom in the group.  <a href="#a300ee7d7bb26e246c1cd78829191a4fd">More...</a><br /></td></tr>
<tr class="separator:a300ee7d7bb26e246c1cd78829191a4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52542da1e67eeb3a14fd8ecf2c7a8c87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52542da1e67eeb3a14fd8ecf2c7a8c87"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a52542da1e67eeb3a14fd8ecf2c7a8c87">applyTransform</a> (const <a class="el" href="classloos_1_1_x_form.html">XForm</a> &amp;)</td></tr>
<tr class="memdesc:a52542da1e67eeb3a14fd8ecf2c7a8c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the given transform to the group's coordinates... <br /></td></tr>
<tr class="separator:a52542da1e67eeb3a14fd8ecf2c7a8c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c50256c66c58e818df2090b1cdce05c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a6c50256c66c58e818df2090b1cdce05c">atomOrderMapFrom</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>
<tr class="memdesc:a6c50256c66c58e818df2090b1cdce05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the order of atoms in <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> g into the current group.  <a href="#a6c50256c66c58e818df2090b1cdce05c">More...</a><br /></td></tr>
<tr class="separator:a6c50256c66c58e818df2090b1cdce05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd5a8cc5a6d1fe8f391b1782d008007"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbd5a8cc5a6d1fe8f391b1782d008007"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (void)</td></tr>
<tr class="separator:abbd5a8cc5a6d1fe8f391b1782d008007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b52c54af3ee70f45771362691cd14f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b52c54af3ee70f45771362691cd14f3"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (void) const </td></tr>
<tr class="separator:a9b52c54af3ee70f45771362691cd14f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1d65a15ea4b388fa2953ca1b8debb1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#add1d65a15ea4b388fa2953ca1b8debb1">boundingBox</a> (void) const </td></tr>
<tr class="memdesc:add1d65a15ea4b388fa2953ca1b8debb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounding box for the group...  <a href="#add1d65a15ea4b388fa2953ca1b8debb1">More...</a><br /></td></tr>
<tr class="separator:add1d65a15ea4b388fa2953ca1b8debb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429f96e9a94724ec68796f4c856f76b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_coord.html">GCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a429f96e9a94724ec68796f4c856f76b5">centerAtOrigin</a> (void)</td></tr>
<tr class="memdesc:a429f96e9a94724ec68796f4c856f76b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates the group so that the centroid is at the origin.  <a href="#a429f96e9a94724ec68796f4c856f76b5">More...</a><br /></td></tr>
<tr class="separator:a429f96e9a94724ec68796f4c856f76b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0914f4528860eb7d729f702782fa3ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0914f4528860eb7d729f702782fa3ae"></a>
<a class="el" href="classloos_1_1_coord.html">GCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#aa0914f4528860eb7d729f702782fa3ae">centerOfElectrons</a> (void) const </td></tr>
<tr class="memdesc:aa0914f4528860eb7d729f702782fa3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to center of mass. <br /></td></tr>
<tr class="separator:aa0914f4528860eb7d729f702782fa3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366b5e348b26199400a46d0bdf55dcbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a366b5e348b26199400a46d0bdf55dcbe"></a>
<a class="el" href="classloos_1_1_coord.html">GCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a366b5e348b26199400a46d0bdf55dcbe">centerOfMass</a> (void) const </td></tr>
<tr class="memdesc:a366b5e348b26199400a46d0bdf55dcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Center of mass of the group (in group coordinates) <br /></td></tr>
<tr class="separator:a366b5e348b26199400a46d0bdf55dcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b50bb3c98f7ddda72c7e0dddd95ea60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a2b50bb3c98f7ddda72c7e0dddd95ea60">centrifyByMolecule</a> () const </td></tr>
<tr class="memdesc:a2b50bb3c98f7ddda72c7e0dddd95ea60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a group with the center of masses of contained molecules.  <a href="#a2b50bb3c98f7ddda72c7e0dddd95ea60">More...</a><br /></td></tr>
<tr class="separator:a2b50bb3c98f7ddda72c7e0dddd95ea60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9641572c666cc026cd3cee245f16e4df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9641572c666cc026cd3cee245f16e4df"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a9641572c666cc026cd3cee245f16e4df">centrifyByResidue</a> () const </td></tr>
<tr class="memdesc:a9641572c666cc026cd3cee245f16e4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a group with the cente of masses of contained residues (see <a class="el" href="classloos_1_1_atomic_group.html#a2b50bb3c98f7ddda72c7e0dddd95ea60" title="Replace a group with the center of masses of contained molecules. ">centrifyByMolecule()</a>) <br /></td></tr>
<tr class="separator:a9641572c666cc026cd3cee245f16e4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26667576771cba32914ee97113a3b7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad26667576771cba32914ee97113a3b7f"></a>
<a class="el" href="classloos_1_1_coord.html">GCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ad26667576771cba32914ee97113a3b7f">centroid</a> (void) const </td></tr>
<tr class="memdesc:ad26667576771cba32914ee97113a3b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centroid of atoms (ignores mass, operates in group coordinates) <br /></td></tr>
<tr class="separator:ad26667576771cba32914ee97113a3b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207734a7387d8aadd0ded48652ca12ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a207734a7387d8aadd0ded48652ca12ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a207734a7387d8aadd0ded48652ca12ea">clearBonds</a> (void)</td></tr>
<tr class="memdesc:a207734a7387d8aadd0ded48652ca12ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any bonding information present in contained atoms. <br /></td></tr>
<tr class="separator:a207734a7387d8aadd0ded48652ca12ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ca8a6697b307b2ef86362c17b1c402"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a02ca8a6697b307b2ef86362c17b1c402">clone</a> (void) const </td></tr>
<tr class="memdesc:a02ca8a6697b307b2ef86362c17b1c402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a lightweight clone of this group (for polymorphism)  <a href="#a02ca8a6697b307b2ef86362c17b1c402">More...</a><br /></td></tr>
<tr class="separator:a02ca8a6697b307b2ef86362c17b1c402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34fb9545f24da183577fb81de246c9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ab34fb9545f24da183577fb81de246c9d">contactWith</a> (const double dist, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp, const uint min=1) const </td></tr>
<tr class="memdesc:ab34fb9545f24da183577fb81de246c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any atom of current group is within <em>dist</em> angstroms of <em>grp</em>.  <a href="#ab34fb9545f24da183577fb81de246c9d">More...</a><br /></td></tr>
<tr class="separator:ab34fb9545f24da183577fb81de246c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f9a440e52b34d9d520ee1443e6a7e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#aa7f9a440e52b34d9d520ee1443e6a7e3">contactWith</a> (const double dist, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box, const uint min=1) const </td></tr>
<tr class="memdesc:aa7f9a440e52b34d9d520ee1443e6a7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any atom of current group is within <em>dist</em> angstroms of <em>grp</em>.  <a href="#aa7f9a440e52b34d9d520ee1443e6a7e3">More...</a><br /></td></tr>
<tr class="separator:aa7f9a440e52b34d9d520ee1443e6a7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1eee0b50387264fc2cd8739a569689c"><td class="memTemplParams" colspan="2">template&lt;class EqualsOp &gt; </td></tr>
<tr class="memitem:ab1eee0b50387264fc2cd8739a569689c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ab1eee0b50387264fc2cd8739a569689c">contains</a> (const pAtom &amp;p, const EqualsOp &amp;op) const </td></tr>
<tr class="memdesc:ab1eee0b50387264fc2cd8739a569689c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a pAtom is contained in this group using the EqualsOp atom-equality policy.  <a href="#ab1eee0b50387264fc2cd8739a569689c">More...</a><br /></td></tr>
<tr class="separator:ab1eee0b50387264fc2cd8739a569689c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecd804f892b48d22ec3f44dbe41eb98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ecd804f892b48d22ec3f44dbe41eb98"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a7ecd804f892b48d22ec3f44dbe41eb98">contains</a> (const pAtom &amp;p) const </td></tr>
<tr class="memdesc:a7ecd804f892b48d22ec3f44dbe41eb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a pAtom is contained in this group using the <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid. ">AtomEquals</a> policy (ie the default comparison policy) <br /></td></tr>
<tr class="separator:a7ecd804f892b48d22ec3f44dbe41eb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30cd421669380208ca4760d6dd21345"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa30cd421669380208ca4760d6dd21345"></a>
template&lt;class EqualsOp &gt; </td></tr>
<tr class="memitem:aa30cd421669380208ca4760d6dd21345"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#aa30cd421669380208ca4760d6dd21345">contains</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, const EqualsOp &amp;op) const </td></tr>
<tr class="memdesc:aa30cd421669380208ca4760d6dd21345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the passed group is a subset of the current group using the EqualsOp atom-equality policy. <br /></td></tr>
<tr class="separator:aa30cd421669380208ca4760d6dd21345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca94900244e46c69ab30951ec585c69b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca94900244e46c69ab30951ec585c69b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#aca94900244e46c69ab30951ec585c69b">contains</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g) const </td></tr>
<tr class="memdesc:aca94900244e46c69ab30951ec585c69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a group is a subset of the current group using the default <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid. ">AtomEquals</a> policy. <br /></td></tr>
<tr class="separator:aca94900244e46c69ab30951ec585c69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d7c677610c950139911880eb2b2b6e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a42d7c677610c950139911880eb2b2b6e"></a>
template&lt;class EqualsOp &gt; </td></tr>
<tr class="memitem:a42d7c677610c950139911880eb2b2b6e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a42d7c677610c950139911880eb2b2b6e">containsAny</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, const EqualsOp &amp;op) const </td></tr>
<tr class="memdesc:a42d7c677610c950139911880eb2b2b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a group contains any atom. <br /></td></tr>
<tr class="separator:a42d7c677610c950139911880eb2b2b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3029ec15c74d90ff057c9ac596211e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b3029ec15c74d90ff057c9ac596211e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a8b3029ec15c74d90ff057c9ac596211e">containsAny</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g) const </td></tr>
<tr class="memdesc:a8b3029ec15c74d90ff057c9ac596211e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a group contains any atom using the default <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid. ">AtomEquals</a> policy. <br /></td></tr>
<tr class="separator:a8b3029ec15c74d90ff057c9ac596211e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d767245bb91ba14377d79be8be6124"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70d767245bb91ba14377d79be8be6124"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>coordsAsVector</b> () const </td></tr>
<tr class="separator:a70d767245bb91ba14377d79be8be6124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1126df7bc01ffad44a95537f5ce40248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a1126df7bc01ffad44a95537f5ce40248">copy</a> (void) const </td></tr>
<tr class="memdesc:a1126df7bc01ffad44a95537f5ce40248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this group.  <a href="#a1126df7bc01ffad44a95537f5ce40248">More...</a><br /></td></tr>
<tr class="separator:a1126df7bc01ffad44a95537f5ce40248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922415f440fece32f23da2103cdc8d0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a922415f440fece32f23da2103cdc8d0d">copyCoordinatesFrom</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, const uint offset=0, const uint length=0)</td></tr>
<tr class="memdesc:a922415f440fece32f23da2103cdc8d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy coordinates from g into current group.  <a href="#a922415f440fece32f23da2103cdc8d0d">More...</a><br /></td></tr>
<tr class="separator:a922415f440fece32f23da2103cdc8d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358e1edc74a57218e6261ab7692c5ef6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a358e1edc74a57218e6261ab7692c5ef6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a358e1edc74a57218e6261ab7692c5ef6">copyCoordinatesWithIndex</a> (const std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; &amp;coords)</td></tr>
<tr class="memdesc:a358e1edc74a57218e6261ab7692c5ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy coordinates from a vector of GCoords using the atom index as an index into the vector. <br /></td></tr>
<tr class="separator:a358e1edc74a57218e6261ab7692c5ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd03b1c9bfad1e983b3c616350304cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a3fd03b1c9bfad1e983b3c616350304cf">copyMappedCoordinatesFrom</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, const std::vector&lt; uint &gt; &amp;order)</td></tr>
<tr class="memdesc:a3fd03b1c9bfad1e983b3c616350304cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mapping of atom order, copy the coordinates into the current group.  <a href="#a3fd03b1c9bfad1e983b3c616350304cf">More...</a><br /></td></tr>
<tr class="separator:a3fd03b1c9bfad1e983b3c616350304cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3a1163fdcd8234a4e78dda2fb9bf0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a5a3a1163fdcd8234a4e78dda2fb9bf0e">copyMappedCoordinatesFrom</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>
<tr class="memdesc:a5a3a1163fdcd8234a4e78dda2fb9bf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the coordinates from the group mapping the atom order.  <a href="#a5a3a1163fdcd8234a4e78dda2fb9bf0e">More...</a><br /></td></tr>
<tr class="separator:a5a3a1163fdcd8234a4e78dda2fb9bf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5a37ae808c139a54eb8049601ffc85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a4c5a37ae808c139a54eb8049601ffc85">copyVelocitiesWithIndex</a> (const std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; &amp;velocities)</td></tr>
<tr class="memdesc:a4c5a37ae808c139a54eb8049601ffc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy velocities from a vector of GCoords using the atom index as an index into the vector.  <a href="#a4c5a37ae808c139a54eb8049601ffc85">More...</a><br /></td></tr>
<tr class="separator:a4c5a37ae808c139a54eb8049601ffc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf2ee4a474c487db2dab7651ddb5204"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#afbf2ee4a474c487db2dab7651ddb5204">deduceAtomicNumberFromMass</a> (const double tol=0.1)</td></tr>
<tr class="memdesc:afbf2ee4a474c487db2dab7651ddb5204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce atomic number from mass (if present), returning number of atoms assigned.  <a href="#afbf2ee4a474c487db2dab7651ddb5204">More...</a><br /></td></tr>
<tr class="separator:afbf2ee4a474c487db2dab7651ddb5204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134a2fa951b17bd310854782622e1d5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a134a2fa951b17bd310854782622e1d5c"></a>
<a class="el" href="classloos_1_1_coord.html">GCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a134a2fa951b17bd310854782622e1d5c">dipoleMoment</a> (void) const </td></tr>
<tr class="memdesc:a134a2fa951b17bd310854782622e1d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dipole moment, relative to group's centroid. <br /></td></tr>
<tr class="separator:a134a2fa951b17bd310854782622e1d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b98d8d1d88bb159216b073c0f72bb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7b98d8d1d88bb159216b073c0f72bb8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> (void) const </td></tr>
<tr class="separator:af7b98d8d1d88bb159216b073c0f72bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c0bb921cb2484cec7ad8054fa64e7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6c0bb921cb2484cec7ad8054fa64e7c"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (void)</td></tr>
<tr class="separator:ae6c0bb921cb2484cec7ad8054fa64e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ce1b0595601eb08d18882ebde751e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10ce1b0595601eb08d18882ebde751e5"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (void) const </td></tr>
<tr class="separator:a10ce1b0595601eb08d18882ebde751e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f001aeb52990a0b0c992bde74053376"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f001aeb52990a0b0c992bde74053376"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a8f001aeb52990a0b0c992bde74053376">excise</a> (const int offset, const int len=0)</td></tr>
<tr class="memdesc:a8f001aeb52990a0b0c992bde74053376"><td class="mdescLeft">&#160;</td><td class="mdescRight">excise returns the excised atoms as a group... <br /></td></tr>
<tr class="separator:a8f001aeb52990a0b0c992bde74053376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b5b12845449dddc4df4cc16fa89b30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a27b5b12845449dddc4df4cc16fa89b30">findBonds</a> (const double dist, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box)</td></tr>
<tr class="memdesc:a27b5b12845449dddc4df4cc16fa89b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance-based search for bonds.  <a href="#a27b5b12845449dddc4df4cc16fa89b30">More...</a><br /></td></tr>
<tr class="separator:a27b5b12845449dddc4df4cc16fa89b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcefc179e187903d3fb8da078d0cf06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbcefc179e187903d3fb8da078d0cf06"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>findBonds</b> (const double dist)</td></tr>
<tr class="separator:adbcefc179e187903d3fb8da078d0cf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a19e2fab6532d68291b5cc7aaf6efef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a19e2fab6532d68291b5cc7aaf6efef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>findBonds</b> (const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box)</td></tr>
<tr class="separator:a6a19e2fab6532d68291b5cc7aaf6efef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb13cb00e25462f1555191da339f691"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bb13cb00e25462f1555191da339f691"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>findBonds</b> ()</td></tr>
<tr class="separator:a0bb13cb00e25462f1555191da339f691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8aadcfcaa3e8a49169e1262dd2b115"><td class="memItemLeft" align="right" valign="top">pAtom&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a7a8aadcfcaa3e8a49169e1262dd2b115">findById</a> (const int id) const </td></tr>
<tr class="memdesc:a7a8aadcfcaa3e8a49169e1262dd2b115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a contained atom by its atomid.  <a href="#a7a8aadcfcaa3e8a49169e1262dd2b115">More...</a><br /></td></tr>
<tr class="separator:a7a8aadcfcaa3e8a49169e1262dd2b115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86dc40255ba8e1af05c81737988e20b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af86dc40255ba8e1af05c81737988e20b"></a>
pAtom&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#af86dc40255ba8e1af05c81737988e20b">getAtom</a> (const int i) const </td></tr>
<tr class="memdesc:af86dc40255ba8e1af05c81737988e20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ith atom from this group. <br /></td></tr>
<tr class="separator:af86dc40255ba8e1af05c81737988e20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605b30aef2f4da808eb92ec0ae0fe9f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a605b30aef2f4da808eb92ec0ae0fe9f2">getCoords</a> (double **outseq, int *m, int *n)</td></tr>
<tr class="separator:a605b30aef2f4da808eb92ec0ae0fe9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5f36f01919f6b54fa410e956c02816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a0b5f36f01919f6b54fa410e956c02816">getResidue</a> (pAtom res)</td></tr>
<tr class="separator:a0b5f36f01919f6b54fa410e956c02816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab786587c1ed62f04afa1d64781ad06cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ab786587c1ed62f04afa1d64781ad06cc">getTransformedCoords</a> (const <a class="el" href="classloos_1_1_x_form.html">XForm</a> &amp;) const </td></tr>
<tr class="memdesc:ab786587c1ed62f04afa1d64781ad06cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of coordinates transformed by the passed <a class="el" href="classloos_1_1_x_form.html" title="Matrix class for handling coordinate transforms... ">XForm</a>.  <a href="#ab786587c1ed62f04afa1d64781ad06cc">More...</a><br /></td></tr>
<tr class="separator:ab786587c1ed62f04afa1d64781ad06cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab241f7c4aa73dbefb6cb1d26d13ea7f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ab241f7c4aa73dbefb6cb1d26d13ea7f6">groupFromID</a> (const std::vector&lt; int &gt; &amp;id_list) const </td></tr>
<tr class="memdesc:ab241f7c4aa73dbefb6cb1d26d13ea7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new group from a vector of atomids.  <a href="#ab241f7c4aa73dbefb6cb1d26d13ea7f6">More...</a><br /></td></tr>
<tr class="separator:ab241f7c4aa73dbefb6cb1d26d13ea7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3169d34e68659c6ac04c210006178f90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3169d34e68659c6ac04c210006178f90"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a3169d34e68659c6ac04c210006178f90">hasBonds</a> (void) const </td></tr>
<tr class="memdesc:a3169d34e68659c6ac04c210006178f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does any atom in the group have bond information??? <br /></td></tr>
<tr class="separator:a3169d34e68659c6ac04c210006178f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b1aad02e4a862a781a0d0e3f5b719e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77b1aad02e4a862a781a0d0e3f5b719e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a77b1aad02e4a862a781a0d0e3f5b719e">hasCoords</a> (void) const </td></tr>
<tr class="memdesc:a77b1aad02e4a862a781a0d0e3f5b719e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do all the atoms in the group have coordinates? <br /></td></tr>
<tr class="separator:a77b1aad02e4a862a781a0d0e3f5b719e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872a5b02eca7320f51181b5a8385e6e5"><td class="memTemplParams" colspan="2">template&lt;class EqualsOp &gt; </td></tr>
<tr class="memitem:a872a5b02eca7320f51181b5a8385e6e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a872a5b02eca7320f51181b5a8385e6e5">intersect</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, const EqualsOp &amp;op)</td></tr>
<tr class="memdesc:a872a5b02eca7320f51181b5a8385e6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of two groups using the EqualsOp atom-equality policy.  <a href="#a872a5b02eca7320f51181b5a8385e6e5">More...</a><br /></td></tr>
<tr class="separator:a872a5b02eca7320f51181b5a8385e6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3314820bb1af318a9fbbc492a8c41d92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3314820bb1af318a9fbbc492a8c41d92"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a3314820bb1af318a9fbbc492a8c41d92">intersect</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>
<tr class="memdesc:a3314820bb1af318a9fbbc492a8c41d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection of two groups. <br /></td></tr>
<tr class="separator:a3314820bb1af318a9fbbc492a8c41d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8338a644424edb15159502ade2ce1c33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8338a644424edb15159502ade2ce1c33"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a8338a644424edb15159502ade2ce1c33">isPeriodic</a> (void) const </td></tr>
<tr class="memdesc:a8338a644424edb15159502ade2ce1c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether or not periodic boundary conditions are set. <br /></td></tr>
<tr class="separator:a8338a644424edb15159502ade2ce1c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7901950b11a6f06080ee338bd53b72"><td class="memItemLeft" align="right" valign="top">greal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#abb7901950b11a6f06080ee338bd53b72">kineticEnergy</a> ()</td></tr>
<tr class="memdesc:abb7901950b11a6f06080ee338bd53b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute kinetic energy of group.  <a href="#abb7901950b11a6f06080ee338bd53b72">More...</a><br /></td></tr>
<tr class="separator:abb7901950b11a6f06080ee338bd53b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea02ea0518d046f99c4e3a8f5827578"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ea02ea0518d046f99c4e3a8f5827578"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>length</b> (void) const </td></tr>
<tr class="separator:a0ea02ea0518d046f99c4e3a8f5827578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73b7940caa47ed4b3834a8e9eacf4a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae73b7940caa47ed4b3834a8e9eacf4a3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>maxId</b> (void) const </td></tr>
<tr class="separator:ae73b7940caa47ed4b3834a8e9eacf4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197b960527be80af05c269ac76315e68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a197b960527be80af05c269ac76315e68"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>maxResid</b> (void) const </td></tr>
<tr class="separator:a197b960527be80af05c269ac76315e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565774cc283d8e5e65fc486330c744f9"><td class="memTemplParams" colspan="2">template&lt;class EqualsOp &gt; </td></tr>
<tr class="memitem:a565774cc283d8e5e65fc486330c744f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a565774cc283d8e5e65fc486330c744f9">merge</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, const EqualsOp &amp;op)</td></tr>
<tr class="memdesc:a565774cc283d8e5e65fc486330c744f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of two groups using the specified atom-equality policy.  <a href="#a565774cc283d8e5e65fc486330c744f9">More...</a><br /></td></tr>
<tr class="separator:a565774cc283d8e5e65fc486330c744f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4f5469c4c73f9fc1c3d1ade297a913"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e4f5469c4c73f9fc1c3d1ade297a913"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a5e4f5469c4c73f9fc1c3d1ade297a913">merge</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>
<tr class="memdesc:a5e4f5469c4c73f9fc1c3d1ade297a913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of two groups using the default <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid. ">AtomEquals</a> atom-equality policy. <br /></td></tr>
<tr class="separator:a5e4f5469c4c73f9fc1c3d1ade297a913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8224e853282a81e55ca83fc8594cd80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ab8224e853282a81e55ca83fc8594cd80">mergeImage</a> (pAtom &amp;p)</td></tr>
<tr class="memdesc:ab8224e853282a81e55ca83fc8594cd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a group that's split across a periodic boundary and reimages it so it's all together.  <a href="#ab8224e853282a81e55ca83fc8594cd80">More...</a><br /></td></tr>
<tr class="separator:ab8224e853282a81e55ca83fc8594cd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b136bf681b267e113c35a6651cbfe51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a4b136bf681b267e113c35a6651cbfe51">mergeImage</a> ()</td></tr>
<tr class="memdesc:a4b136bf681b267e113c35a6651cbfe51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a group that's split across a periodic boundary and reimages it so it's all together, using the first atom in the <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> as the reference.  <a href="#a4b136bf681b267e113c35a6651cbfe51">More...</a><br /></td></tr>
<tr class="separator:a4b136bf681b267e113c35a6651cbfe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5faf41086f89352626b0d8e93e00a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba5faf41086f89352626b0d8e93e00a0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>minId</b> (void) const </td></tr>
<tr class="separator:aba5faf41086f89352626b0d8e93e00a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081b805047d02270094386c8564385a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a081b805047d02270094386c8564385a1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>minResid</b> (void) const </td></tr>
<tr class="separator:a081b805047d02270094386c8564385a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0204deda6ace2293fe0675812f4f8d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a0a0204deda6ace2293fe0675812f4f8d">momentsOfInertia</a> (void) const </td></tr>
<tr class="memdesc:a0a0204deda6ace2293fe0675812f4f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the moments of inertia for a group.  <a href="#a0a0204deda6ace2293fe0675812f4f8d">More...</a><br /></td></tr>
<tr class="separator:a0a0204deda6ace2293fe0675812f4f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57be13b14440df21544468bc2764eac0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57be13b14440df21544468bc2764eac0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numberOfResidues</b> (void) const </td></tr>
<tr class="separator:a57be13b14440df21544468bc2764eac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50ce1e25cecb4bf15a16f12ee705c57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad50ce1e25cecb4bf15a16f12ee705c57"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numberOfSegids</b> (void) const </td></tr>
<tr class="separator:ad50ce1e25cecb4bf15a16f12ee705c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca357a30a685ab4394d9b055d557727"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ca357a30a685ab4394d9b055d557727"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a6ca357a30a685ab4394d9b055d557727">operator!=</a> (<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs)</td></tr>
<tr class="memdesc:a6ca357a30a685ab4394d9b055d557727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality test for two groups. <br /></td></tr>
<tr class="separator:a6ca357a30a685ab4394d9b055d557727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1eb6a409784584453b13d5e2c5c7b8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1eb6a409784584453b13d5e2c5c7b8c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ad1eb6a409784584453b13d5e2c5c7b8c">operator!=</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs) const </td></tr>
<tr class="memdesc:ad1eb6a409784584453b13d5e2c5c7b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality test for two groups. <br /></td></tr>
<tr class="separator:ad1eb6a409784584453b13d5e2c5c7b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae894af21108bb06b5f1cf1aaeecdb0c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae894af21108bb06b5f1cf1aaeecdb0c7"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs)</td></tr>
<tr class="separator:ae894af21108bb06b5f1cf1aaeecdb0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3213e4858ec14a9293f107215082fa99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3213e4858ec14a9293f107215082fa99"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const pAtom &amp;rhs)</td></tr>
<tr class="separator:a3213e4858ec14a9293f107215082fa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f4f60bd3c46b587d5ecc3d481fc09c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7f4f60bd3c46b587d5ecc3d481fc09c"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs)</td></tr>
<tr class="separator:af7f4f60bd3c46b587d5ecc3d481fc09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b11da8e2cdc6e8a5fa0d5b1f26d854e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b11da8e2cdc6e8a5fa0d5b1f26d854e"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const pAtom &amp;rhs)</td></tr>
<tr class="separator:a0b11da8e2cdc6e8a5fa0d5b1f26d854e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838252229a0bae82a0c6184c4a7638ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a838252229a0bae82a0c6184c4a7638ba">operator==</a> (<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs)</td></tr>
<tr class="memdesc:a838252229a0bae82a0c6184c4a7638ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality test for two groups.  <a href="#a838252229a0bae82a0c6184c4a7638ba">More...</a><br /></td></tr>
<tr class="separator:a838252229a0bae82a0c6184c4a7638ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0288588db8433e56c11899419ac8fa8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ae0288588db8433e56c11899419ac8fa8">operator==</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs) const </td></tr>
<tr class="memdesc:ae0288588db8433e56c11899419ac8fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality test for const groups.  <a href="#ae0288588db8433e56c11899419ac8fa8">More...</a><br /></td></tr>
<tr class="separator:ae0288588db8433e56c11899419ac8fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fdbd8588fe478c2b6c69ab6a421400"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5fdbd8588fe478c2b6c69ab6a421400"></a>
pAtom &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#af5fdbd8588fe478c2b6c69ab6a421400">operator[]</a> (const int i)</td></tr>
<tr class="memdesc:af5fdbd8588fe478c2b6c69ab6a421400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as getAtom(i) <br /></td></tr>
<tr class="separator:af5fdbd8588fe478c2b6c69ab6a421400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf6c5276a4ffc9eaa4e3f13ec212361"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bf6c5276a4ffc9eaa4e3f13ec212361"></a>
const pAtom &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const int i) const </td></tr>
<tr class="separator:a4bf6c5276a4ffc9eaa4e3f13ec212361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7df3660d00eb14a49e33f40b80878d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe7df3660d00eb14a49e33f40b80878d"></a>
<a class="el" href="classloos_1_1_coord.html">GCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#abe7df3660d00eb14a49e33f40b80878d">periodicBox</a> (void) const </td></tr>
<tr class="memdesc:abe7df3660d00eb14a49e33f40b80878d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the periodic boundary conditions. <br /></td></tr>
<tr class="separator:abe7df3660d00eb14a49e33f40b80878d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9eab6e6bae0c319d8534b0f0cc3215"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb9eab6e6bae0c319d8534b0f0cc3215"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#aeb9eab6e6bae0c319d8534b0f0cc3215">periodicBox</a> (const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;c)</td></tr>
<tr class="memdesc:aeb9eab6e6bae0c319d8534b0f0cc3215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the periodic boundary conditions. <br /></td></tr>
<tr class="separator:aeb9eab6e6bae0c319d8534b0f0cc3215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e9fc4b412353e46cd78a390494c221"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94e9fc4b412353e46cd78a390494c221"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a94e9fc4b412353e46cd78a390494c221">periodicBox</a> (const greal x, const greal y, const greal z)</td></tr>
<tr class="memdesc:a94e9fc4b412353e46cd78a390494c221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the periodic boundary conditions. <br /></td></tr>
<tr class="separator:a94e9fc4b412353e46cd78a390494c221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd02e8969d6e05ea36e5531014d72084"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd02e8969d6e05ea36e5531014d72084"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#afd02e8969d6e05ea36e5531014d72084">perturbCoords</a> (const greal)</td></tr>
<tr class="memdesc:afd02e8969d6e05ea36e5531014d72084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each atom is moved in a random direction by a vector of the passed size. <br /></td></tr>
<tr class="separator:afd02e8969d6e05ea36e5531014d72084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ce39f2d7a53db0f5cc858db1b3607a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ab9ce39f2d7a53db0f5cc858db1b3607a">principalAxes</a> (void) const </td></tr>
<tr class="memdesc:ab9ce39f2d7a53db0f5cc858db1b3607a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the principal axes of a group.  <a href="#ab9ce39f2d7a53db0f5cc858db1b3607a">More...</a><br /></td></tr>
<tr class="separator:ab9ce39f2d7a53db0f5cc858db1b3607a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab682d7a74a46a65d920f0e362bc72c5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ab682d7a74a46a65d920f0e362bc72c5a">pruneBonds</a> ()</td></tr>
<tr class="memdesc:ab682d7a74a46a65d920f0e362bc72c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to prune connectivity (only retain bonds to atoms within this <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a>)  <a href="#ab682d7a74a46a65d920f0e362bc72c5a">More...</a><br /></td></tr>
<tr class="separator:ab682d7a74a46a65d920f0e362bc72c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f304c334d971041e5258bd2cab96da"><td class="memItemLeft" align="right" valign="top">greal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a03f304c334d971041e5258bd2cab96da">radius</a> (const bool use_atom_as_reference=false) const </td></tr>
<tr class="memdesc:a03f304c334d971041e5258bd2cab96da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum radius from centroid of all atoms (not gyration)  <a href="#a03f304c334d971041e5258bd2cab96da">More...</a><br /></td></tr>
<tr class="separator:a03f304c334d971041e5258bd2cab96da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5911852e216c7059f46a620d8ce5a32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5911852e216c7059f46a620d8ce5a32"></a>
greal&#160;</td><td class="memItemRight" valign="bottom"><b>radiusOfGyration</b> (void) const </td></tr>
<tr class="separator:ae5911852e216c7059f46a620d8ce5a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8d3c09032f4d4779681353f3b60446"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a7d8d3c09032f4d4779681353f3b60446">reimage</a> ()</td></tr>
<tr class="separator:a7d8d3c09032f4d4779681353f3b60446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2a62540a7bceaecc4231cd8948ba6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf2a62540a7bceaecc4231cd8948ba6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#abf2a62540a7bceaecc4231cd8948ba6c">reimageByAtom</a> ()</td></tr>
<tr class="memdesc:abf2a62540a7bceaecc4231cd8948ba6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reimage atoms individually into the primary cell. <br /></td></tr>
<tr class="separator:abf2a62540a7bceaecc4231cd8948ba6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e9517fea9eeeb50b7cc66e1e09d148"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8e9517fea9eeeb50b7cc66e1e09d148"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#af8e9517fea9eeeb50b7cc66e1e09d148">remove</a> (pAtom pa)</td></tr>
<tr class="memdesc:af8e9517fea9eeeb50b7cc66e1e09d148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a single atom. <br /></td></tr>
<tr class="separator:af8e9517fea9eeeb50b7cc66e1e09d148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b74b1d9169c9a95fa152cedcd70b2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5b74b1d9169c9a95fa152cedcd70b2d"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ad5b74b1d9169c9a95fa152cedcd70b2d">remove</a> (std::vector&lt; pAtom &gt; pas)</td></tr>
<tr class="memdesc:ad5b74b1d9169c9a95fa152cedcd70b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a set of atoms. <br /></td></tr>
<tr class="separator:ad5b74b1d9169c9a95fa152cedcd70b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73e2cac9002750e1fd9f408b3b3547c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae73e2cac9002750e1fd9f408b3b3547c"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ae73e2cac9002750e1fd9f408b3b3547c">remove</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp)</td></tr>
<tr class="memdesc:ae73e2cac9002750e1fd9f408b3b3547c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all atoms in the passed grp that are also in the current group. <br /></td></tr>
<tr class="separator:ae73e2cac9002750e1fd9f408b3b3547c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49a8d5a7e61d51d7e4c3d2fd129030a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac49a8d5a7e61d51d7e4c3d2fd129030a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ac49a8d5a7e61d51d7e4c3d2fd129030a">removePeriodicBox</a> ()</td></tr>
<tr class="memdesc:ac49a8d5a7e61d51d7e4c3d2fd129030a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove periodicity. <br /></td></tr>
<tr class="separator:ac49a8d5a7e61d51d7e4c3d2fd129030a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb954f4f8e8ea1d561e79d03c4fbf6f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb954f4f8e8ea1d561e79d03c4fbf6f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#adb954f4f8e8ea1d561e79d03c4fbf6f3">renumber</a> (const int start=1, const int stride=1)</td></tr>
<tr class="memdesc:adb954f4f8e8ea1d561e79d03c4fbf6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renumber the atomid's of the contained atoms... <br /></td></tr>
<tr class="separator:adb954f4f8e8ea1d561e79d03c4fbf6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b461aac137353d384db9098e8e2433b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a6b461aac137353d384db9098e8e2433b">resetAtomIndices</a> ()</td></tr>
<tr class="memdesc:a6b461aac137353d384db9098e8e2433b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the atom indices (used for interfacing with trajectories)  <a href="#a6b461aac137353d384db9098e8e2433b">More...</a><br /></td></tr>
<tr class="separator:a6b461aac137353d384db9098e8e2433b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727648708aee3f4a3af63aa76cc9b73f"><td class="memItemLeft" align="right" valign="top">greal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a727648708aee3f4a3af63aa76cc9b73f">rmsd</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;)</td></tr>
<tr class="memdesc:a727648708aee3f4a3af63aa76cc9b73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the RMSD between two groups.  <a href="#a727648708aee3f4a3af63aa76cc9b73f">More...</a><br /></td></tr>
<tr class="separator:a727648708aee3f4a3af63aa76cc9b73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d3e12ceabe2ce225fa263db16884a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5d3e12ceabe2ce225fa263db16884a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ac5d3e12ceabe2ce225fa263db16884a4">rotate</a> (const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;axis, const greal angle_in_degrees)</td></tr>
<tr class="memdesc:ac5d3e12ceabe2ce225fa263db16884a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate group's coordinates (right-handed, about centroid) <br /></td></tr>
<tr class="separator:ac5d3e12ceabe2ce225fa263db16884a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36b81018fa18e77483f5014ffe8749d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae36b81018fa18e77483f5014ffe8749d"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ae36b81018fa18e77483f5014ffe8749d">select</a> (const <a class="el" href="structloos_1_1_atom_selector.html">AtomSelector</a> &amp;sel) const </td></tr>
<tr class="memdesc:ae36b81018fa18e77483f5014ffe8749d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a group consisting of atoms for which sel predicate returns true... <br /></td></tr>
<tr class="separator:ae36b81018fa18e77483f5014ffe8749d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f01a0fa6b0ccf7ae7400b2530f85051"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a6f01a0fa6b0ccf7ae7400b2530f85051">setCoords</a> (double *seq, int m, int n)</td></tr>
<tr class="separator:a6f01a0fa6b0ccf7ae7400b2530f85051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae074c74bdaa55894ef822075d831010f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae074c74bdaa55894ef822075d831010f"></a>
<a class="el" href="classloos_1_1_shared_periodic_box.html">loos::SharedPeriodicBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ae074c74bdaa55894ef822075d831010f">sharedPeriodicBox</a> () const </td></tr>
<tr class="memdesc:ae074c74bdaa55894ef822075d831010f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide access to the underlying shared periodic box... <br /></td></tr>
<tr class="separator:ae074c74bdaa55894ef822075d831010f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a46c22888a8ef8021c41ab6a56b177"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1a46c22888a8ef8021c41ab6a56b177"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (void) const </td></tr>
<tr class="separator:ae1a46c22888a8ef8021c41ab6a56b177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4df4c4e55665b8c6f8d09fc467fc35c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4df4c4e55665b8c6f8d09fc467fc35c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ae4df4c4e55665b8c6f8d09fc467fc35c">sort</a> (void)</td></tr>
<tr class="memdesc:ae4df4c4e55665b8c6f8d09fc467fc35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort based on atomid. <br /></td></tr>
<tr class="separator:ae4df4c4e55665b8c6f8d09fc467fc35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c44a3c614264f47bfa0cde05ad3db5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a85c44a3c614264f47bfa0cde05ad3db5">sorted</a> (void) const </td></tr>
<tr class="memdesc:a85c44a3c614264f47bfa0cde05ad3db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the array of atoms already sorted???  <a href="#a85c44a3c614264f47bfa0cde05ad3db5">More...</a><br /></td></tr>
<tr class="separator:a85c44a3c614264f47bfa0cde05ad3db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5c1e3c4acc114cb54bc68d40153f6d"><td class="memItemLeft" align="right" valign="top">greal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a5b5c1e3c4acc114cb54bc68d40153f6d">sphericalVariance</a> (const pAtom) const </td></tr>
<tr class="memdesc:a5b5c1e3c4acc114cb54bc68d40153f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spherical variance of group with respect to target atom.  <a href="#a5b5c1e3c4acc114cb54bc68d40153f6d">More...</a><br /></td></tr>
<tr class="separator:a5b5c1e3c4acc114cb54bc68d40153f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af32bd5df3cac2cf25a431d8cac443e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4af32bd5df3cac2cf25a431d8cac443e"></a>
greal&#160;</td><td class="memItemRight" valign="bottom"><b>sphericalVariance</b> (const <a class="el" href="classloos_1_1_coord.html">GCoord</a>) const </td></tr>
<tr class="separator:a4af32bd5df3cac2cf25a431d8cac443e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bae9400609d329e7d445e57fbb989e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bae9400609d329e7d445e57fbb989e9"></a>
std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a7bae9400609d329e7d445e57fbb989e9">splitByMolecule</a> (void) const </td></tr>
<tr class="memdesc:a7bae9400609d329e7d445e57fbb989e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of AtomicGroups split based on bond connectivity. <br /></td></tr>
<tr class="separator:a7bae9400609d329e7d445e57fbb989e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edb32f41f97125016d6f70908263ce5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8edb32f41f97125016d6f70908263ce5"></a>
std::map&lt; std::string, <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a8edb32f41f97125016d6f70908263ce5">splitByName</a> (void) const </td></tr>
<tr class="memdesc:a8edb32f41f97125016d6f70908263ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of AtomicGroups, each containing atoms with the same name. <br /></td></tr>
<tr class="separator:a8edb32f41f97125016d6f70908263ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946c264e25c6a8decfdf1efd7d0586ee"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a946c264e25c6a8decfdf1efd7d0586ee">splitByResidue</a> (void) const </td></tr>
<tr class="memdesc:a946c264e25c6a8decfdf1efd7d0586ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of AtomicGroups, each comprising a single residue.  <a href="#a946c264e25c6a8decfdf1efd7d0586ee">More...</a><br /></td></tr>
<tr class="separator:a946c264e25c6a8decfdf1efd7d0586ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18396f6467d8bfad2492e3a444799855"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a18396f6467d8bfad2492e3a444799855">splitByUniqueSegid</a> (void) const </td></tr>
<tr class="memdesc:a18396f6467d8bfad2492e3a444799855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of AtomicGroups split from the current group based on segid.  <a href="#a18396f6467d8bfad2492e3a444799855">More...</a><br /></td></tr>
<tr class="separator:a18396f6467d8bfad2492e3a444799855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabbe2dcc5ce2aa4f9a46873d0d5a7e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#aaabbe2dcc5ce2aa4f9a46873d0d5a7e8">subset</a> (const int offset, const int len=0)</td></tr>
<tr class="memdesc:aaabbe2dcc5ce2aa4f9a46873d0d5a7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classloos_1_1_atomic_group.html#aaabbe2dcc5ce2aa4f9a46873d0d5a7e8" title="subset() and excise() args are patterned after perl&#39;s substr... ">subset()</a> and <a class="el" href="classloos_1_1_atomic_group.html#a8f001aeb52990a0b0c992bde74053376" title="excise returns the excised atoms as a group... ">excise()</a> args are patterned after perl's substr...  <a href="#aaabbe2dcc5ce2aa4f9a46873d0d5a7e8">More...</a><br /></td></tr>
<tr class="separator:aaabbe2dcc5ce2aa4f9a46873d0d5a7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc303bb0118c356d6878f75855742733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_matrix44.html">GMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#afc303bb0118c356d6878f75855742733">superposition</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;)</td></tr>
<tr class="memdesc:afc303bb0118c356d6878f75855742733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the transformation matrix for superposition of groups.  <a href="#afc303bb0118c356d6878f75855742733">More...</a><br /></td></tr>
<tr class="separator:afc303bb0118c356d6878f75855742733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee3d2984aca0ca7341766bd5d3a7d00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afee3d2984aca0ca7341766bd5d3a7d00"></a>
greal&#160;</td><td class="memItemRight" valign="bottom"><b>totalCharge</b> (void) const </td></tr>
<tr class="separator:afee3d2984aca0ca7341766bd5d3a7d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59520b699fbba866352b818b7b5b9bd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59520b699fbba866352b818b7b5b9bd3"></a>
greal&#160;</td><td class="memItemRight" valign="bottom"><b>totalMass</b> (void) const </td></tr>
<tr class="separator:a59520b699fbba866352b818b7b5b9bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093499187c8cb7e4c919ce36e7b873ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a093499187c8cb7e4c919ce36e7b873ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a093499187c8cb7e4c919ce36e7b873ab">translate</a> (const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;v)</td></tr>
<tr class="memdesc:a093499187c8cb7e4c919ce36e7b873ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate an atomic group by vector v. <br /></td></tr>
<tr class="separator:a093499187c8cb7e4c919ce36e7b873ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d80786ac74363404fb5a7f8a4d4b28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51d80786ac74363404fb5a7f8a4d4b28"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a51d80786ac74363404fb5a7f8a4d4b28">within</a> (const double dist, <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp) const </td></tr>
<tr class="memdesc:a51d80786ac74363404fb5a7f8a4d4b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find atoms in the current group that are within <em>dist</em> angstroms of any atom in <em>grp</em>. <br /></td></tr>
<tr class="separator:a51d80786ac74363404fb5a7f8a4d4b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978cd4429b3dd51e07e0f73b2e62912d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a978cd4429b3dd51e07e0f73b2e62912d"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#a978cd4429b3dd51e07e0f73b2e62912d">within</a> (const double dist, <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box) const </td></tr>
<tr class="memdesc:a978cd4429b3dd51e07e0f73b2e62912d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find atoms in <em>grp</em> that are within <em>dist</em> angstroms of atoms in the current group, considering periodicity. <br /></td></tr>
<tr class="separator:a978cd4429b3dd51e07e0f73b2e62912d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a33c54758a5fbee379f6f3fa442c71044"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33c54758a5fbee379f6f3fa442c71044"></a>
static const double&#160;</td><td class="memItemRight" valign="bottom"><b>superposition_zero_singular_value</b> = 1e-10</td></tr>
<tr class="separator:a33c54758a5fbee379f6f3fa442c71044"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae879f425747b04dd2254770990cb5bea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae879f425747b04dd2254770990cb5bea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setGroupConnectivity</b> ()</td></tr>
<tr class="separator:ae879f425747b04dd2254770990cb5bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa568698d3ece67936eacda77df4c5f84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa568698d3ece67936eacda77df4c5f84"></a>
std::vector&lt; pAtom &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>atoms</b></td></tr>
<tr class="separator:aa568698d3ece67936eacda77df4c5f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1509b8935261a029a9a19698cfd47a40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1509b8935261a029a9a19698cfd47a40"></a>
<a class="el" href="classloos_1_1_shared_periodic_box.html">loos::SharedPeriodicBox</a>&#160;</td><td class="memItemRight" valign="bottom"><b>box</b></td></tr>
<tr class="separator:a1509b8935261a029a9a19698cfd47a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac63f9cf552c3640708fc6462d6a6ae9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac63f9cf552c3640708fc6462d6a6ae9e"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html#ac63f9cf552c3640708fc6462d6a6ae9e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp)</td></tr>
<tr class="memdesc:ac63f9cf552c3640708fc6462d6a6ae9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the group in pseudo-XML format... <br /></td></tr>
<tr class="separator:ac63f9cf552c3640708fc6462d6a6ae9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for handling groups of Atoms (pAtoms, actually) </p>
<p>This class contains a collection of shared pointers to Atoms (i.e. pAtoms). Copying an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> is a light-copy. You can, however, perform a deep copy by using the <a class="el" href="classloos_1_1_atomic_group.html#a1126df7bc01ffad44a95537f5ce40248" title="Creates a deep copy of this group. ">AtomicGroup::copy()</a> method. Note that atomid's are assumed to be unique for any given <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a>.</p>
<p>Valid operators are '+' and '+=' and can combine either <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> objects or pAtom objects.</p>
<p>AtomicGroups also support periodic boundary conditions via the <a class="el" href="classloos_1_1_atomic_group.html#abe7df3660d00eb14a49e33f40b80878d" title="Fetch the periodic boundary conditions. ">periodicBox()</a> method. If a box has been set, then <a class="el" href="classloos_1_1_atomic_group.html#a8338a644424edb15159502ade2ce1c33" title="Test whether or not periodic boundary conditions are set. ">isPeriodic()</a> will return true. The periodic box is shared between the parent group and all derived groups. <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> copies have non-shared periodic boxes... </p>

<p>Definition at line <a class="el" href="_atomic_group_8hpp_source.html#l00087">87</a> of file <a class="el" href="_atomic_group_8hpp_source.html">AtomicGroup.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a125a4b144bc5457366ae204e8f98f446"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">loos::AtomicGroup::AtomicGroup </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> with <em>n</em> un-initialized atoms. </p>
<p>The atoms will all have ascending atomid's beginning with 1, but otherwise no other properties will be set. </p>

<p>Definition at line <a class="el" href="_atomic_group_8hpp_source.html#l00104">104</a> of file <a class="el" href="_atomic_group_8hpp_source.html">AtomicGroup.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9d1966c971d7730391d417bcdfd1486e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_matrix44.html">GMatrix</a> loos::AtomicGroup::alignOnto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>grp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Superimposes the current group onto the passed group. </p>
<p>Calls superposition to calculate the transformation matrix to superimpose the current group onto the passed one, then applies the transformation to the current group's coordinates. </p>

<p>Definition at line <a class="el" href="_a_g__linalg_8cpp_source.html#l00196">196</a> of file <a class="el" href="_a_g__linalg_8cpp_source.html">AG_linalg.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a300ee7d7bb26e246c1cd78829191a4fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T loos::AtomicGroup::apply </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a functor or a function to each atom in the group. </p>
<p><a class="el" href="classloos_1_1_atomic_group.html#a300ee7d7bb26e246c1cd78829191a4fd" title="Apply a functor or a function to each atom in the group. ">apply()</a> let's you apply a functor or a function pointer to each atom in the group. The functor is passed a pAtom. The functor object is also returned (in case it retained state). For example, the following code snippet shows how to calculate the centroid of a group using apply and a functor... </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Functor {</div><div class="line">Functor() : C(GCoord(0,0,0)), n(0) { }</div><div class="line"><span class="keywordtype">void</span> operator()(pAtom&amp; p) { C += p-&gt;coords(); ++n; }</div><div class="line">GCoord center(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span>(C/n); }</div><div class="line"></div><div class="line">GCoord C;</div><div class="line"><span class="keywordtype">int</span> n;</div><div class="line">};</div><div class="line"></div><div class="line">Functor f = group.apply(Functor());</div><div class="line">GCoord <a class="code" href="classloos_1_1_atomic_group.html#ad26667576771cba32914ee97113a3b7f">centroid</a> = f.center();</div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="_atomic_group_8hpp_source.html#l00516">516</a> of file <a class="el" href="_atomic_group_8hpp_source.html">AtomicGroup.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c50256c66c58e818df2090b1cdce05c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint &gt; loos::AtomicGroup::atomOrderMapFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map the order of atoms in <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> g into the current group. </p>
<p>Note that the order is only checked within a residue. The residues must appear in the same order between the two groups. This addresses edge issues such as when psfgen reorders the atoms within a residue. The map is an index into the <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> g that puts g into the same order as the current group. </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00959">959</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="add1d65a15ea4b388fa2953ca1b8debb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; loos::AtomicGroup::boundingBox </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bounding box for the group... </p>
<p>Returns a vector containing 2 GCoords, one containing (minx, miny, minz) and the other (maxx, maxy, maxz) </p>

<p>Definition at line <a class="el" href="_a_g__numerical_8cpp_source.html#l00050">50</a> of file <a class="el" href="_a_g__numerical_8cpp_source.html">AG_numerical.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a429f96e9a94724ec68796f4c856f76b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_coord.html">GCoord</a> loos::AtomicGroup::centerAtOrigin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates the group so that the centroid is at the origin. </p>
<p>Returns the old centroid of the group </p>

<p>Definition at line <a class="el" href="_a_g__numerical_8cpp_source.html#l00351">351</a> of file <a class="el" href="_a_g__numerical_8cpp_source.html">AG_numerical.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b50bb3c98f7ddda72c7e0dddd95ea60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::centrifyByMolecule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a group with the center of masses of contained molecules. </p>
<p>The <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> is split into molecules. A new group is constructed where each atom is the center of mass of one molecule. The atom metadata is taken from the first atom of the associated molecule, but with the atom name "CEN". </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l01047">1047</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02ca8a6697b307b2ef86362c17b1c402"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> * loos::AtomicGroup::clone </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a lightweight clone of this group (for polymorphism) </p>
<p>Despite the name, this is meant for polymorphic use. It is <em>not</em> a deep copy. If you don't understand what any of this means, then you almost certainly want to be using the <a class="el" href="classloos_1_1_atomic_group.html#a1126df7bc01ffad44a95537f5ce40248" title="Creates a deep copy of this group. ">copy()</a> method instead. </p>

<p>Reimplemented in <a class="el" href="classloos_1_1_amber.html#abbed41ab7a29e2de2cdb95357a10affb">loos::Amber</a>, <a class="el" href="classloos_1_1_p_d_b.html#af3d225dd1d98480d16eaf4d5fc6f9db7">loos::PDB</a>, <a class="el" href="classloos_1_1_p_s_f.html#a8e3af32c07a708706a2ef55351a616ac">loos::PSF</a>, <a class="el" href="classloos_1_1_c_h_a_r_m_m.html#a16fffbf58bdd5da486b41233acf5e5c7">loos::CHARMM</a>, and <a class="el" href="classloos_1_1_tinker_x_y_z.html#a5f81294d0382b5f29782604f5e281f7f">loos::TinkerXYZ</a>.</p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00051">51</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab34fb9545f24da183577fb81de246c9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool loos::AtomicGroup::contactWith </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint&#160;</td>
          <td class="paramname"><em>min</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if any atom of current group is within <em>dist</em> angstroms of <em>grp</em>. </p>
<p><em>min</em> is the minimum number of pair-wise contacts required to be considered in contact </p>

<p>Definition at line <a class="el" href="_atomic_group_8hpp_source.html#l00466">466</a> of file <a class="el" href="_atomic_group_8hpp_source.html">AtomicGroup.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7f9a440e52b34d9d520ee1443e6a7e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool loos::AtomicGroup::contactWith </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint&#160;</td>
          <td class="paramname"><em>min</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if any atom of current group is within <em>dist</em> angstroms of <em>grp</em>. </p>
<p><em>min</em> is the minimum number of pair-wise contacts required to be considered in contact </p>

<p>Definition at line <a class="el" href="_atomic_group_8hpp_source.html#l00476">476</a> of file <a class="el" href="_atomic_group_8hpp_source.html">AtomicGroup.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1eee0b50387264fc2cd8739a569689c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EqualsOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool loos::AtomicGroup::contains </td>
          <td>(</td>
          <td class="paramtype">const pAtom &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EqualsOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a pAtom is contained in this group using the EqualsOp atom-equality policy. </p>
<p>The problem with determining containment/intersection/etc is how to define when two atoms are equal... This is done by specifying a comparison functor (the EqualsOp) as a policy. There are two comparison policies currently in LOOS: <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid. ">AtomEquals</a> and <a class="el" href="structloos_1_1_atom_coords_equals.html" title="Compares two atoms based on name, id, resid, resname, segid, and coords. ">AtomCoordsEquals</a>. The default behavior is to use <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid. ">AtomEquals</a> which only compares a subset of the available <a class="el" href="classloos_1_1_atom.html" title="Basic Atom class for handling atom properties. ">Atom</a> metadata. You can specify the more restrictive policy (or an user-defined policy) like: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> b = group.contains(an_atom, <a class="code" href="structloos_1_1_atom_coords_equals.html">loos::AtomCoordsEquals</a>());</div></div><!-- fragment --><p>Or as another example, comparing only residue numbers... </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ResidEquals : <span class="keyword">public</span> std::binary_function&lt;pAtom, pAtom, bool&gt; {</div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> pAtom&amp; a, <span class="keyword">const</span> pAtom&amp; b) { <span class="keywordflow">return</span>(a.resid() == b.resid()); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> b = group.contains(an_atom, ResidEquals());</div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="_atomic_group_8hpp_source.html#l00239">239</a> of file <a class="el" href="_atomic_group_8hpp_source.html">AtomicGroup.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1126df7bc01ffad44a95537f5ce40248"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::copy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a deep copy of this group. </p>
<p>This creates a non-polymorphic deep copy of an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a>. The additional catch is that it may end up involving extra data-movement as the copy is constructed and then copied back out to wherever you're putting it. </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00056">56</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a922415f440fece32f23da2103cdc8d0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::copyCoordinatesFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy coordinates from g into current group. </p>
<p>The offset is relative to the start of the current group and length is the number of coordinates to copy. If length + offset is greater than the number of atoms in the current group, then the excess coordinates will not be copied.</p>
<p>If length is 0, then all coordinates in g will be copied.</p>
<p>It is assumed that the atoms in g are in the appropriate order relative to the current group for the copy to make sense. </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00950">950</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3fd03b1c9bfad1e983b3c616350304cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::copyMappedCoordinatesFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a mapping of atom order, copy the coordinates into the current group. </p>
<p>See <a class="el" href="classloos_1_1_atomic_group.html#a6c50256c66c58e818df2090b1cdce05c" title="Map the order of atoms in AtomicGroup g into the current group. ">AtomicGroup::atomOrderMapFrom(const AtomicGroup&amp; g)</a> for more information</p>
<p>If you know that the atoms are in the same order in both groups, then <a class="el" href="classloos_1_1_atomic_group.html#a922415f440fece32f23da2103cdc8d0d" title="Copy coordinates from g into current group. ">AtomicGroup::copyCoordinatesFrom()</a> will be faster... </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00987">987</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a3a1163fdcd8234a4e78dda2fb9bf0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::copyMappedCoordinatesFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the coordinates from the group mapping the atom order. </p>
<p>See AtomicGroup::atomOrderFrom(const AtomicGroup&amp; g) for more information</p>
<p>If you know that the atoms are in the same order in both groups, then <a class="el" href="classloos_1_1_atomic_group.html#a922415f440fece32f23da2103cdc8d0d" title="Copy coordinates from g into current group. ">AtomicGroup::copyCoordinatesFrom()</a> will be faster... </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00997">997</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c5a37ae808c139a54eb8049601ffc85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::copyVelocitiesWithIndex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>velocities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy velocities from a vector of GCoords using the atom index as an index into the vector. </p>
<p>This can be used to update a group's velocities if they come from a separate trajectory... </p><div class="fragment"><div class="line">pTraj trajcrds = createTrajectory(<span class="stringliteral">&#39;foo.dcd&#39;</span>, model);</div><div class="line">pTraj trajvels = createTrajectory(<span class="stringliteral">&#39;foo-velocities.dcd&#39;</span>, model);</div><div class="line"></div><div class="line"><span class="keywordflow">while</span> (trajcrds-&gt;readFrame()) {</div><div class="line">   trajcrds-&gt;updateGroupCoords(model);</div><div class="line"></div><div class="line">   trajvels-&gt;readFrame();</div><div class="line">   model.copyVelocitiesWithIndex(trajvels-&gt;coords());</div><div class="line">}</div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00937">937</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afbf2ee4a474c487db2dab7651ddb5204"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint loos::AtomicGroup::deduceAtomicNumberFromMass </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduce atomic number from mass (if present), returning number of atoms assigned. </p>
<p>If an atom has a mass, then this is used to look up it's atomic number. Note that LOOS only has the first 96 elements in its tables. If a mass is not found in the LOOS table, then the atomic number is not modified (or set), otherwise any existing atomic number is overwritten. </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00909">909</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27b5b12845449dddc4df4cc16fa89b30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::findBonds </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distance-based search for bonds. </p>
<p>Searches for bonds within an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> based on distance. does NOT clear the existing bond list prior to building new bonds. The default distance cutoff is 1.65. If a box (GCoord) is passed, then periodicity is taken into consideration. </p>

<p>Definition at line <a class="el" href="_atomic_group_8hpp_source.html#l00489">489</a> of file <a class="el" href="_atomic_group_8hpp_source.html">AtomicGroup.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7a8aadcfcaa3e8a49169e1262dd2b115"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pAtom loos::AtomicGroup::findById </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a contained atom by its atomid. </p>
<p>The default behavior is to assume that the atoms in the <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> are not in order of increasing atomid and to therefore use a linear search. If the atoms are sorted (<a class="el" href="classloos_1_1_atomic_group.html#ae4df4c4e55665b8c6f8d09fc467fc35c" title="Sort based on atomid. ">AtomicGroup::sort()</a>), then the more efficient binary search will be used. </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00520">520</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a605b30aef2f4da808eb92ec0ae0fe9f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::getCoords </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>outseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is meant for Numpy/swig use. It will store the current model's coordinates into a newly allocated array (using malloc). The caller is expected to manage the memory. </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l01035">1035</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b5f36f01919f6b54fa410e956c02816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::getResidue </td>
          <td>(</td>
          <td class="paramtype">pAtom&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an <a class="el" href="classloos_1_1_atom.html" title="Basic Atom class for handling atom properties. ">Atom</a>, return a group of all the atoms contained by its containing residue </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00555">555</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab786587c1ed62f04afa1d64781ad06cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; loos::AtomicGroup::getTransformedCoords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_x_form.html">XForm</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of coordinates transformed by the passed <a class="el" href="classloos_1_1_x_form.html" title="Matrix class for handling coordinate transforms... ">XForm</a>. </p>
<p>Does not alter the group's coordinates... </p>

<p>Definition at line <a class="el" href="_a_g__numerical_8cpp_source.html#l00254">254</a> of file <a class="el" href="_a_g__numerical_8cpp_source.html">AG_numerical.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab241f7c4aa73dbefb6cb1d26d13ea7f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::groupFromID </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>id_list</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new group from a vector of atomids. </p>
<p>Note: when calling this, you'll want to make sure you use the outermost group (eg the psf or pdb you used to create things, rather than using a subselection, unless you're sure the subsection contains these atoms as well. The main use of this routine is to create a group of atoms bound to another atom.</p>
<p>Any missing atoms are ignored... This is in contrast with the previous behavior where missing atoms would throw an exception </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00539">539</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a872a5b02eca7320f51181b5a8385e6e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EqualsOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EqualsOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the intersection of two groups using the EqualsOp atom-equality policy. </p>
<p>See AtomicGroup::contains(const pAtom&amp;, const EqualsOp&amp;) for more details </p>

<p>Definition at line <a class="el" href="_atomic_group_8hpp_source.html#l00277">277</a> of file <a class="el" href="_atomic_group_8hpp_source.html">AtomicGroup.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb7901950b11a6f06080ee338bd53b72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">greal loos::AtomicGroup::kineticEnergy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute kinetic energy of group. </p>
<p>Assumes mass and velocity have been set. Output units are kcal/mol </p>

<p>Definition at line <a class="el" href="_a_g__numerical_8cpp_source.html#l00241">241</a> of file <a class="el" href="_a_g__numerical_8cpp_source.html">AG_numerical.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a565774cc283d8e5e65fc486330c744f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EqualsOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EqualsOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Union of two groups using the specified atom-equality policy. </p>
<p>Note that the periodic box of the current group is unchanged by this operation </p>

<p>Definition at line <a class="el" href="_atomic_group_8hpp_source.html#l00295">295</a> of file <a class="el" href="_atomic_group_8hpp_source.html">AtomicGroup.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab8224e853282a81e55ca83fc8594cd80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::mergeImage </td>
          <td>(</td>
          <td class="paramtype">pAtom &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a group that's split across a periodic boundary and reimages it so it's all together. </p>
<p>Works by translating the system so one atom is in the center of the box, reimaging by atom (so now the group is all in the middle of the box), and then translating back.</p>
<p>If you don't want to give it a reference atom, call the version that takes no argument; it uses the first atom in the <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a>. </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00835">835</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b136bf681b267e113c35a6651cbfe51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::mergeImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a group that's split across a periodic boundary and reimages it so it's all together, using the first atom in the <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> as the reference. </p>
<p>Does the same as the other mergeImage, only using the first atom in the <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> as the reference atom. </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00846">846</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a0204deda6ace2293fe0675812f4f8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; loos::AtomicGroup::momentsOfInertia </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the moments of inertia for a group. </p>
<p>Calculates the principal moments and principal axes (from the moment of inertia). This is distinct from the <a class="el" href="classloos_1_1_atomic_group.html#ab9ce39f2d7a53db0f5cc858db1b3607a" title="Compute the principal axes of a group. ">principalAxes()</a> function which calculates the distribution of points about the centroid. </p>

<p>Definition at line <a class="el" href="_a_g__linalg_8cpp_source.html#l00048">48</a> of file <a class="el" href="_a_g__linalg_8cpp_source.html">AG_linalg.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a838252229a0bae82a0c6184c4a7638ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool loos::AtomicGroup::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality test for two groups. </p>
<p>The test for equality is based on whether or not the contained atom pointers are the same. This operator will also force both sides of the equation to be sorted. </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00749">749</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0288588db8433e56c11899419ac8fa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool loos::AtomicGroup::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality test for const groups. </p>
<p>Similar to the non-const version, but it will sort <em>copies</em> of the atom lists if they are not already sorted... </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00769">769</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9ce39f2d7a53db0f5cc858db1b3607a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; loos::AtomicGroup::principalAxes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the principal axes of a group. </p>
<p>Calculates the eigendecomposition of AA' where A is column-wise concatenation of coordinates from all atoms in the group. The mean coordinate is automatically subtracted from A... Returns a vector of GCoord's in order of decreasing magnitude of the corresponding eigenvalue. The eigenvalues are returned as a GCoord after the eigenvectors.</p>
<p>Example </p><div class="fragment"><div class="line">vector&lt;GCoord&gt; V = group_of_atoms.principalAxes();</div><div class="line">GCoord eigenvalues = V[3];</div><div class="line">GCoord first_eigenvector = V[0];   <span class="comment">// Most significant</span></div><div class="line">GCoord second_eigenvector = V[1];</div><div class="line">GCoord third_eigenvector = V[2];   <span class="comment">// Least significant</span></div></div><!-- fragment --><p>Notes</p><ul>
<li>Any errors encountered in the BLAS/LAPACK routines cause a runtime exception to be thrown...</li>
<li><a class="el" href="classloos_1_1_coord.html" title="Basic 3-D coordinates class. ">Coord</a> type of contained atoms will always be upcast to double.</li>
<li>Potential issue with f77int under linux when not on a 64-bit architecture. </li>
</ul>

<p>Definition at line <a class="el" href="_a_g__linalg_8cpp_source.html#l00104">104</a> of file <a class="el" href="_a_g__linalg_8cpp_source.html">AG_linalg.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab682d7a74a46a65d920f0e362bc72c5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::pruneBonds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to prune connectivity (only retain bonds to atoms within this <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a>) </p>
<p>The connectivity list is searched for each atom and if a bond is not found in the current group, then it is removed from the bond-list for that atom. Note that this means that any <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> sharing the atom in question will also now have the modified bond list. It's therefore recommended that this function be called on a copy (<a class="el" href="classloos_1_1_atomic_group.html#a1126df7bc01ffad44a95537f5ce40248" title="Creates a deep copy of this group. ">AtomicGroup::copy()</a>). Also note that FindById() does not implicitly sort the atoms for more efficient searching. You may want to call <a class="el" href="classloos_1_1_atomic_group.html#ae4df4c4e55665b8c6f8d09fc467fc35c" title="Sort based on atomid. ">AtomicGroup::sort()</a> prior to <a class="el" href="classloos_1_1_atomic_group.html#ab682d7a74a46a65d920f0e362bc72c5a" title="Attempt to prune connectivity (only retain bonds to atoms within this AtomicGroup) ...">AtomicGroup::pruneBonds()</a> if the exact atom order does not matter. </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00872">872</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03f304c334d971041e5258bd2cab96da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">greal loos::AtomicGroup::radius </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_atom_as_reference</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum radius from centroid of all atoms (not gyration) </p>
<p>If optional argument is true, uses coordinates of atom 0 instead of centroid. Argument is false by default. </p>

<p>Definition at line <a class="el" href="_a_g__numerical_8cpp_source.html#l00164">164</a> of file <a class="el" href="_a_g__numerical_8cpp_source.html">AG_numerical.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d8d3c09032f4d4779681353f3b60446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::reimage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate the entire group so that the centroid is in the primary cell </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00803">803</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b461aac137353d384db9098e8e2433b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::resetAtomIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the atom indices (used for interfacing with trajectories) </p>
<p>The <a class="el" href="classloos_1_1_atom.html" title="Basic Atom class for handling atom properties. ">Atom</a> index is the original ordering of atoms from whatever file format the model came from. This is used as an index into each frame of the trajectory for corresponding atom properties (such as coordinates). If an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> is a subset, then it may be necessary to reset the indices when working with a subsetted trajectory as well. This function will reset the atom indices to be sequential, beginning with 0. </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00895">895</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a727648708aee3f4a3af63aa76cc9b73f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">greal loos::AtomicGroup::rmsd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the RMSD between two groups. </p>
<p>Sorts both groups (if necessary), then assumes a 1:1 correspondence between ith atoms. </p>

<p>Definition at line <a class="el" href="_a_g__numerical_8cpp_source.html#l00222">222</a> of file <a class="el" href="_a_g__numerical_8cpp_source.html">AG_numerical.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f01a0fa6b0ccf7ae7400b2530f85051"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::setCoords </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is meant for Numpy/swig use in setting the model's coordinates. The passed array is row-major. </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l01025">1025</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a85c44a3c614264f47bfa0cde05ad3db5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool loos::AtomicGroup::sorted </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the array of atoms already sorted??? </p>
<p>While we make some effort to ensure that alterations to the <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> will invalidate the sorted status, it's a good idea to explicitly sort if you want to make sure that the group is in fact sorted. </p>

<p>Definition at line <a class="el" href="_atomic_group_8hpp_source.html#l00411">411</a> of file <a class="el" href="_atomic_group_8hpp_source.html">AtomicGroup.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b5c1e3c4acc114cb54bc68d40153f6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">greal loos::AtomicGroup::sphericalVariance </td>
          <td>(</td>
          <td class="paramtype">const pAtom&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spherical variance of group with respect to target atom. </p>
<p>spherical variance as a measure of how much atom "target" is inside this atomic group Mezei, J Mol Graph Modeling, 2003, 21, 463-472 </p>

<p>Definition at line <a class="el" href="_a_g__numerical_8cpp_source.html#l00204">204</a> of file <a class="el" href="_a_g__numerical_8cpp_source.html">AG_numerical.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a946c264e25c6a8decfdf1efd7d0586ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; loos::AtomicGroup::splitByResidue </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of AtomicGroups, each comprising a single residue. </p>
<p>Splits an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> into individual residues. The residue boundary is marked by either a change in the resid or in the segid. </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00461">461</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18396f6467d8bfad2492e3a444799855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; loos::AtomicGroup::splitByUniqueSegid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of AtomicGroups split from the current group based on segid. </p>
<p>The groups that are returned will be in the same order that the segids appear in the source <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually) ">AtomicGroup</a> </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00318">318</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaabbe2dcc5ce2aa4f9a46873d0d5a7e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::subset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classloos_1_1_atomic_group.html#aaabbe2dcc5ce2aa4f9a46873d0d5a7e8" title="subset() and excise() args are patterned after perl&#39;s substr... ">subset()</a> and <a class="el" href="classloos_1_1_atomic_group.html#a8f001aeb52990a0b0c992bde74053376" title="excise returns the excised atoms as a group... ">excise()</a> args are patterned after perl's substr... </p>
<p>If offset is negative, then it's relative to the end of the group. If length is 0, then everything from offset to the appropriate end is used... </p>

<p>Definition at line <a class="el" href="_atomic_group_8cpp_source.html#l00276">276</a> of file <a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc303bb0118c356d6878f75855742733"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_matrix44.html">GMatrix</a> loos::AtomicGroup::superposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>grp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the transformation matrix for superposition of groups. </p>
<p>Uses the Kabsch alignment method (via SVD) to calculate the transformation matrix that superimposes the current group onto the passed group. Returns the matrix.</p>
<p>If too few atoms are given for aligning, the correlation matrix may become singular and return fewer than three eigenpairs. If this is detected, <a class="el" href="classloos_1_1_atomic_group.html#afc303bb0118c356d6878f75855742733" title="Calculates the transformation matrix for superposition of groups. ">superposition()</a> will throw a <a class="el" href="classloos_1_1_numerical_error.html" title="Exception caused by a blas/atlas error. ">NumericalError</a>. The threshold for a zero-eigenvalue (really, a zero singular value) is set in AtomicGroup::superposition_zero_singular_value </p>

<p>Definition at line <a class="el" href="_a_g__linalg_8cpp_source.html#l00188">188</a> of file <a class="el" href="_a_g__linalg_8cpp_source.html">AG_linalg.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_atomic_group_8hpp_source.html">AtomicGroup.hpp</a></li>
<li>src/<a class="el" href="_a_g__linalg_8cpp_source.html">AG_linalg.cpp</a></li>
<li>src/<a class="el" href="_a_g__numerical_8cpp_source.html">AG_numerical.cpp</a></li>
<li>src/<a class="el" href="_atomic_group_8cpp_source.html">AtomicGroup.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceloos.html">loos</a></li><li class="navelem"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
